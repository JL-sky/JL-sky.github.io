[{"content":"本章节所有代码托管在miniOS_32\n章节任务介绍\r任务简介\r上一节，我们完成了用户程序和操作系统之间的接口——系统调用，本节我们在此基础上完善堆内存管理——实现malloc和free\n之前我们虽然已经实现了内存管理，但之前实现分配的内存都是以 4KB 大小的页框为单位的，当我们仅需要几十字节、几百字节这样的小内存块时，显然无法满足这样的需求了，为此必须实现一种小内存块的管理，可以满足任意内存大小的分配，这就是我们为实现malloc要做的基础工作。\n本节的主要任务有：\n实现sys_malloc 实现sys_free 实现malloc 实现free 内存分配\r底层初始化\r划分和管理内存块\r为了实现对小内存块的管理和分配\n我们将一页内存按照块大小平均划分 假如我们规定一块的内存大小是512B，则这页内存可以被分为4k/512B=8个块 为了适应不同块大小的分配，我们分别定义7种类型大小的内存块 接下来我们定义一些必要的数据结构，以下是这些数据结构之间的关系\n/kernel/memory.h\n首先是空闲内存块的定义\n1 2 3 4 5 6 7 8 9 10 11 12 /* 内存块描述符个数 对应16、32、64、128、256、512、1024这7种小内存块 */ #define DESC_CNT 7 /*内存块*/ struct mem_block { // 内存块使用双链表进行管理 struct list_elem free_elem; }; 为了对内存块进行管理，我们还需要定义内存块的信息管理数据结构\n1 2 3 4 5 6 7 8 9 10 /*内存块描述符*/ struct mem_block_desc { // 每个块的大小 uint32_t block_size; // 块的总数量 uint32_t blocks_per_arena; // 用于管理组织块的双链表结构的头节点 struct list free_list; }; 同时为了分配内存，我们需要记录空闲内存块的数量和位置\n/kernel/memory.c\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /* 内存仓库元信息 每个页面有7种类型大小的内存块 一个arena管理一种类型大小的内存块 */ struct arena { /*管理该种类型大小的内存块数组索引*/ struct mem_block_desc *desc; /* 标记是分配的页框还是内存块 如果是页框，则cnt表示页框的数量 如果是内存块，则cnt表示空闲内存块的数量 （注意，是空闲块的数量，mem_block_desc中表示的是块的总数） */ bool large; uint32_t cnt; }; 从哪申请内存块\r内存块的分配和释放本质上都是从内存池中进行申请和归还的，而我们有两种内存池——内核内存池和用户内存池\n其中内核内存池供内核程序使用，用户内存池供用户程序使用\n因此针对不同类型的内存池需要各自分别添加内存管理结构\n内核内存池\r/kernel/memory.c\n1 2 /*不同类型大小的内存块管理数组*/ struct mem_block_desc k_block_descs[DESC_CNT]; 用户内存池\r/thread/thread.h\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /* 进程或线程的pcb,程序控制块, 此结构体用于存储线程的管理信息*/ struct task_struct { uint32_t *self_kstack; // 用于存储线程的栈顶位置，栈顶放着线程要用到的运行信息 pid_t pid; // 定义线程或者进程的pid enum task_status status; uint8_t priority; // 线程优先级 char name[16]; // 用于存储自己的线程的名字 uint8_t ticks; // 线程允许上处理器运行还剩下的滴答值，因为priority不能改变，所以要在其之外另行定义一个值来倒计时 uint32_t elapsed_ticks; // 此任务自上cpu运行后至今占用了多少cpu嘀嗒数, 也就是此任务执行了多久*/ struct list_elem general_tag; // general_tag的作用是用于线程在一般的队列(如就绪队列或者等待队列)中的结点 struct list_elem all_list_tag; // all_list_tag的作用是用于线程队列thread_all_list（这个队列用于管理所有线程）中的结点 uint32_t *pgdir; // 进程自己页目录表的虚拟地址 struct virtual_addr userprog_vaddr; // 每个用户进程自己的虚拟地址池 struct mem_block_desc u_block_desc[DESC_CNT]; // 用户进程内存块描述符 uint32_t stack_magic; // 如果线程的栈无限生长，总会覆盖地pcb的信息，那么需要定义个边界数来检测是否栈已经到了PCB的边界 }; 上述主要为PCB数据结构添加内存块管理成员\n1 struct mem_block_desc u_block_desc[DESC_CNT]; // 用户进程内存块描述符 内存块管理初始化\r内核内存块管理初始化\r/kernel/memory.c\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /* 初始化内存块管理数组 分别对应16、32、64、128、256、512、1024这7种大小内存块类型 */ void block_desc_init(struct mem_block_desc *desc_array) { uint16_t desc_idx, block_size = 16; for (desc_idx = 0; desc_idx \u0026lt; DESC_CNT; desc_idx++) { // 块的大小 desc_array[desc_idx].block_size = block_size; // 块的总数 desc_array[desc_idx].blocks_per_arena = (PG_SIZE - sizeof(struct arena)) / block_size; // 管理组织块的双链表结构 list_init(\u0026amp;desc_array[desc_idx].free_list); block_size *= 2; } } 添加内存块管理结构的初始化入口\n1 2 3 4 5 6 7 8 9 /* 内存管理部分初始化入口 */ void mem_init() { put_str(\u0026#34;mem_init start\\n\u0026#34;); uint32_t mem_bytes_total = (*(uint32_t *)(0xb00)); mem_pool_init(mem_bytes_total); // 初始化内存池 block_desc_init(k_block_descs); put_str(\u0026#34;mem_init done\\n\u0026#34;); } 用户内存块管理初始化\r/userprog/process.c\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // 用于创建进程，参数是进程要执行的函数与他的名字 void process_execute(void *filename, char *name) { /* pcb内核的数据结构,由内核来维护进程信息,因此要在内核内存池中申请 */ struct task_struct *thread = get_kernel_pages(1); /*初始化pcb*/ init_thread(thread, name, default_prio); // 初始化进程pcb中特有的页目录表 thread-\u0026gt;pgdir = create_page_dir(); // 初始化进程虚拟内存池，进程有自己的虚拟内存 create_user_vaddr_bitmap(thread); // 初始化进程空闲链表管理数组 block_desc_init(thread-\u0026gt;u_block_desc); // 首先初始化线程栈运行环境，执行start_process // 然后初始化中断栈，此时的中断栈也是进程的运行栈，接着执行真正的执行函数filename thread_create(thread, start_process, filename); enum intr_status old_status = intr_disable(); ASSERT(!elem_find(\u0026amp;thread_ready_list, \u0026amp;thread-\u0026gt;general_tag)); list_append(\u0026amp;thread_ready_list, \u0026amp;thread-\u0026gt;general_tag); ASSERT(!elem_find(\u0026amp;thread_all_list, \u0026amp;thread-\u0026gt;all_list_tag)); list_append(\u0026amp;thread_all_list, \u0026amp;thread-\u0026gt;all_list_tag); intr_set_status(old_status); } 用户内存块的初始化在创建用户进程时进行，而用户进程的创建也是内核负责完成的，因此只需在用户创建函数中调用block_desc_init完成对pcb中内存块管理结构的初始化即可，如下\n1 2 // 初始化进程空闲链表管理数组 block_desc_init(thread-\u0026gt;u_block_desc); 实现sys_malloc\r/kernel/memory.c\n首先是一些必要的辅助函数\n1 2 3 4 5 6 7 8 9 10 11 12 /*返回arena中第idx个内存块的地址*/ static struct mem_block *arena2block(struct arena *a, uint32_t idx) { /*跨过arana元信息，然后按照块大小和索引值寻找对应内存块地址*/ return (struct mem_block *)((uint32_t)a + sizeof(struct arena) + idx * a-\u0026gt;desc-\u0026gt;block_size); } /*返回内存块block所在的arena地址*/ static struct arena *block2arena(struct mem_block *block) { return (struct arena *)((uint32_t)block \u0026amp; 0xfffff000); } 接下来正式实现sys_malloc\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 /*在堆中申请size字节的内存*/ void *sys_malloc(uint32_t size) { enum pool_flags PF; struct pool *mem_pool; uint32_t pool_size; struct mem_block_desc *descs; struct task_struct *cur_thread = running_thread(); // 判断从哪个内存池中申请内存 if (cur_thread-\u0026gt;pgdir == NULL) { // 如果是内存线程，就从内核内存池中申请内存 PF = PF_KERNEL; pool_size = kernel_pool.pool_size; mem_pool = \u0026amp;kernel_pool; descs = k_block_descs; } else { // 从用户内存池中申请内存 PF = PF_USER; pool_size = user_pool.pool_size; mem_pool = \u0026amp;user_pool; descs = cur_thread-\u0026gt;u_block_desc; } /* 若申请的内存不在内存池容量范围内则直接返回NULL */ if (!(size \u0026gt; 0 \u0026amp;\u0026amp; size \u0026lt; pool_size)) return NULL; struct arena *a; struct mem_block *block; lock_acquire(\u0026amp;mem_pool-\u0026gt;lock); /* 超过最大内存块1024, 就分配页框 */ if (size \u0026gt; 1024) { // 向上取整需要的页框数 uint32_t page_cnt = DIV_ROUND_UP(size + sizeof(struct arena), PG_SIZE); a = malloc_page(PF, page_cnt); if (a != NULL) { memset(a, 0, page_cnt * PG_SIZE); a-\u0026gt;desc = NULL; a-\u0026gt;cnt = page_cnt; a-\u0026gt;large = true; lock_release(\u0026amp;mem_pool-\u0026gt;lock); // 跨过arena大小，把剩下的内存返回 return (void *)(a + 1); } else { lock_release(\u0026amp;mem_pool-\u0026gt;lock); return NULL; } } // 若申请的内存小于等于1024,可在各种规格的mem_block_desc中去适配 else { uint8_t desc_idx; for (desc_idx = 0; desc_idx \u0026lt; DESC_CNT; desc_idx++) { // 首次适应，从小往大后,找到后退出 if (size \u0026lt;= descs[desc_idx].block_size) break; } /*找到了可以容纳申请大小的内存块类型，然后寻找空闲块*/ if (list_empty(\u0026amp;descs[desc_idx].free_list)) { // 如果链表为空，说明此时没有空闲块，就创建新块分配之 // 分配1页框做为arena a = malloc_page(PF, 1); if (a == NULL) { lock_release(\u0026amp;mem_pool-\u0026gt;lock); return NULL; } memset(a, 0, PG_SIZE); /* 对于分配的小块内存,将desc置为相应内存块描述符, * cnt置为此arena可用的内存块数,large置为false */ a-\u0026gt;desc = \u0026amp;descs[desc_idx]; a-\u0026gt;large = false; a-\u0026gt;cnt = descs[desc_idx].blocks_per_arena; uint32_t block_idx; enum intr_status old_status = intr_disable(); /* 开始将arena拆分成内存块,并添加到内存块描述符的free_list中 */ for (block_idx = 0; block_idx \u0026lt; descs[desc_idx].blocks_per_arena; block_idx++) { block = arena2block(a, block_idx); ASSERT(!elem_find(\u0026amp;a-\u0026gt;desc-\u0026gt;free_list, \u0026amp;block-\u0026gt;free_elem)); list_append(\u0026amp;a-\u0026gt;desc-\u0026gt;free_list, \u0026amp;block-\u0026gt;free_elem); } intr_set_status(old_status); } /* 开始分配内存块 */ // block = elem2entry(struct mem_block, free_elem, list_pop(\u0026amp;(descs[desc_idx].free_list))); block = list_pop(\u0026amp;(descs[desc_idx].free_list)); memset(block, 0, descs[desc_idx].block_size); a = block2arena(block); a-\u0026gt;cnt--; lock_release(\u0026amp;mem_pool-\u0026gt;lock); return (void *)block; } } 其代码逻辑为\n判断在哪种类型的内存池中申请内存块——内核内存池 or 用户内存池？ 判断申请的内存大小是否大于最大可分配类型大小的内存1024B 如果申请内存的块大小，大于最大可分配类型大小的内存1024B，则说明无法分配小的内存块，直接分配一页页框给申请者 否则转向步骤3 遍历各种类型大小的内存块，找到第一个满足申请内存大小的类型内存（首次适配算法）。如申请者申请500B的内存，遍历后发现256B\u0026lt;500B\u0026lt;512B，说明此时可以尝试去找一块空闲的512B的内存块分配给申请者 查看空闲链表是否为空，即查看是否有没有被分配的512B内存块 如果空闲链表为空，说明512B大小的内存块还没有创建或者已经被分配完了 则此时重新从内核中申请一页内存 然后将该页内存划分成7个（由于有arena的存在，可用的块只有7个）512B大小的内存块 然后将划分好的内存块插入到空闲链表中 如果空闲链表不为空，则转向5 空闲链表不为空，说明有可用的内存块使用，则从空闲链表中弹出然后分配给申请者 测试\r/kernel/main.c\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 #include \u0026#34;print.h\u0026#34; #include \u0026#34;init.h\u0026#34; #include \u0026#34;thread.h\u0026#34; #include \u0026#34;interrupt.h\u0026#34; #include \u0026#34;console.h\u0026#34; #include \u0026#34;process.h\u0026#34; #include \u0026#34;syscall-init.h\u0026#34; #include \u0026#34;syscall.h\u0026#34; #include \u0026#34;stdio.h\u0026#34; #include \u0026#34;memory.h\u0026#34; void k_thread_a(void *); void k_thread_b(void *); void u_prog_a(void); void u_prog_b(void); int main(void) { put_str(\u0026#34;I am kernel\\n\u0026#34;); init_all(); intr_enable(); thread_start(\u0026#34;k_thread_a\u0026#34;, 31, k_thread_a, \u0026#34;I am thread_a\u0026#34;); thread_start(\u0026#34;k_thread_b\u0026#34;, 31, k_thread_b, \u0026#34;I am thread_b \u0026#34;); while (1) ; return 0; } /* 在线程中运行的函数 */ void k_thread_a(void *arg) { char *para = arg; void *addr = sys_malloc(33); console_put_str(\u0026#34; I am thread_a, sys_malloc(33), addr is 0x\u0026#34;); console_put_int((int)addr); console_put_char(\u0026#39;\\n\u0026#39;); while (1) ; } /* 在线程中运行的函数 */ void k_thread_b(void *arg) { char *para = arg; void *addr = sys_malloc(63); console_put_str(\u0026#34; I am thread_b, sys_malloc(63), addr is 0x\u0026#34;); console_put_int((int)addr); console_put_char(\u0026#39;\\n\u0026#39;); while (1) ; } /* 测试用户进程 */ void u_prog_a(void) { char *name = \u0026#34;prog_a\u0026#34;; printf(\u0026#34; I am %s, my pid:%d%c\u0026#34;, name, getpid(), \u0026#39;\\n\u0026#39;); while (1) ; } /* 测试用户进程 */ void u_prog_b(void) { char *name = \u0026#34;prog_b\u0026#34;; printf(\u0026#34; I am %s, my pid:%d%c\u0026#34;, name, getpid(), \u0026#39;\\n\u0026#39;); while (1) ; } 编译运行\n内存释放\r内存块的释放是基于页面的——假如所有内存块都空闲，则直接将该页面释放，否则就只是将该内存块插入到空闲链表中\n因此我们首先需要构建内存页的释放，内存页的释放是内存页分配的逆过程\n在物理内存池中释放物理内存页（只需将位图置为0即可） 清除页表中的页表项，即清除掉虚拟内存和物理内存的映射关系 在虚拟内存池中释放虚拟内存页（只需将位图置为0即可） 内存页的释放\r释放物理内存页\r/kernel/memory.c\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 /*将物理地址pg_phy_addr回收到物理内存池*/ void pfree(uint32_t pg_phy_addr) { struct pool *mem_pool; uint32_t bit_idx = 0; // 用户物理内存池 if (pg_phy_addr \u0026gt;= user_pool.phy_addr_start) { mem_pool = \u0026amp;user_pool; bit_idx = (pg_phy_addr - user_pool.phy_addr_start) / PG_SIZE; } else { // 内核物理内存池 mem_pool = \u0026amp;kernel_pool; bit_idx = (pg_phy_addr - kernel_pool.phy_addr_start) / PG_SIZE; } // 将位图中该位清0 bitmap_set(\u0026amp;mem_pool-\u0026gt;pool_bitmap, bit_idx, 0); } 删除映射关系\r/kernel/memory.c\n1 2 3 4 5 6 7 8 9 /* 去掉页表中虚拟地址vaddr的映射,只去掉vaddr对应的pte */ static void page_table_pte_remove(uint32_t vaddr) { uint32_t *pte = pte_ptr(vaddr); // 将页表项pte的P位置0 *pte \u0026amp;= ~PG_P_1; // 更新tlb asm volatile(\u0026#34;invlpg %0\u0026#34; ::\u0026#34;m\u0026#34;(vaddr) : \u0026#34;memory\u0026#34;); } 释放虚拟内存页\r/kernel/memory.c\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 /*在虚拟地址池中释放以_vaddr起始的连续pg_cnt个虚拟页地址，实质就是清除虚拟内存池位图的位*/ static void vaddr_remove(enum pool_flags pf, void *_vaddr, uint32_t pg_cnt) { uint32_t bit_idx_start = 0, vaddr = (uint32_t)_vaddr, cnt = 0; // 内核虚拟内存池 if (pf == PF_KERNEL) { bit_idx_start = (vaddr - kernel_vaddr.vaddr_start) / PG_SIZE; while (cnt \u0026lt; pg_cnt) bitmap_set(\u0026amp;kernel_vaddr.vaddr_bitmap, bit_idx_start + cnt++, 0); } else { // 用户虚拟内存池 struct task_struct *cur_thread = running_thread(); bit_idx_start = (vaddr - cur_thread-\u0026gt;userprog_vaddr.vaddr_start) / PG_SIZE; while (cnt \u0026lt; pg_cnt) bitmap_set(\u0026amp;cur_thread-\u0026gt;userprog_vaddr.vaddr_bitmap, bit_idx_start + cnt++, 0); } } 内存页释放过程封装\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 /* 释放以虚拟地址vaddr为起始的cnt个物理页框 */ void mfree_page(enum pool_flags pf, void *_vaddr, uint32_t pg_cnt) { uint32_t vaddr = (uint32_t)_vaddr, page_cnt = 0; ASSERT(pg_cnt \u0026gt;= 1 \u0026amp;\u0026amp; vaddr % PG_SIZE == 0); uint32_t pg_phy_addr = addr_v2p(vaddr); /* 确保待释放的物理内存在低端1M+1k大小的页目录+1k大小的页表地址范围外 */ ASSERT((pg_phy_addr % PG_SIZE) == 0 \u0026amp;\u0026amp; pg_phy_addr \u0026gt;= 0x102000); /* 判断pg_phy_addr属于用户物理内存池还是内核物理内存池 */ if (pg_phy_addr \u0026gt;= user_pool.phy_addr_start) { // 位于user_pool内存池 vaddr -= PG_SIZE; while (page_cnt \u0026lt; pg_cnt) { vaddr += PG_SIZE; pg_phy_addr = addr_v2p(vaddr); /* 确保物理地址属于用户物理内存池 */ ASSERT((pg_phy_addr % PG_SIZE) == 0 \u0026amp;\u0026amp; pg_phy_addr \u0026gt;= user_pool.phy_addr_start); /* 先将对应的物理页框归还到内存池 */ pfree(pg_phy_addr); /* 再从页表中清除此虚拟地址所在的页表项pte */ page_table_pte_remove(vaddr); page_cnt++; } /* 清空虚拟地址的位图中的相应位 */ vaddr_remove(pf, _vaddr, pg_cnt); } else { // 位于kernel_pool内存池 vaddr -= PG_SIZE; while (page_cnt \u0026lt; pg_cnt) { vaddr += PG_SIZE; pg_phy_addr = addr_v2p(vaddr); /* 确保待释放的物理内存只属于内核物理内存池 */ ASSERT((pg_phy_addr % PG_SIZE) == 0 \u0026amp;\u0026amp; pg_phy_addr \u0026gt;= kernel_pool.phy_addr_start \u0026amp;\u0026amp; pg_phy_addr \u0026lt; user_pool.phy_addr_start); /* 先将对应的物理页框归还到内存池 */ pfree(pg_phy_addr); /* 再从页表中清除此虚拟地址所在的页表项pte */ page_table_pte_remove(vaddr); page_cnt++; } /* 清空虚拟地址的位图中的相应位 */ vaddr_remove(pf, _vaddr, pg_cnt); } } sys_free\r有了内存页的释放过程之后，内存块的释放就可以实现了，其逻辑同上所述\n判断释放的内存块大小是否大于可分配的最大大小1024B，如果是就直接释放这个页面，否则转步骤2 判断当前内存块所在的arena是否所有块都空闲，如果是就直接释放这个页面，否则转步骤3 仅仅释放该内存块，将其插入空闲链表即可 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 /* 回收内存块ptr */ void sys_free(void *ptr) { ASSERT(ptr != NULL); if (ptr != NULL) { enum pool_flags PF; struct pool *mem_pool; /*判断是线程还是进程*/ if (running_thread()-\u0026gt;pgdir == NULL) { ASSERT((uint32_t)ptr \u0026gt;= K_HEAP_START); PF = PF_KERNEL; mem_pool = \u0026amp;kernel_pool; } else { PF = PF_USER; mem_pool = \u0026amp;user_pool; } lock_acquire(\u0026amp;mem_pool-\u0026gt;lock); struct mem_block *b = ptr; struct arena *a = block2arena(b); ASSERT(a-\u0026gt;large == 0 || a-\u0026gt;large == 1); if (a-\u0026gt;desc == NULL \u0026amp;\u0026amp; a-\u0026gt;large == true) { // 大于1024的内存 mfree_page(PF, a, a-\u0026gt;cnt); } else { // 小于等于1024的内存块先将内存块回收到free_list list_append(\u0026amp;a-\u0026gt;desc-\u0026gt;free_list, \u0026amp;b-\u0026gt;free_elem); /* 再判断此arena中的内存块是否都是空闲,如果是就释放arena */ if (++a-\u0026gt;cnt == a-\u0026gt;desc-\u0026gt;blocks_per_arena) { uint32_t block_idx; for (block_idx = 0; block_idx \u0026lt; a-\u0026gt;desc-\u0026gt;blocks_per_arena; block_idx++) { struct mem_block *b = arena2block(a, block_idx); ASSERT(elem_find(\u0026amp;a-\u0026gt;desc-\u0026gt;free_list, \u0026amp;b-\u0026gt;free_elem)); list_remove(\u0026amp;b-\u0026gt;free_elem); } mfree_page(PF, a, 1); } } lock_release(\u0026amp;mem_pool-\u0026gt;lock); } } 测试\r/kernel/main.c\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 #include \u0026#34;print.h\u0026#34; #include \u0026#34;init.h\u0026#34; #include \u0026#34;thread.h\u0026#34; #include \u0026#34;interrupt.h\u0026#34; #include \u0026#34;console.h\u0026#34; #include \u0026#34;process.h\u0026#34; #include \u0026#34;syscall-init.h\u0026#34; #include \u0026#34;syscall.h\u0026#34; #include \u0026#34;stdio.h\u0026#34; #include \u0026#34;memory.h\u0026#34; void k_thread_a(void *); void k_thread_b(void *); void u_prog_a(void); void u_prog_b(void); int main(void) { put_str(\u0026#34;I am kernel\\n\u0026#34;); init_all(); intr_enable(); thread_start(\u0026#34;k_thread_a\u0026#34;, 31, k_thread_a, \u0026#34;I am thread_a\u0026#34;); thread_start(\u0026#34;k_thread_b\u0026#34;, 31, k_thread_b, \u0026#34;I am thread_b \u0026#34;); while (1) ; return 0; } /* 在线程中运行的函数 */ void k_thread_a(void *arg) { char *para = arg; void *addr1; void *addr2; void *addr3; void *addr4; void *addr5; void *addr6; void *addr7; console_put_str(\u0026#34; thread_a start\\n\u0026#34;); int max = 1000; while (max-- \u0026gt; 0) { int size = 128; addr1 = sys_malloc(size); size *= 2; addr2 = sys_malloc(size); size *= 2; addr3 = sys_malloc(size); sys_free(addr1); addr4 = sys_malloc(size); size *= 2; size *= 2; size *= 2; size *= 2; size *= 2; size *= 2; size *= 2; addr5 = sys_malloc(size); addr6 = sys_malloc(size); sys_free(addr5); size *= 2; addr7 = sys_malloc(size); sys_free(addr6); sys_free(addr7); sys_free(addr2); sys_free(addr3); sys_free(addr4); } console_put_str(\u0026#34; thread_a end\\n\u0026#34;); while (1) ; } /* 在线程中运行的函数 */ void k_thread_b(void *arg) { char *para = arg; void *addr1; void *addr2; void *addr3; void *addr4; void *addr5; void *addr6; void *addr7; void *addr8; void *addr9; int max = 1000; console_put_str(\u0026#34; thread_b start\\n\u0026#34;); while (max-- \u0026gt; 0) { int size = 9; addr1 = sys_malloc(size); size *= 2; addr2 = sys_malloc(size); size *= 2; sys_free(addr2); addr3 = sys_malloc(size); sys_free(addr1); addr4 = sys_malloc(size); addr5 = sys_malloc(size); addr6 = sys_malloc(size); sys_free(addr5); size *= 2; addr7 = sys_malloc(size); sys_free(addr6); sys_free(addr7); sys_free(addr3); sys_free(addr4); size *= 2; size *= 2; size *= 2; addr1 = sys_malloc(size); addr2 = sys_malloc(size); addr3 = sys_malloc(size); addr4 = sys_malloc(size); addr5 = sys_malloc(size); addr6 = sys_malloc(size); addr7 = sys_malloc(size); addr8 = sys_malloc(size); addr9 = sys_malloc(size); sys_free(addr1); sys_free(addr2); sys_free(addr3); sys_free(addr4); sys_free(addr5); sys_free(addr6); sys_free(addr7); sys_free(addr8); sys_free(addr9); } console_put_str(\u0026#34; thread_b end\\n\u0026#34;); while (1) ; } /* 测试用户进程 */ void u_prog_a(void) { char *name = \u0026#34;prog_a\u0026#34;; printf(\u0026#34; I am %s, my pid:%d%c\u0026#34;, name, getpid(), \u0026#39;\\n\u0026#39;); while (1) ; } /* 测试用户进程 */ void u_prog_b(void) { char *name = \u0026#34;prog_b\u0026#34;; printf(\u0026#34; I am %s, my pid:%d%c\u0026#34;, name, getpid(), \u0026#39;\\n\u0026#39;); while (1) ; } 编译运行\n实现系统调用malloc和free\rmalloc和free的实现其实是对sys_malloc和sys_free的用户实现\n添加内核系统调用例程\r/userprog/syscall-init.c\n1 2 3 4 5 6 7 8 9 10 /* 初始化系统调用 */ void syscall_init(void) { put_str(\u0026#34;syscall_init start\\n\u0026#34;); syscall_table[SYS_GETPID] = sys_getpid; syscall_table[SYS_WRITE] = sys_write; syscall_table[SYS_MALLOC] = sys_malloc; syscall_table[SYS_FREE] = sys_free; put_str(\u0026#34;syscall_init done\\n\u0026#34;); } 添加用户系统调用函数malloc和free\r/lib/user/syscall.h\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #ifndef __LIB_USER_SYSCALL_H #define __LIB_USER_SYSCALL_H #include \u0026#34;stdint.h\u0026#34; /*定义系统调用号*/ enum SYSCALL_NR { SYS_GETPID, SYS_WRITE, SYS_MALLOC, SYS_FREE }; uint32_t getpid(void); uint32_t write(char *str); void *malloc(uint32_t size); void free(void *ptr); #endif /lib/user/syscall.c\n1 2 3 4 5 6 7 8 9 10 11 /* 申请size字节大小的内存,并返回结果 */ void *malloc(uint32_t size) { return (void *)_syscall1(SYS_MALLOC, size); } /* 释放ptr指向的内存 */ void free(void *ptr) { _syscall1(SYS_FREE, ptr); } 测试\r/kernel/main.c\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 #include \u0026#34;print.h\u0026#34; #include \u0026#34;init.h\u0026#34; #include \u0026#34;thread.h\u0026#34; #include \u0026#34;interrupt.h\u0026#34; #include \u0026#34;console.h\u0026#34; #include \u0026#34;process.h\u0026#34; #include \u0026#34;syscall-init.h\u0026#34; #include \u0026#34;syscall.h\u0026#34; #include \u0026#34;stdio.h\u0026#34; #include \u0026#34;memory.h\u0026#34; void k_thread_a(void *); void k_thread_b(void *); void u_prog_a(void); void u_prog_b(void); int main(void) { put_str(\u0026#34;I am kernel\\n\u0026#34;); init_all(); intr_enable(); process_execute(u_prog_a, \u0026#34;u_prog_a\u0026#34;); process_execute(u_prog_b, \u0026#34;u_prog_b\u0026#34;); thread_start(\u0026#34;k_thread_a\u0026#34;, 31, k_thread_a, \u0026#34;I am thread_a\u0026#34;); thread_start(\u0026#34;k_thread_b\u0026#34;, 31, k_thread_b, \u0026#34;I am thread_b\u0026#34;); while (1) ; return 0; } /* 在线程中运行的函数 */ void k_thread_a(void *arg) { void *addr1 = sys_malloc(256); void *addr2 = sys_malloc(255); void *addr3 = sys_malloc(254); console_put_str(\u0026#34; thread_a malloc addr:0x\u0026#34;); console_put_int((int)addr1); console_put_char(\u0026#39;,\u0026#39;); console_put_int((int)addr2); console_put_char(\u0026#39;,\u0026#39;); console_put_int((int)addr3); console_put_char(\u0026#39;\\n\u0026#39;); int cpu_delay = 9999999; while (cpu_delay-- \u0026gt; 0) ; sys_free(addr1); sys_free(addr2); sys_free(addr3); while (1) ; } /* 在线程中运行的函数 */ void k_thread_b(void *arg) { void *addr1 = sys_malloc(256); void *addr2 = sys_malloc(255); void *addr3 = sys_malloc(254); console_put_str(\u0026#34; thread_b malloc addr:0x\u0026#34;); console_put_int((int)addr1); console_put_char(\u0026#39;,\u0026#39;); console_put_int((int)addr2); console_put_char(\u0026#39;,\u0026#39;); console_put_int((int)addr3); console_put_char(\u0026#39;\\n\u0026#39;); int cpu_delay = 999999; while (cpu_delay-- \u0026gt; 0) ; sys_free(addr1); sys_free(addr2); sys_free(addr3); while (1) ; } /* 测试用户进程 */ void u_prog_a(void) { void *addr1 = malloc(256); void *addr2 = malloc(255); void *addr3 = malloc(254); printf(\u0026#34; prog_a malloc addr:0x%x,0x%x,0x%x\\n\u0026#34;, (int)addr1, (int)addr2, (int)addr3); int cpu_delay = 100000; while (cpu_delay-- \u0026gt; 0) ; free(addr1); free(addr2); free(addr3); while (1) ; } /* 测试用户进程 */ void u_prog_b(void) { void *addr1 = malloc(256); void *addr2 = malloc(255); void *addr3 = malloc(254); printf(\u0026#34; prog_b malloc addr:0x%x,0x%x,0x%x\\n\u0026#34;, (int)addr1, (int)addr2, (int)addr3); int cpu_delay = 100000; while (cpu_delay-- \u0026gt; 0) ; free(addr1); free(addr2); free(addr3); while (1) ; } 编译运行\n","date":"2025-01-08T15:26:17+08:00","image":"https://raw.githubusercontent.com/jl-sky/imageDatesets/master/2025/01/upgit_20250108_1736322476.jpg","permalink":"http://localhost:1313/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9C%9F%E8%B1%A1%E8%BF%98%E5%8E%9F%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0%E4%BA%8C-%E5%AE%8C%E5%96%84%E5%A0%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/","title":"《操作系统真象还原》第十二章（二） —— 完善堆内存管理"},{"content":"本章节所有代码托管在miniOS_32\n章节任务介绍\r任务简介\r上一节，我们实现了用户进程的创建，至此，我们成功将操作系统的使用权给用户进行了开放，用户至此可以创建进程然后实现自己的功能，但用户实现的功能最终还是要在操作系统上运行，因此还需要借助操作系统提供的接口服务，这就是本节我们将要实现的——系统调用\n系统调用（System Call）是操作系统提供给应用程序访问硬件资源和操作系统服务的接口。通过系统调用，程序可以向操作系统请求服务，如文件操作、内存管理、进程控制等。系统调用位于用户态和内核态之间，通常被用来执行用户程序无法直接完成的任务。\n本节的主要任务有：\n构建系统调用的实现框架 实现getpid系统调用 实现printf库函数 前置知识\rlinux系统调用是通过软中断实现的，并且linux系统调用产生的中断向量号只有一个，即0x80，也就是说，当处理器执行指令int 0x80时就触发了系统调用。\n为了让用户程序可以通过这一个中断门调用多种系统功能，在系统调用之前，Linux在寄存器eax中写入子功能号，例如系统调用open 和 close 都是不同的子功能号,当用户程序通过int 0x80进行系统调用时，对应的中断处理例程会根据eax的值来判断用户进程申请哪种系统调用。\n构建系统调用实现框架\r如图，就是本节我们要完成的任务\n构建系统调用所需的中断描述符 构建触发系统调用中断的转接口，该转接口的作用是将eax中的系统调用号作为索引，然后按照索引寻找syscall_table中对应的系统调用例程 /kernel/interrupt.c\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 extern uint32_t syscall_handler(void); static void idt_desc_init(void) { int i; for (i = 0; i \u0026lt; IDT_DESC_CNT; i++) { make_idt_desc(\u0026amp;idt[i], IDT_DESC_ATTR_DPL0, intr_entry_table[i]); } int lastindex = IDT_DESC_CNT - 1; // 单独处理系统调用,系统调用对应的中断门dpl为3,中断处理程序为汇编的syscall_handler make_idt_desc(\u0026amp;idt[lastindex], IDT_DESC_ATTR_DPL3, syscall_handler); put_str(\u0026#34; idt_desc_init done\\n\u0026#34;); } 上述函数是构建中断描述符表的函数，我们之前在开启中断时所写的，因此，我们添加系统调用的中断描述符，只需要添加代码：\n1 2 3 int lastindex = IDT_DESC_CNT - 1; // 单独处理系统调用,系统调用对应的中断门dpl为3,中断处理程序为汇编的syscall_handler make_idt_desc(\u0026amp;idt[lastindex], IDT_DESC_ATTR_DPL3, syscall_handler); 其中，IDT_DESC_CNT表示中断描述符的个数，修改和定义如下\n1 #define IDT_DESC_CNT 0x81 // 目前总共支持的中断数，最后一个支持的中断号0x80 + 1 syscall_handler表示系统调用的中断触发时所调用的函数，也就是我们的转接口，其实现如下\n/kernel/kernel.S\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 ;;;;;;;;;;;;;;;; 0x80号中断 ;;;;;;;;;;;;;;;; [bits 32] extern syscall_table section .text global syscall_handler syscall_handler: ;1 保存上下文环境，为了复用之前写好的intr_exit:，所以我们仿照中断处理机制压入的东西，构建系统调用压入的东西 push 0 ; 压入0, 使栈中格式统一 push ds push es push fs push gs pushad push 0x80 ; PUSHAD指令压入32位寄存器，其入栈顺序是:EAX,ECX,EDX,EBX,ESP,EBP,ESI,EDI ; 此位置压入0x80也是为了保持统一的栈格式 ;2 为系统调用子功能传入参数，由于这个函数是3个参数的用户程序系统调用入口都会使用 push edx push ecx push ebx ;3 调用c中定义的功能处理函数,eax系统调用号 call [syscall_table+eax*4] add esp,12 ;回收三个参数占用的空间，保持中断退出栈格式统一 mov [esp+8*4],eax ;将eax的返回值传递给pushad压入的eax，这样中断退出时就可以将返回值弹出 jmp intr_exit 该函数的处理逻辑如下：\n保存中断调用前的寄存器环境，为了使中断退出时调用intr_exit弹栈顺利执行，需要保持压栈时的栈结构与之前我们处理中断的压栈结构一致，因此首先push 0 接下来压入中断号0x80，准备调用系统调用的中断 为系统调用准备参数环境，edx，ecx，ebx这三个参数将传递系统调用的参数时使用 调用系统调用，按照c约定，调用结束后会将返回值压入eax中 为了成功将返回值传递出去，将返回值压入pushad时压入的eax栈结构中，这样中断退出时就可以将返回值弹出 实现系统调用getpid\r有了上述框架之后，我们以后想扩充系统调用功能，只需要将系统调用例程填充进syscall_table中，并将系统调用号告知给用户，这样用户就可以调用我们实现的系统调用了\n接下来我们构建第一个系统调用，然后将其函数地址填充进syscall_table\n为用户进程和内核线程分配pid\rgetpid()的作用是返回给用户当前任务的pid，为了实现此功能，我们首先需要给进程或者线程分配pid\n/thread/thread.h\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 /* 进程或线程的pcb,程序控制块, 此结构体用于存储线程的管理信息*/ struct task_struct { uint32_t *self_kstack; // 用于存储线程的栈顶位置，栈顶放着线程要用到的运行信息 pid_t pid; // 定义线程或者进程的pid enum task_status status; uint8_t priority; // 线程优先级 char name[16]; // 用于存储自己的线程的名字 uint8_t ticks; // 线程允许上处理器运行还剩下的滴答值，因为priority不能改变，所以要在其之外另行定义一个值来倒计时 uint32_t elapsed_ticks; // 此任务自上cpu运行后至今占用了多少cpu嘀嗒数, 也就是此任务执行了多久*/ struct list_elem general_tag; // general_tag的作用是用于线程在一般的队列(如就绪队列或者等待队列)中的结点 struct list_elem all_list_tag; // all_list_tag的作用是用于线程队列thread_all_list（这个队列用于管理所有线程）中的结点 uint32_t *pgdir; // 进程自己页目录表的虚拟地址 struct virtual_addr userprog_vaddr; // 每个用户进程自己的虚拟地址池 uint32_t stack_magic; // 如果线程的栈无限生长，总会覆盖地pcb的信息，那么需要定义个边界数来检测是否栈已经到了PCB的边界 }; 在PCB结构体中添加pid字段\n1 pid_t pid; // 定义线程或者进程的pid 然后在内核线程和用户进程的PCB初始化过程中添加PID的初始化\n/thread/thread.c\npid的分配是互斥的，我们首先需要初始化pid锁\n1 2 3 4 5 6 7 8 9 10 11 /* 初始化线程环境 */ void thread_init(void) { put_str(\u0026#34;thread_init start\\n\u0026#34;); list_init(\u0026amp;thread_ready_list); list_init(\u0026amp;thread_all_list); lock_init(\u0026amp;pid_lock); /* 将当前main函数创建为线程 */ make_main_thread(); put_str(\u0026#34;thread_init done\\n\u0026#34;); } 接下来实现pid分配函数\n1 2 3 4 5 6 7 8 9 /*分配pid*/ static pid_t allocate_pid(void) { static pid_t next_pid = 0; lock_acquire(\u0026amp;pid_lock); ++next_pid; lock_release(\u0026amp;pid_lock); return next_pid; } 接下来就可以进行内核线程和用户进程pid的初始化（注意，pid是内核线程和用户进程共同的属性，而用户进程在初始化PCB时会复用和内核线程相同属性的初始化代码，因此这里对init_thread的修改就相当于修改了内核线程和用户进程初始化PCB时对pid的分配）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 /* 初始化线程基本信息 , pcb中存储的是线程的管理信息，此函数用于根据传入的pcb的地址，线程的名字等来初始化线程的管理信息*/ void init_thread(struct task_struct *pthread, char *name, int prio) { memset(pthread, 0, sizeof(*pthread)); // 把pcb初始化为0 pthread-\u0026gt;pid = allocate_pid(); strcpy(pthread-\u0026gt;name, name); // 将传入的线程的名字填入线程的pcb中 if (pthread == main_thread) { pthread-\u0026gt;status = TASK_RUNNING; // 由于把main函数也封装成一个线程,并且它一直是运行的,故将其直接设为TASK_RUNNING */ } else { pthread-\u0026gt;status = TASK_READY; } pthread-\u0026gt;priority = prio; /* self_kstack是线程自己在内核态下使用的栈顶地址 */ pthread-\u0026gt;ticks = prio; pthread-\u0026gt;elapsed_ticks = 0; pthread-\u0026gt;pgdir = NULL; // 线程没有自己的地址空间，进程的pcb这一项才有用，指向自己的页表虚拟地址 pthread-\u0026gt;self_kstack = (uint32_t *)((uint32_t)pthread + PG_SIZE); // 本操作系统比较简单，线程不会太大，就将线程栈顶定义为pcb地址 //+4096的地方，这样就留了一页给线程的信息（包含管理信息与运行信息）空间 pthread-\u0026gt;stack_magic = 0x20241221; // /定义的边界数字，随便选的数字来判断线程的栈是否已经生长到覆盖pcb信息了 } 如上所示，只是在PCB的初始化代码中添加了一行代码\n1 pthread-\u0026gt;pid = allocate_pid(); 初始化系统调用getpid\r接下来，我们就可以填充syscall_table中的调用调研例程了，如下所示\n/userprog/syscall-init.h\n1 2 3 4 5 6 #ifndef __USERPROG_SYSCALLINIT_H #define __USERPROG_SYSCALLINIT_H #include \u0026#34;stdint.h\u0026#34; void syscall_init(void); uint32_t sys_getpid(void); #endif /userprog/syscall-init.c\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026#34;syscall-init.h\u0026#34; #include \u0026#34;syscall.h\u0026#34; #include \u0026#34;stdint.h\u0026#34; #include \u0026#34;print.h\u0026#34; #include \u0026#34;thread.h\u0026#34; #define syscall_nr 32 typedef void *syscall; syscall syscall_table[syscall_nr]; /* 返回当前任务的pid */ uint32_t sys_getpid(void) { return running_thread()-\u0026gt;pid; } /* 初始化系统调用 */ void syscall_init(void) { put_str(\u0026#34;syscall_init start\\n\u0026#34;); syscall_table[SYS_GETPID] = sys_getpid; put_str(\u0026#34;syscall_init done\\n\u0026#34;); } 将系统调用的初始化代码添加进操作系统启动的初始化代码中\n/kernel/init.c\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026#34;init.h\u0026#34; #include \u0026#34;print.h\u0026#34; #include \u0026#34;interrupt.h\u0026#34; #include \u0026#34;timer.h\u0026#34; #include \u0026#34;memory.h\u0026#34; #include \u0026#34;thread.h\u0026#34; #include \u0026#34;console.h\u0026#34; #include \u0026#34;keyboard.h\u0026#34; #include \u0026#34;tss.h\u0026#34; /*负责初始化所有模块 */ void init_all() { put_str(\u0026#34;init_all\\n\u0026#34;); idt_init(); // 初始化中断 mem_init(); // 初始化内存管理系统 thread_init(); // 初始化线程相关结构 timer_init(); // 初始化PIT console_init(); // 控制台初始化最好放在开中断之前 keyboard_init(); // 键盘初始化 tss_init(); // tss初始化 syscall_init(); // 初始化系统调用 } 提供给用户使用的系统调用函数getpid\r至此，我们已经成功将getpid系统调用例程添加进了syscall_table，按照我们之前的分析，当用户执行init 0x80触发中断，并将getpid的中断号填写进eax中，就可以触发sys_getpid函数\n我们把上述过程封装起来，以便用户使用，这就是getpid库函数\n/lib/user/syscall.h\n1 2 3 4 5 6 7 8 9 10 #ifndef __LIB_USER_SYSCALL_H #define __LIB_USER_SYSCALL_H #include \u0026#34;stdint.h\u0026#34; /*定义系统调用号*/ enum SYSCALL_NR { SYS_GETPID }; uint32_t getpid(void); #endif /lib/user/syscall.c\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 #include \u0026#34;syscall.h\u0026#34; /* 无参数的系统调用 */ #define _syscall0(NUMBER) ({ \\ int retval; \\ asm volatile( \\ \u0026#34;int $0x80\u0026#34; \\ : \u0026#34;=a\u0026#34;(retval) \\ : \u0026#34;a\u0026#34;(NUMBER) \\ : \u0026#34;memory\u0026#34;); \\ retval; \\ }) /* 一个参数的系统调用 */ #define _syscall1(NUMBER, ARG1) ({ \\ int retval; \\ asm volatile( \\ \u0026#34;int $0x80\u0026#34; \\ : \u0026#34;=a\u0026#34;(retval) \\ : \u0026#34;a\u0026#34;(NUMBER), \u0026#34;b\u0026#34;(ARG1) \\ : \u0026#34;memory\u0026#34;); \\ retval; \\ }) /* 两个参数的系统调用 */ #define _syscall2(NUMBER, ARG1, ARG2) ({ \\ int retval; \\ asm volatile( \\ \u0026#34;int $0x80\u0026#34; \\ : \u0026#34;=a\u0026#34;(retval) \\ : \u0026#34;a\u0026#34;(NUMBER), \u0026#34;b\u0026#34;(ARG1), \u0026#34;c\u0026#34;(ARG2) \\ : \u0026#34;memory\u0026#34;); \\ retval; \\ }) /* 三个参数的系统调用 */ #define _syscall3(NUMBER, ARG1, ARG2, ARG3) ({ \\ int retval; \\ asm volatile( \\ \u0026#34;int $0x80\u0026#34; \\ : \u0026#34;=a\u0026#34;(retval) \\ : \u0026#34;a\u0026#34;(NUMBER), \u0026#34;b\u0026#34;(ARG1), \u0026#34;c\u0026#34;(ARG2), \u0026#34;d\u0026#34;(ARG3) \\ : \u0026#34;memory\u0026#34;); \\ retval; \\ }) /*返回当前任务的pid*/ uint32_t getpid() { return _syscall0(SYS_GETPID); } 如上所示，getpid就是我们提供给用户使用的库函数\n测试\r/kernel/main.c\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 #include \u0026#34;print.h\u0026#34; #include \u0026#34;init.h\u0026#34; #include \u0026#34;thread.h\u0026#34; #include \u0026#34;interrupt.h\u0026#34; #include \u0026#34;console.h\u0026#34; #include \u0026#34;process.h\u0026#34; #include \u0026#34;syscall-init.h\u0026#34; #include \u0026#34;syscall.h\u0026#34; void k_thread_a(void *); void k_thread_b(void *); void u_prog_a(void); void u_prog_b(void); int prog_a_pid = 0, prog_b_pid = 0; int main(void) { put_str(\u0026#34;I am kernel\\n\u0026#34;); init_all(); process_execute(u_prog_a, \u0026#34;user_prog_a\u0026#34;); process_execute(u_prog_b, \u0026#34;user_prog_b\u0026#34;); intr_enable(); console_put_str(\u0026#34; main_pid:0x\u0026#34;); console_put_int(sys_getpid()); console_put_char(\u0026#39;\\n\u0026#39;); thread_start(\u0026#34;k_thread_a\u0026#34;, 31, k_thread_a, \u0026#34;argA \u0026#34;); thread_start(\u0026#34;k_thread_b\u0026#34;, 31, k_thread_b, \u0026#34;argB \u0026#34;); while (1) ; return 0; } /* 在线程中运行的函数 */ void k_thread_a(void *arg) { char *para = arg; console_put_str(\u0026#34; thread_a_pid:0x\u0026#34;); console_put_int(sys_getpid()); console_put_char(\u0026#39;\\n\u0026#39;); console_put_str(\u0026#34; prog_a_pid:0x\u0026#34;); console_put_int(prog_a_pid); console_put_char(\u0026#39;\\n\u0026#39;); while (1) ; } /* 在线程中运行的函数 */ void k_thread_b(void *arg) { char *para = arg; console_put_str(\u0026#34; thread_b_pid:0x\u0026#34;); console_put_int(sys_getpid()); console_put_char(\u0026#39;\\n\u0026#39;); console_put_str(\u0026#34; prog_b_pid:0x\u0026#34;); console_put_int(prog_b_pid); console_put_char(\u0026#39;\\n\u0026#39;); while (1) ; } /* 测试用户进程 */ void u_prog_a(void) { prog_a_pid = getpid(); while (1) ; } /* 测试用户进程 */ void u_prog_b(void) { prog_b_pid = getpid(); while (1); } 编译运行\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 mkdir -p bin #编译mbr nasm -o $(pwd)/bin/mbr -I $(pwd)/boot/include/ $(pwd)/boot/mbr.S dd if=$(pwd)/bin/mbr of=~/bochs/hd60M.img bs=512 count=1 conv=notrunc #编译loader nasm -o $(pwd)/bin/loader -I $(pwd)/boot/include/ $(pwd)/boot/loader.S dd if=$(pwd)/bin/loader of=~/bochs/hd60M.img bs=512 count=4 seek=2 conv=notrunc #编译print函数 nasm -f elf32 -o $(pwd)/bin/print.o $(pwd)/lib/kernel/print.S # 编译kernel nasm -f elf32 -o $(pwd)/bin/kernel.o $(pwd)/kernel/kernel.S # 编译switch nasm -f elf32 -o $(pwd)/bin/switch.o $(pwd)/thread/switch.S #编译main文件 gcc-4.4 -o $(pwd)/bin/main.o -c -fno-builtin -m32 -I $(pwd)/lib/kernel/ -I $(pwd)/lib/user/ -I $(pwd)/lib/ -I $(pwd)/kernel/ -I $(pwd)/device/ -I $(pwd)/thread/ -I $(pwd)/userprog/ $(pwd)/kernel/main.c #编译interrupt文件 gcc-4.4 -o $(pwd)/bin/interrupt.o -c -fno-builtin -m32 -I $(pwd)/lib/kernel/ -I $(pwd)/lib/ -I $(pwd)/kernel/ $(pwd)/kernel/interrupt.c #编译init文件 gcc-4.4 -o $(pwd)/bin/init.o -c -fno-builtin -m32 -I $(pwd)/lib/kernel/ -I $(pwd)/lib/ -I $(pwd)/kernel/ -I $(pwd)/thread/ -I $(pwd)/device/ -I $(pwd)/userprog/ $(pwd)/kernel/init.c # 编译debug文件 gcc-4.4 -o $(pwd)/bin/debug.o -c -fno-builtin -m32 -I $(pwd)/lib/kernel/ -I $(pwd)/lib/ -I $(pwd)/kernel/ $(pwd)/kernel/debug.c # 编译string文件 gcc-4.4 -o $(pwd)/bin/string.o -c -fno-builtin -m32 -I $(pwd)/lib/kernel/ -I $(pwd)/lib/ -I $(pwd)/kernel/ $(pwd)/lib/string.c # 编译bitmap文件 gcc-4.4 -o $(pwd)/bin/bitmap.o -c -fno-builtin -m32 -I $(pwd)/lib/kernel/ -I $(pwd)/lib/ -I $(pwd)/kernel/ $(pwd)/lib/kernel/bitmap.c # 编译memory文件 gcc-4.4 -o $(pwd)/bin/memory.o -c -fno-builtin -m32 -I $(pwd)/lib/kernel/ -I $(pwd)/lib/ -I $(pwd)/kernel/ -I $(pwd)/thread/ $(pwd)/kernel/memory.c # 编译thread文件 gcc-4.4 -o $(pwd)/bin/thread.o -c -fno-builtin -m32 -I $(pwd)/lib/kernel/ -I $(pwd)/lib/ -I $(pwd)/kernel/ -I $(pwd)/thread/ -I $(pwd)/userprog/ $(pwd)/thread/thread.c # 编译list文件 gcc-4.4 -o $(pwd)/bin/list.o -c -fno-builtin -m32 -I $(pwd)/lib/kernel/ -I $(pwd)/lib/ -I $(pwd)/kernel/ $(pwd)/lib/kernel/list.c # 编译timer文件 gcc-4.4 -o $(pwd)/bin/timer.o -c -fno-builtin -m32 -I $(pwd)/lib/kernel/ -I $(pwd)/lib/ -I $(pwd)/kernel/ -I $(pwd)/thread/ $(pwd)/device/timer.c # 编译sync文件 gcc-4.4 -o $(pwd)/bin/sync.o -c -fno-builtin -m32 -I $(pwd)/lib/kernel/ -I $(pwd)/lib/ -I $(pwd)/kernel/ -I $(pwd)/thread/ $(pwd)/thread/sync.c # 编译console文件 gcc-4.4 -o $(pwd)/bin/console.o -c -fno-builtin -m32 -I $(pwd)/lib/kernel/ -I $(pwd)/lib/ -I $(pwd)/kernel/ -I $(pwd)/thread/ $(pwd)/device/console.c # 编译keyboard文件 gcc-4.4 -o $(pwd)/bin/keyboard.o -c -fno-builtin -m32 -I $(pwd)/lib/kernel/ -I $(pwd)/lib/ -I $(pwd)/kernel/ -I $(pwd)/thread/ $(pwd)/device/keyboard.c # 编译ioqueue文件 gcc-4.4 -o $(pwd)/bin/ioqueue.o -c -fno-builtin -m32 -I $(pwd)/lib/kernel/ -I $(pwd)/lib/ -I $(pwd)/kernel/ -I $(pwd)/thread/ $(pwd)/device/ioqueue.c # 编译tss文件 gcc-4.4 -o $(pwd)/bin/tss.o -c -fno-builtin -m32 -I $(pwd)/lib/kernel/ -I $(pwd)/lib/ -I $(pwd)/kernel/ -I $(pwd)/thread/ -I $(pwd)/userprog/ $(pwd)/userprog/tss.c # 编译process文件 gcc-4.4 -o $(pwd)/bin/process.o -c -fno-builtin -m32 -I $(pwd)/lib/kernel/ -I $(pwd)/lib/ -I $(pwd)/kernel/ -I $(pwd)/thread/ -I $(pwd)/device/ -I $(pwd)/userprog/ $(pwd)/userprog/process.c # 编译syscall-init文件 gcc-4.4 -o $(pwd)/bin/syscall-init.o -c -fno-builtin -m32 -I $(pwd)/lib/kernel/ -I $(pwd)/lib/ -I $(pwd)/kernel/ -I $(pwd)/thread/ -I $(pwd)/device/ -I $(pwd)/userprog/ -I $(pwd)/lib/user/ $(pwd)/userprog/syscall-init.c # 编译syscall文件 gcc-4.4 -o $(pwd)/bin/syscall.o -c -fno-builtin -m32 -I $(pwd)/lib/kernel/ -I $(pwd)/lib/ -I $(pwd)/kernel/ -I $(pwd)/thread/ -I $(pwd)/lib/user/ $(pwd)/lib/user/syscall.c #将main函数与print函数进行链接 ld -m elf_i386 -Ttext 0xc0001500 -e main -o $(pwd)/bin/kernel.bin $(pwd)/bin/main.o $(pwd)/bin/kernel.o $(pwd)/bin/init.o $(pwd)/bin/syscall-init.o $(pwd)/bin/syscall.o $(pwd)/bin/process.o $(pwd)/bin/tss.o $(pwd)/bin/thread.o $(pwd)/bin/switch.o $(pwd)/bin/list.o $(pwd)/bin/sync.o $(pwd)/bin/console.o $(pwd)/bin/keyboard.o $(pwd)/bin/timer.o $(pwd)/bin/ioqueue.o $(pwd)/bin/interrupt.o $(pwd)/bin/memory.o $(pwd)/bin/bitmap.o $(pwd)/bin/print.o $(pwd)/bin/string.o $(pwd)/bin/debug.o #将内核文件写入磁盘，loader程序会将其加载到内存运行 dd if=$(pwd)/bin/kernel.bin of=~/bochs/hd60M.img bs=512 count=200 conv=notrunc seek=9 #rm -rf bin/* 结果如下所示\n实现库函数printf\r我们之前已经构建好了系统调用的实现框架，当我们想要添加系统调用功能时，只需要在syscal_table中添加对应的例程，然后再封装一个用户使用的库函数即可\n初始化系统调用的屏幕打印函数\r/userprog/syscall-init.h\n1 2 3 4 5 6 7 #ifndef __USERPROG_SYSCALLINIT_H #define __USERPROG_SYSCALLINIT_H #include \u0026#34;stdint.h\u0026#34; void syscall_init(void); uint32_t sys_getpid(void); uint32_t sys_write(char *str); #endif /userprog/syscall-init.c\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 /*打印字符串*/ uint32_t sys_write(char *str) { console_put_str(str); return strlen(str); } /* 初始化系统调用 */ void syscall_init(void) { put_str(\u0026#34;syscall_init start\\n\u0026#34;); syscall_table[SYS_GETPID] = sys_getpid; syscall_table[SYS_WRITE] = sys_write; put_str(\u0026#34;syscall_init done\\n\u0026#34;); } 构建用户调用的库函数\r/lib/user/syscall.h\n1 2 3 4 5 6 7 8 9 10 11 12 #ifndef __LIB_USER_SYSCALL_H #define __LIB_USER_SYSCALL_H #include \u0026#34;stdint.h\u0026#34; /*定义系统调用号*/ enum SYSCALL_NR { SYS_GETPID, SYS_WRITE }; uint32_t getpid(void); uint32_t write(char *str); #endif /lib/user/syscall.c\n1 2 3 4 5 /*打印字符串str*/ uint32_t write(char *str) { return _syscall1(SYS_WRITE, str); } printf实现\r以上我们实现了基本的屏幕打印库函数，用户进程可以使用write函数实现屏幕打印功能，但用户使用该函数不仅需要知道系统调用号，并且不能进行格式化打印，为此，我们继续封装一个格式化打印函数\n/lib/user/stdio.h\n1 2 3 4 5 6 7 8 9 10 11 #ifndef __LIB_STDIO_H #define __LIB_STDIO_H #include \u0026#34;stdint.h\u0026#34; typedef char *va_list; // 按照format格式解析字符串，并传出str uint32_t vsprintf(char *str, const char *format, va_list ap); // 将解析后的字符串通过系统调用打印到屏幕上 uint32_t printf(const char *str, ...); #endif /lib/user/stdio.c\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 #include \u0026#34;stdio.h\u0026#34; #include \u0026#34;stdint.h\u0026#34; #include \u0026#34;string.h\u0026#34; #include \u0026#34;global.h\u0026#34; #include \u0026#34;syscall.h\u0026#34; #define va_start(ap, v) ap = (va_list) \u0026amp; v // 把ap指向第一个固定参数v #define va_arg(ap, t) *((t *)(ap += 4)) // ap指向下一个参数并返回其值 #define va_end(ap) ap = NULL // 清除ap /* 将整型转换成字符(integer to ascii) */ static void itoa(uint32_t value, char **buf_ptr_addr, uint8_t base) { uint32_t m = value % base; // 求模,最先掉下来的是最低位 uint32_t i = value / base; // 取整 if (i) { // 如果倍数不为0则递归调用。 itoa(i, buf_ptr_addr, base); } if (m \u0026lt; 10) { // 如果余数是0~9 *((*buf_ptr_addr)++) = m + \u0026#39;0\u0026#39;; // 将数字0~9转换为字符\u0026#39;0\u0026#39;~\u0026#39;9\u0026#39; } else { // 否则余数是A~F *((*buf_ptr_addr)++) = m - 10 + \u0026#39;A\u0026#39;; // 将数字A~F转换为字符\u0026#39;A\u0026#39;~\u0026#39;F\u0026#39; } } /* 将参数ap按照格式format输出到字符串str,并返回替换后str长度 */ uint32_t vsprintf(char *str, const char *format, va_list ap) { char *buf_ptr = str; const char *index_ptr = format; char index_char = *index_ptr; int32_t arg_int; char *arg_str; while (index_char) { if (index_char != \u0026#39;%\u0026#39;) { *(buf_ptr++) = index_char; index_char = *(++index_ptr); continue; } index_char = *(++index_ptr); // 得到%后面的字符 switch (index_char) { case \u0026#39;s\u0026#39;: arg_str = va_arg(ap, char *); strcpy(buf_ptr, arg_str); buf_ptr += strlen(arg_str); index_char = *(++index_ptr); break; case \u0026#39;c\u0026#39;: *(buf_ptr++) = va_arg(ap, char); index_char = *(++index_ptr); break; case \u0026#39;d\u0026#39;: arg_int = va_arg(ap, int); if (arg_int \u0026lt; 0) { arg_int = 0 - arg_int; /* 若是负数, 将其转为正数后,再正数前面输出个负号\u0026#39;-\u0026#39;. */ *buf_ptr++ = \u0026#39;-\u0026#39;; } itoa(arg_int, \u0026amp;buf_ptr, 10); index_char = *(++index_ptr); break; case \u0026#39;x\u0026#39;: arg_int = va_arg(ap, int); itoa(arg_int, \u0026amp;buf_ptr, 16); index_char = *(++index_ptr); // 跳过格式字符并更新index_char break; } } return strlen(str); } /* 格式化输出字符串format */ uint32_t printf(const char *format, ...) { va_list args; va_start(args, format); // 使args指向format char buf[1024] = {0}; // 用于存储拼接后的字符串 vsprintf(buf, format, args); va_end(args); return write(buf); } 以下是代码的处理流程，其基本思想为\n逐个扫描format中的字符，将其拷贝进str中，直到遇到字符% 当遇到字符%，说明有固定参数需要转换，转而按照对应的逻辑进行处理，然后再将其转换为字符串 测试\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 #include \u0026#34;print.h\u0026#34; #include \u0026#34;init.h\u0026#34; #include \u0026#34;thread.h\u0026#34; #include \u0026#34;interrupt.h\u0026#34; #include \u0026#34;console.h\u0026#34; #include \u0026#34;process.h\u0026#34; #include \u0026#34;syscall-init.h\u0026#34; #include \u0026#34;syscall.h\u0026#34; #include \u0026#34;stdio.h\u0026#34; void k_thread_a(void *); void k_thread_b(void *); void u_prog_a(void); void u_prog_b(void); int main(void) { put_str(\u0026#34;I am kernel\\n\u0026#34;); init_all(); process_execute(u_prog_a, \u0026#34;user_prog_a\u0026#34;); process_execute(u_prog_b, \u0026#34;user_prog_b\u0026#34;); console_put_str(\u0026#34; I am main, my pid:0x\u0026#34;); console_put_int(sys_getpid()); console_put_char(\u0026#39;\\n\u0026#39;); intr_enable(); thread_start(\u0026#34;k_thread_a\u0026#34;, 31, k_thread_a, \u0026#34;I am thread_a \u0026#34;); thread_start(\u0026#34;k_thread_b\u0026#34;, 31, k_thread_b, \u0026#34;I am thread_b \u0026#34;); while (1) ; return 0; } /* 在线程中运行的函数 */ void k_thread_a(void *arg) { char *para = arg; console_put_str(\u0026#34; I am thread_a, my pid:0x\u0026#34;); console_put_int(sys_getpid()); console_put_char(\u0026#39;\\n\u0026#39;); while (1) ; } /* 在线程中运行的函数 */ void k_thread_b(void *arg) { char *para = arg; console_put_str(\u0026#34; I am thread_b, my pid:0x\u0026#34;); console_put_int(sys_getpid()); console_put_char(\u0026#39;\\n\u0026#39;); while (1) ; } /* 测试用户进程 */ void u_prog_a(void) { char *name = \u0026#34;prog_a\u0026#34;; printf(\u0026#34; I am %s, my pid:%d%c\u0026#34;, name, getpid(), \u0026#39;\\n\u0026#39;); while (1) ; } /* 测试用户进程 */ void u_prog_b(void) { char *name = \u0026#34;prog_b\u0026#34;; printf(\u0026#34; I am %s, my pid:%d%c\u0026#34;, name, getpid(), \u0026#39;\\n\u0026#39;); while (1) ; } 编译运行\n","date":"2025-01-08T15:26:17+08:00","image":"https://raw.githubusercontent.com/jl-sky/imageDatesets/master/2025/01/upgit_20250108_1736322215.jpg","permalink":"http://localhost:1313/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9C%9F%E8%B1%A1%E8%BF%98%E5%8E%9F%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0%E4%B8%80-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/","title":"《操作系统真象还原》第十二章（一） —— 系统调用"},{"content":"本章节所有代码托管在miniOS_32\n章节任务介绍\r在上一节中，我们实现了操作系统的“输入”功能，通过编写键盘驱动程序，成功让操作系统接受键盘输入并在屏幕进行打印\n但是到目前为止，我们所有的程序都是在最高特权级0级下工作，而本节，我们将实现用户使用的用户程序，其特权级为3\n任务简介\r进程与内核线程最大的区别是进程有单独的4GB空间，当然这指的是虚拟地址。\n因此，我们需要单独为每个进程维护一个虚拟地址池 此外，为了维护每个进程的虚拟内存池与用户物理内存池的映射关系，我们还需要为每个进程创建页目录表 最后，每个进程的特权级是3，而此前我们一直在0特权级下工作，因此我们还需要完成从特权级0到特权级3的转换 本节的主要任务有：\n实现用户进程 在内核态完成进程PCB的初始化，同时为每个进程创建虚拟内存池 在内核态为进程分配资源，包括内存、堆栈等，为每个进程创建页目录表 完成进程从特权级0到特权级3的转换，然后执行用户进程的执行函数 创建用户进程\r在开始书写本节任务之前，我们首先回忆一下之前我们的内核线程是如何创建和启动的\n如图所示，当创建线程并执行时，我们\n首先在内核空间中申请了一块PCB 初始化PCB的内容，包括 内核线程的名字、优先级、栈顶位置以及就绪队列和全部队列的维护节点等 初始化线程栈的运行信息，这包括 初始化eip寄存器为通用线程启动函数kernel_thread 初始化线程执行函数的地址、执行函数的参数 最后运行时通过ret指令将kernel_thread弹出并赋值给eip，这样eip寄存器指向指令的时候就相当于在执行函数kernel_thread，而kernel_thread函数可以取出真正的执行函数的地址和参数，去执行线程的执行函数 进程PCB的初始化\r由此，我们可以借助内核线程的创建流程去创建进程\n首先，我们可以在PCB的数据结构中添加两个字段——页目录表基址、虚拟内存池\n这样当初始化PCB时\n如果是线程PCB的初始化，则不初始化上述两个字段 如果是进程PCB的初始化，则只需要复用线程PCB的初始化，然后添加上上述两个字段的初始化即可 如下所示，我们首先为PCB结构体task_struct添加两个字段pgdir和userprog_vaddr，分别用以记录进程的页目录表基址和进程虚拟内存池的初始化\n/thread/thread.h\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 /* 进程或线程的pcb,程序控制块, 此结构体用于存储线程的管理信息*/ struct task_struct { uint32_t *self_kstack; // 用于存储线程的栈顶位置，栈顶放着线程要用到的运行信息 enum task_status status; uint8_t priority; // 线程优先级 char name[16]; // 用于存储自己的线程的名字 uint8_t ticks; // 线程允许上处理器运行还剩下的滴答值，因为priority不能改变，所以要在其之外另行定义一个值来倒计时 uint32_t elapsed_ticks; // 此任务自上cpu运行后至今占用了多少cpu嘀嗒数, 也就是此任务执行了多久*/ struct list_elem general_tag; // general_tag的作用是用于线程在一般的队列(如就绪队列或者等待队列)中的结点 struct list_elem all_list_tag; // all_list_tag的作用是用于线程队列thread_all_list（这个队列用于管理所有线程）中的结点 uint32_t *pgdir; // 进程自己页目录表的虚拟地址 struct virtual_addr userprog_vaddr; // 每个用户进程自己的虚拟地址池 uint32_t stack_magic; // 如果线程的栈无限生长，总会覆盖地pcb的信息，那么需要定义个边界数来检测是否栈已经到了PCB的边界 }; 接下来我们主要进行这两项字段的初始化\n进程页目录表的初始化\r/userprog/process.c\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 为进程创建页目录表，并初始化（系统映射+页目录表最后一项是自己的物理地址，以此来动态操作页目录表），成功后，返回页目录表虚拟地址，失败返回空地址 uint32_t *create_page_dir(void) { // 用户进程的页表不能让用户直接访问到,所以在内核空间来申请 uint32_t *page_dir_vaddr = get_kernel_pages(1); if (page_dir_vaddr == NULL) { console_put_str(\u0026#34;create_page_dir: get_kernel_page failed!\u0026#34;); return NULL; } // 将内核页目录表的768号项到1022号项复制过来 memcpy((uint32_t *)((uint32_t)page_dir_vaddr + 768 * 4), (uint32_t *)(0xfffff000 + 768 * 4), 255 * 4); uint32_t new_page_dir_phy_addr = addr_v2p((uint32_t)page_dir_vaddr); // 将进程的页目录表的虚拟地址，转换成物理地址 page_dir_vaddr[1023] = new_page_dir_phy_addr | PG_US_U | PG_RW_W | PG_P_1; // 页目录表最后一项填自己的地址，为的是动态操作页表 return page_dir_vaddr; } 如上所示，进程页目录表的初始化很简单，其主要逻辑为\n从内核空间中申请一页内存给页目录表 将内核页目录表的768号项到1022号项复制到刚刚创建的页目录表中，原因是内核页目录表的768号项到1022号项映射的是操作系统的内核空间，为了让所有进程共享操作系统的内核，故而需要将这段映射复制给每个进程 页目录表初始化后需要激活，也就是将页目录表的基址加载到cr3寄存器中，激活的时间是由调度函数调度该进程时完成的，此处只是书写相关激活代码，将来有调度函数完成调用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 /* 激活页表 */ void page_dir_activate(struct task_struct *p_thread) { /******************************************************** * 执行此函数时,当前任务可能是线程。 * 之所以对线程也要重新安装页表, 原因是上一次被调度的可能是进程, * 否则不恢复页表的话,线程就会使用进程的页表了。 ********************************************************/ /* 若为内核线程,需要重新填充页表为0x100000 */ uint32_t pagedir_phy_addr = 0x100000; // 默认为内核的页目录物理地址,也就是内核线程所用的页目录表 if (p_thread-\u0026gt;pgdir != NULL) { // 如果不为空，说明要调度的是个进程，那么就要执行加载页表，所以先得到进程页目录表的物理地址 pagedir_phy_addr = addr_v2p((uint32_t)p_thread-\u0026gt;pgdir); } asm volatile(\u0026#34;movl %0, %%cr3\u0026#34; : : \u0026#34;r\u0026#34;(pagedir_phy_addr) : \u0026#34;memory\u0026#34;); // 更新页目录寄存器cr3,使新页表生效 } 进程虚拟内存池的初始化\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // 初始化进程pcb中的用于管理自己虚拟地址空间的虚拟内存池结构体 void create_user_vaddr_bitmap(struct task_struct *user_prog) { // 虚拟内存池的起始地址 user_prog-\u0026gt;userprog_vaddr.vaddr_start = USER_VADDR_START; /* (0xc0000000 - USER_VADDR_START)表示用户栈的大小 故，(0xc0000000 - USER_VADDR_START) / PG_SIZE表示用户栈占用的页面数 由于位图中每个比特位对应记录的是一个页面 因此(0xc0000000 - USER_VADDR_START) / PG_SIZE / 8表示用户栈位图所占用的比特数 DIV_ROUND_UP表示向上取整，如9/10=1 因此整行代码表示管理用户栈的位图所需要的内存大小（页面数） */ uint32_t bitmap_pg_cnt = DIV_ROUND_UP((0xc0000000 - USER_VADDR_START) / PG_SIZE / 8, PG_SIZE); // 从内核中申请为位图存放的空间 user_prog-\u0026gt;userprog_vaddr.vaddr_bitmap.bits = get_kernel_pages(bitmap_pg_cnt); // 计算出位图长度（字节单位） user_prog-\u0026gt;userprog_vaddr.vaddr_bitmap.btmp_bytes_len = (0xc0000000 - USER_VADDR_START) / PG_SIZE / 8; // 初始化位图 bitmap_init(\u0026amp;user_prog-\u0026gt;userprog_vaddr.vaddr_bitmap); } 虚拟内存池的初始化主要有两部分\n虚拟内存池的基址 管理虚拟内存池的位图的初始化 其中，下述代码表示虚拟内存池基址的初始化\n1 user_prog-\u0026gt;userprog_vaddr.vaddr_start = USER_VADDR_START; 该基址的宏定义如下所示\n1 2 // linux下大部分可执行程序的入口地址（虚拟）都是这个附近，我们也仿照这个设定 #define USER_VADDR_START 0x8048000 剩余部分的代码则表示对位图的初始化，包括\n为位图申请合适的存放空间 初始化位图的内容 至此，我们将复用线程PCB的初始化逻辑，再上述两个字段的初始化，就完成了进程PCB初始化的内容部分，代码流程如下所示\n1 2 3 4 5 6 7 8 /* pcb内核的数据结构,由内核来维护进程信息,因此要在内核内存池中申请 */ struct task_struct *thread = get_kernel_pages(1); /*初始化pcb*/ init_thread(thread, name, default_prio); // 初始化进程pcb中特有的页目录表 thread-\u0026gt;pgdir = create_page_dir(); // 初始化进程虚拟内存池，进程有自己的虚拟内存 create_user_vaddr_bitmap(thread); 接下来，我们同样借助线程栈运行信息的初始化来初始化进程的运行信息\n进程运行信息的初始化\r首先我们看线程栈的运行信息是如何初始化的\n1 void thread_create(struct task_struct *pthread, thread_func function, void *func_arg); 初始时，如下图所示，thread_create会将线程的栈顶指针self_kstack指向线程栈基址，然后逐步初始化线程栈的运行信息。\n当被ret指令弹出开始运行线程时，ret指令会把kernel_thread函数弹出给eip，然后执行kernel_thread函数，而kernel_thread函数去执行真正的线程执行函数，也就是thread_create中的参数function\n上述是线程运行信息的初始化，为了完成进程运行信息的初始化，我们利用上述过程，当ret指令弹出kernel_thread，然后执行kernel_thread的时候，我们让其转而执行进程运行信息的初始化代码start_process，也就是\n1 2 3 // 首先初始化线程栈运行环境，执行start_process // 然后初始化中断栈，此时的中断栈也是进程的运行栈，接着执行真正的执行函数filename thread_create(thread, start_process, filename); start_process中的工作和thread_create类似，也是初始化进程运行时信息，然后借用中断退出指令iretd去执行可执行函数，我们在这里将参数filename置为真正的进程执行函数地址\n/userprog/process.c\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // 用于初始化进入进程所需要的中断栈中的信息，传入参数是实际要运行的函数地址(进程)，这个函数是用线程启动器进入的（kernel_thread） void start_process(void *filename_) { void *function = filename_; struct task_struct *cur = running_thread(); cur-\u0026gt;self_kstack += sizeof(struct thread_stack); // 当我们进入到这里的时候，cur-\u0026gt;self_kstack指向thread_stack的起始地址，跳过这里，才能设置intr_stack struct intr_stack *proc_stack = (struct intr_stack *)cur-\u0026gt;self_kstack; proc_stack-\u0026gt;edi = proc_stack-\u0026gt;esi = proc_stack-\u0026gt;ebp = proc_stack-\u0026gt;esp_dummy = 0; proc_stack-\u0026gt;ebx = proc_stack-\u0026gt;edx = proc_stack-\u0026gt;ecx = proc_stack-\u0026gt;eax = 0; proc_stack-\u0026gt;gs = 0; // 用户态根本用不上这个，所以置为0（gs我们一般用于访问显存段，这个让内核态来访问） proc_stack-\u0026gt;ds = proc_stack-\u0026gt;es = proc_stack-\u0026gt;fs = SELECTOR_U_DATA; proc_stack-\u0026gt;eip = function; // 设定要执行的函数（进程）的地址 proc_stack-\u0026gt;cs = SELECTOR_U_CODE; proc_stack-\u0026gt;eflags = (EFLAGS_IOPL_0 | EFLAGS_MBS | EFLAGS_IF_1); // 设置用户态下的eflages的相关字段 // 初始化中断栈中的栈顶位置，我们先为虚拟地址0xc0000000 - 0x1000申请了个物理页，然后将虚拟地址+4096置为栈顶 proc_stack-\u0026gt;esp = (void *)((uint32_t)get_a_page(PF_USER, USER_STACK3_VADDR) + PG_SIZE); proc_stack-\u0026gt;ss = SELECTOR_U_DATA; asm volatile(\u0026#34;movl %0, %%esp; jmp intr_exit\u0026#34; : : \u0026#34;g\u0026#34;(proc_stack) : \u0026#34;memory\u0026#34;); } 从中断返回要用到 iretd 指令，iretd 指令的主要工作流程为\n用栈中的数据作为返回地址 加载栈中 eflags的值到 efags 寄存器 如果栈中 cs.rpl若为更低的特权级，处理器的特权级检查通过后，会将栈中 cs载入到 CS寄存器，栈中ss载入 SS寄存器，随后处理器进入低特权级。 其中**退出中断的出口是汇编语言函数intr_exit，这是我们定义在 kernel.S**中的，此函数用来恢复中断发生时、被中断的任务的上下文状态，并且退出中断。\n1 2 3 4 5 6 7 8 9 10 11 12 section .text global intr_exit intr_exit:\t; 以下是恢复上下文环境 add esp, 4\t; 跳过中断号 popad pop gs pop fs pop es pop ds add esp, 4\t;对于会压入错误码的中断会抛弃错误码（这个错误码是执行中断处理函数之前CPU自动压入的），对于不会压入错误码的中断，就会抛弃上面push的0 iretd\t; 从中断返回,32位下iret等同指令iretd 其余需要说明的是，start_process中，以下代码主要用于为用户栈开辟空间\n1 proc_stack-\u0026gt;esp = (void *)((uint32_t)get_a_page(PF_USER, USER_STACK3_VADDR) + PG_SIZE); 其中get_a_page的实现为\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 // 用于为指定的虚拟地址申请一个物理页，传入参数是这个虚拟地址，要申请的物理页所在的地址池的标志。申请失败，返回null void *get_a_page(enum pool_flags pf, uint32_t vaddr) { struct pool *mem_pool = pf \u0026amp; PF_KERNEL ? \u0026amp;kernel_pool : \u0026amp;user_pool; lock_acquire(\u0026amp;mem_pool-\u0026gt;lock); struct task_struct *cur = running_thread(); int32_t bit_idx = -1; /* 若当前是用户进程申请用户内存,就修改用户进程自己的虚拟地址位图 */ if (cur-\u0026gt;pgdir != NULL \u0026amp;\u0026amp; pf == PF_USER) { bit_idx = (vaddr - cur-\u0026gt;userprog_vaddr.vaddr_start) / PG_SIZE; ASSERT(bit_idx \u0026gt; 0); bitmap_set(\u0026amp;cur-\u0026gt;userprog_vaddr.vaddr_bitmap, bit_idx, 1); } else if (cur-\u0026gt;pgdir == NULL \u0026amp;\u0026amp; pf == PF_KERNEL) { /* 如果是内核线程申请内核内存,就修改kernel_vaddr. */ bit_idx = (vaddr - kernel_vaddr.vaddr_start) / PG_SIZE; ASSERT(bit_idx \u0026gt; 0); bitmap_set(\u0026amp;kernel_vaddr.vaddr_bitmap, bit_idx, 1); } else { PANIC(\u0026#34;get_a_page:not allow kernel alloc userspace or user alloc kernelspace by get_a_page\u0026#34;); } void *page_phyaddr = palloc(mem_pool); if (page_phyaddr == NULL) return NULL; page_table_add((void *)vaddr, page_phyaddr); lock_release(\u0026amp;mem_pool-\u0026gt;lock); return (void *)vaddr; } 上述所有的初始化任务代码为\n1 2 3 4 5 6 7 8 9 10 11 12 /* pcb内核的数据结构,由内核来维护进程信息,因此要在内核内存池中申请 */ struct task_struct *thread = get_kernel_pages(1); /*初始化pcb*/ init_thread(thread, name, default_prio); // 初始化进程pcb中特有的页目录表 thread-\u0026gt;pgdir = create_page_dir(); // 初始化进程虚拟内存池，进程有自己的虚拟内存 create_user_vaddr_bitmap(thread); // 首先初始化线程栈运行环境，执行start_process // 然后初始化中断栈，此时的中断栈也是进程的运行栈，接着执行真正的执行函数filename thread_create(thread, start_process, filename); 当初始化结束之后，就可以将该进程任务上到就绪队列当中\n1 2 3 4 5 6 7 enum intr_status old_status = intr_disable(); ASSERT(!elem_find(\u0026amp;thread_ready_list, \u0026amp;thread-\u0026gt;general_tag)); list_append(\u0026amp;thread_ready_list, \u0026amp;thread-\u0026gt;general_tag); ASSERT(!elem_find(\u0026amp;thread_all_list, \u0026amp;thread-\u0026gt;all_list_tag)); list_append(\u0026amp;thread_all_list, \u0026amp;thread-\u0026gt;all_list_tag); intr_set_status(old_status); 特权级转换\r创建用户进程的第三个工作是实现特权级转换，在此之前我们需要知道有关特权级转换的一些常识\n对于 代码段，操作系统不允许高特权级（PL0）直接切换到低特权级（PL3），以确保内核代码的安全性。 对于 数据段，操作系统不允许低特权级（PL3）直接切换到高特权级（PL0），以保护内核数据不被用户程序非法访问。 如果代码段想要从高特权级转换到低特权级，需要从中断返回实现，这也是为什么我们在高特权级创建好进程需要的东西后，使用ired指令进行中断返回来进入进程的执行函数，只有这样才能让用户进程运行在低特权级下\n但是有个问题，那就是如果用户进程想要从低特权级进入到高特权级该怎么办呢？\n这就是TSS的作用。\n在操作系统中，TSS（Task State Segment，任务状态段） 是一种用于管理任务（进程或线程）状态的数据结构，主要用于处理任务切换。\n如图所示，每当任务切换时，操作系统需要保存当前任务的寄存器值（如通用寄存器、程序计数器、堆栈指针等），以及一些控制信息\n也就是说，TSS是保存任务切换时寄存器状态的一种数据结构\n在这些寄存器中，esp0, ss0这两个字段指定了任务切换时，进入内核态时的栈指针和栈段选择子。\n也就是说，当用户进程想要从低特权级切换到高特权级时，就可以从TSS中取出esp0, ss0这两个字段的值，然后重新返回到内核态\n因此，现在我们可以说\n当创建一个用户进程时，操作系统在内核态下为进程准备好PCB以及用户栈和内存等必要的运行环境 当操作系统准备进行调度进程时，就激活页表，同时更新记录当前TSS中的esp0和ss0的值，当用户进程想要从低特权级转换到高特权级时，就可以使用此时在TSS中记录的esp0和ss0 如下，当任务进行调度切换的时候，调度函数负责激活页表，同时更新TSS中的esp0的值，让它指向线程/进程的0级栈，然后摘取就绪队列中的任务上处理器\n/thread/thread.c\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 /* 实现任务调度 */ void schedule() { ASSERT(intr_get_status() == INTR_OFF); struct task_struct *cur = running_thread(); if (cur-\u0026gt;status == TASK_RUNNING) { // 若此线程只是cpu时间片到了,将其加入到就绪队列尾 ASSERT(!elem_find(\u0026amp;thread_ready_list, \u0026amp;cur-\u0026gt;general_tag)); list_append(\u0026amp;thread_ready_list, \u0026amp;cur-\u0026gt;general_tag); cur-\u0026gt;ticks = cur-\u0026gt;priority; // 重新将当前线程的ticks再重置为其priority; cur-\u0026gt;status = TASK_READY; } else { /* 若此线程需要某事件发生后才能继续上cpu运行, 不需要将其加入队列,因为当前线程不在就绪队列中。*/ } ASSERT(!list_empty(\u0026amp;thread_ready_list)); thread_tag = NULL; // thread_tag清空 /* 将thread_ready_list队列中的第一个就绪线程弹出,准备将其调度上cpu. */ thread_tag = list_pop(\u0026amp;thread_ready_list); struct task_struct *next = elem2entry(struct task_struct, general_tag, thread_tag); next-\u0026gt;status = TASK_RUNNING; // 激活任务页表,同时更新TSS中的esp0的值，让它指向线程/进程的0级栈 process_activate(next); switch_to(cur, next); } /userprog/process.c\n1 2 3 4 5 6 7 8 9 10 // 用于加载进程自己的页目录表，同时更新进程自己的0特权级esp0到TSS中 void process_activate(struct task_struct *p_thread) { ASSERT(p_thread != NULL); /* 激活该进程或线程的页表 */ page_dir_activate(p_thread); /* 内核线程特权级本身就是0,处理器进入中断时并不会从tss中获取0特权级栈地址,故不需要更新esp0 */ if (p_thread-\u0026gt;pgdir) update_tss_esp(p_thread); /* 更新该进程的esp0,用于此进程被中断时保留上下文 */ } 既然要使用和更新TSS，当然离不开TSS的初始化，以下介绍TSS的初始化。\nTSS只是一段内存区域，与其他普通段一样，TSS也有自己的描述符，即TSS描述符，用它来描述一个TSS的信息，此描述符需要定义在GDT中。\n寄存器TR始终指向当前任务的TSS。任务切换就是改变TR的指向，CPU自动将当前寄存器组的值(快照)写入TR 指向的 TSS，同时将新任务TSS中的各寄存器的值载入CPU中对应的寄存器，从而实现了任务切换。\nTSS必须要在GDT中注册才行，这也是为了在引用描述符的阶段做安全检查。因此TSS是通过选择子来访问的，将tss加载到寄存器TR的指令是 ltr，其指令格式为:\n1 ltr “16 位通用寄存器”或“16 位内存单元 因此，同GDT一样，我们只需要在gdt中创建tss描述符，并重新加载gdt，然后让TR寄存器指向TSS描述符即可\n/userprog/tss.c\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 #include \u0026#34;tss.h\u0026#34; #include \u0026#34;stdint.h\u0026#34; #include \u0026#34;global.h\u0026#34; #include \u0026#34;string.h\u0026#34; #include \u0026#34;print.h\u0026#34; //定义tss的数据结构，在内存中tss的分布就是这个结构体 struct tss { uint32_t backlink; uint32_t* esp0; uint32_t ss0; uint32_t* esp1; uint32_t ss1; uint32_t* esp2; uint32_t ss2; uint32_t cr3; uint32_t (*eip) (void); uint32_t eflags; uint32_t eax; uint32_t ecx; uint32_t edx; uint32_t ebx; uint32_t esp; uint32_t ebp; uint32_t esi; uint32_t edi; uint32_t es; uint32_t cs; uint32_t ss; uint32_t ds; uint32_t fs; uint32_t gs; uint32_t ldt; uint16_t trace; uint16_t io_base; }; static struct tss tss; //用于更新TSS中的esp0的值，让它指向线程/进程的0级栈 void update_tss_esp(struct task_struct* pthread) { tss.esp0 = (uint32_t*)((uint32_t)pthread + PG_SIZE); } //用于创建gdt描述符，传入参数1，段基址，传入参数2，段界限；参数3，属性低字节，参数4，属性高字节(要把低四位置0，高4位才是属性) static struct gdt_desc make_gdt_desc(uint32_t* desc_addr, uint32_t limit, uint8_t attr_low, uint8_t attr_high) { uint32_t desc_base = (uint32_t)desc_addr; struct gdt_desc desc; desc.limit_low_word = limit \u0026amp; 0x0000ffff; desc.base_low_word = desc_base \u0026amp; 0x0000ffff; desc.base_mid_byte = ((desc_base \u0026amp; 0x00ff0000) \u0026gt;\u0026gt; 16); desc.attr_low_byte = (uint8_t)(attr_low); desc.limit_high_attr_high = (((limit \u0026amp; 0x000f0000) \u0026gt;\u0026gt; 16) + (uint8_t)(attr_high)); desc.base_high_byte = desc_base \u0026gt;\u0026gt; 24; return desc; } /* 在gdt中创建tss并重新加载gdt */ void tss_init() { put_str(\u0026#34;tss_init start\\n\u0026#34;); uint16_t tss_size = (uint16_t)sizeof(tss); memset(\u0026amp;tss, 0, tss_size); tss.ss0 = SELECTOR_K_STACK; tss.io_base = tss_size; //io_base 字段的值大于或等于 TSS 的大小，那么这意味着 用于表示I/O 位图的数组超出了 TSS 的界限， //或者说，TSS 结构实际上并没有包含 I/O 位图。在这种情况下，处理器就会假定该任务可以访问所有 I/O 端口 /* gdt段基址为0x900,把tss放到第4个位置,也就是0x900+0x20的位置 */ //在gdt表中添加tss段描述符，在本系统的，GDT表的起始位置为0x00000900，那么tss的段描述就应该在0x920(0x900+十进制4*8) *((struct gdt_desc*)0xc0000920) = make_gdt_desc((uint32_t*)\u0026amp;tss, tss_size - 1, TSS_ATTR_LOW, TSS_ATTR_HIGH); /* 在gdt中添加dpl为3的数据段和代码段描述符 */ *((struct gdt_desc*)0xc0000928) = make_gdt_desc((uint32_t*)0, 0xfffff, GDT_CODE_ATTR_LOW_DPL3, GDT_ATTR_HIGH); *((struct gdt_desc*)0xc0000930) = make_gdt_desc((uint32_t*)0, 0xfffff, GDT_DATA_ATTR_LOW_DPL3, GDT_ATTR_HIGH); /* gdt 16位的limit 32位的段基址 */ uint64_t gdt_operand = ((8 * 7 - 1) | ((uint64_t)(uint32_t)0xc0000900 \u0026lt;\u0026lt; 16)); // 7个描述符大小 asm volatile (\u0026#34;lgdt %0\u0026#34; : : \u0026#34;m\u0026#34; (gdt_operand)); asm volatile (\u0026#34;ltr %w0\u0026#34; : : \u0026#34;r\u0026#34; (SELECTOR_TSS)); put_str(\u0026#34;tss_init and ltr done\\n\u0026#34;); } 总结\r本章代码逻辑其实和线程的创建是一样的，都是首先初始化PCB和运行栈空间信息\n只是由于进程有自己的内存空间，因此需要在初始化PCB的过程中添加上进程内存信息的初始化\n另外由于用户进程涉及特权级的转换，这一部分我们中断返回实现，因此在运行栈空间的信息初始化时借助了中断返回进入用户空间执行\n如下总结了用户进程创建和执行的过程流程\n创建过程\n执行过程\n用户进程测试\rmain.c\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 #include \u0026#34;print.h\u0026#34; #include \u0026#34;init.h\u0026#34; #include \u0026#34;thread.h\u0026#34; #include \u0026#34;interrupt.h\u0026#34; #include \u0026#34;console.h\u0026#34; #include \u0026#34;process.h\u0026#34; void k_thread_a(void*); void k_thread_b(void*); void u_prog_a(void); void u_prog_b(void); int test_var_a = 0, test_var_b = 0; int main(void) { put_str(\u0026#34;I am kernel\\n\u0026#34;); init_all(); thread_start(\u0026#34;k_thread_a\u0026#34;, 31, k_thread_a, \u0026#34;argA \u0026#34;); thread_start(\u0026#34;k_thread_b\u0026#34;, 31, k_thread_b, \u0026#34;argB \u0026#34;); process_execute(u_prog_a, \u0026#34;user_prog_a\u0026#34;); process_execute(u_prog_b, \u0026#34;user_prog_b\u0026#34;); intr_enable(); while(1); return 0; } /* 在线程中运行的函数 */ void k_thread_a(void* arg) { char* para = arg; while(1) { console_put_str(\u0026#34; v_a:0x\u0026#34;); console_put_int(test_var_a); } } /* 在线程中运行的函数 */ void k_thread_b(void* arg) { char* para = arg; while(1) { console_put_str(\u0026#34; v_b:0x\u0026#34;); console_put_int(test_var_b); } } /* 测试用户进程 */ void u_prog_a(void) { while(1) { test_var_a++; } } /* 测试用户进程 */ void u_prog_b(void) { while(1) { test_var_b++; } } 编译\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 mkdir -p bin #编译mbr nasm -o $(pwd)/bin/mbr -I $(pwd)/boot/include/ $(pwd)/boot/mbr.S dd if=$(pwd)/bin/mbr of=~/bochs/hd60M.img bs=512 count=1 conv=notrunc #编译loader nasm -o $(pwd)/bin/loader -I $(pwd)/boot/include/ $(pwd)/boot/loader.S dd if=$(pwd)/bin/loader of=~/bochs/hd60M.img bs=512 count=4 seek=2 conv=notrunc #编译print函数 nasm -f elf32 -o $(pwd)/bin/print.o $(pwd)/lib/kernel/print.S # 编译kernel nasm -f elf32 -o $(pwd)/bin/kernel.o $(pwd)/kernel/kernel.S # 编译switch nasm -f elf32 -o $(pwd)/bin/switch.o $(pwd)/thread/switch.S #编译main文件 gcc-4.4 -o $(pwd)/bin/main.o -c -fno-builtin -m32 -I $(pwd)/lib/kernel/ -I $(pwd)/lib/ -I $(pwd)/kernel/ -I $(pwd)/device/ -I $(pwd)/thread/ -I $(pwd)/userprog/ $(pwd)/kernel/main.c #编译interrupt文件 gcc-4.4 -o $(pwd)/bin/interrupt.o -c -fno-builtin -m32 -I $(pwd)/lib/kernel/ -I $(pwd)/lib/ -I $(pwd)/kernel/ $(pwd)/kernel/interrupt.c #编译init文件 gcc-4.4 -o $(pwd)/bin/init.o -c -fno-builtin -m32 -I $(pwd)/lib/kernel/ -I $(pwd)/lib/ -I $(pwd)/kernel/ -I $(pwd)/thread/ -I $(pwd)/device/ -I $(pwd)/userprog/ $(pwd)/kernel/init.c # 编译debug文件 gcc-4.4 -o $(pwd)/bin/debug.o -c -fno-builtin -m32 -I $(pwd)/lib/kernel/ -I $(pwd)/lib/ -I $(pwd)/kernel/ $(pwd)/kernel/debug.c # 编译string文件 gcc-4.4 -o $(pwd)/bin/string.o -c -fno-builtin -m32 -I $(pwd)/lib/kernel/ -I $(pwd)/lib/ -I $(pwd)/kernel/ $(pwd)/lib/string.c # 编译bitmap文件 gcc-4.4 -o $(pwd)/bin/bitmap.o -c -fno-builtin -m32 -I $(pwd)/lib/kernel/ -I $(pwd)/lib/ -I $(pwd)/kernel/ $(pwd)/lib/kernel/bitmap.c # 编译memory文件 gcc-4.4 -o $(pwd)/bin/memory.o -c -fno-builtin -m32 -I $(pwd)/lib/kernel/ -I $(pwd)/lib/ -I $(pwd)/kernel/ -I $(pwd)/thread/ $(pwd)/kernel/memory.c # 编译thread文件 gcc-4.4 -o $(pwd)/bin/thread.o -c -fno-builtin -m32 -I $(pwd)/lib/kernel/ -I $(pwd)/lib/ -I $(pwd)/kernel/ -I $(pwd)/thread/ -I $(pwd)/userprog/ $(pwd)/thread/thread.c # 编译list文件 gcc-4.4 -o $(pwd)/bin/list.o -c -fno-builtin -m32 -I $(pwd)/lib/kernel/ -I $(pwd)/lib/ -I $(pwd)/kernel/ $(pwd)/lib/kernel/list.c # 编译timer文件 gcc-4.4 -o $(pwd)/bin/timer.o -c -fno-builtin -m32 -I $(pwd)/lib/kernel/ -I $(pwd)/lib/ -I $(pwd)/kernel/ -I $(pwd)/thread/ $(pwd)/device/timer.c # 编译sync文件 gcc-4.4 -o $(pwd)/bin/sync.o -c -fno-builtin -m32 -I $(pwd)/lib/kernel/ -I $(pwd)/lib/ -I $(pwd)/kernel/ -I $(pwd)/thread/ $(pwd)/thread/sync.c # 编译console文件 gcc-4.4 -o $(pwd)/bin/console.o -c -fno-builtin -m32 -I $(pwd)/lib/kernel/ -I $(pwd)/lib/ -I $(pwd)/kernel/ -I $(pwd)/thread/ $(pwd)/device/console.c # 编译keyboard文件 gcc-4.4 -o $(pwd)/bin/keyboard.o -c -fno-builtin -m32 -I $(pwd)/lib/kernel/ -I $(pwd)/lib/ -I $(pwd)/kernel/ -I $(pwd)/thread/ $(pwd)/device/keyboard.c # 编译ioqueue文件 gcc-4.4 -o $(pwd)/bin/ioqueue.o -c -fno-builtin -m32 -I $(pwd)/lib/kernel/ -I $(pwd)/lib/ -I $(pwd)/kernel/ -I $(pwd)/thread/ $(pwd)/device/ioqueue.c # 编译tss文件 gcc-4.4 -o $(pwd)/bin/tss.o -c -fno-builtin -m32 -I $(pwd)/lib/kernel/ -I $(pwd)/lib/ -I $(pwd)/kernel/ -I $(pwd)/thread/ -I $(pwd)/userprog/ $(pwd)/userprog/tss.c # 编译process文件 gcc-4.4 -o $(pwd)/bin/process.o -c -fno-builtin -m32 -I $(pwd)/lib/kernel/ -I $(pwd)/lib/ -I $(pwd)/kernel/ -I $(pwd)/thread/ -I $(pwd)/device/ -I $(pwd)/userprog/ $(pwd)/userprog/process.c #将main函数与print函数进行链接 ld -m elf_i386 -Ttext 0xc0001500 -e main -o $(pwd)/bin/kernel.bin $(pwd)/bin/main.o $(pwd)/bin/kernel.o $(pwd)/bin/init.o $(pwd)/bin/process.o $(pwd)/bin/tss.o $(pwd)/bin/thread.o $(pwd)/bin/switch.o $(pwd)/bin/list.o $(pwd)/bin/sync.o $(pwd)/bin/console.o $(pwd)/bin/keyboard.o $(pwd)/bin/timer.o $(pwd)/bin/ioqueue.o $(pwd)/bin/interrupt.o $(pwd)/bin/memory.o $(pwd)/bin/bitmap.o $(pwd)/bin/print.o $(pwd)/bin/string.o $(pwd)/bin/debug.o #将内核文件写入磁盘，loader程序会将其加载到内存运行 dd if=$(pwd)/bin/kernel.bin of=~/bochs/hd60M.img bs=512 count=200 conv=notrunc seek=9 #rm -rf bin/* 运行\n","date":"2025-01-05T15:26:17+08:00","image":"https://raw.githubusercontent.com/jl-sky/imageDatesets/master/2025/01/upgit_20250105_1736061136.jpg","permalink":"http://localhost:1313/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9C%9F%E8%B1%A1%E8%BF%98%E5%8E%9F%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%E8%BF%9B%E7%A8%8B/","title":"《操作系统真象还原》第十一章 —— 创建用户进程"},{"content":"本章节所有代码托管在miniOS_32\n章节任务介绍\r在上一节中，我们介绍了操作系统的同步机制互斥锁的内容，并手动实现了互斥锁，同时实现了线程安全的屏幕打印。 至此，我们算是基本完成了操作系统的“输出”功能，但目前为止我们的输入仍旧依赖于程序，而不是用户操控的键盘 本节我们将正式完成操作系统的“输入”\n任务简介\r本节的主要任务有：\n键盘驱动测试 编写键盘驱动程序 基于环形缓冲区的键盘驱动程序 前置知识\r键盘输入原理简介\r键盘编码介绍\r一个键的状态要么是按下，要么是弹起，因此一个键有两个编码，这两个编码统称扫描码，一个键的扫描码由通码和断码组成。 按键被按下时的编码叫通码，表示按键上的触点接通了内部电路，使硬件产生了一个码，故通码也称为makecode。 按键在被按住不松手时会持续产生相同的码，直到按键被松开时才终止，因此按键被松开弹起时产生的编码叫断码，也就是电路被断开了，不再持续产生码了，故断码也称为breakcode。 断码=0x80+通码 以下是各个键的扫描码\n无论是通码还是断码，它们基本都是一字节大小 最高位也就是第7位的值决定按键的状态，最高位若值为 0，表示按键处于按下的状态，否则为1的话,表示按键弹起。 但有些按键的通码和断码都以0xe0开头，它们占2字节 8048芯片\r无论是按下键，或是松开键，当键的状态改变后，键盘中的 8048 芯片把按键对应的扫描码(通码或断码)发送到主板上的 8042 芯片，8042处理后保存在自己的寄存器中，然后向 8259A 发送中断信号，这样处理器便去执行键盘中断处理程序，将 8042处理过的扫描码从它的寄存器中读取出来，继续进行下一步处理。\n因此，8048是键盘上的芯片**，负责监控键盘哪个键被按下或者松开，并将扫描码发送给8042芯片\n8042芯片\r8042芯片负责接收来自键盘的扫描码，将它转换为标准的字符编码（如ASCII码），并保存在自己的寄存器中，然后向 8259A 发送中断信号，这样处理器便去执行键盘中断处理程序，将 8042处理过的扫描码从它的寄存器中读取出来，继续进行下一步处理。\n如下所示，8042共有4个8位寄存器，这4个寄存器共用2个端口\n8042是连接8048和处理器的桥梁，8042存在的目的是:为了处理器可以通过它控制8048的工作方式，然后让 8048的工作成果通过 8042回传给处理器。此时8042就相当于数据的缓冲区、中转站，根据数据被发送的方向，8042的作用分别是输入和输出。\n键盘中断处理程序测试\r本节我们将简单编写一个键盘驱动程序，用以测试键盘输入过程。我们首先梳理一下逻辑\n当键盘键入按键后，8048芯片就将扫描码发送给8042，然后8042触发中断信号，接着触发中断处理程序 因此我们需要做的其实就是，编写键盘中断对应的中断处理程序，程序的逻辑就是读取8042接收到的扫描码，然后将其按照扫描码与键盘的对应关系显示在键盘上 由于最终目的是要编写键盘中断处理程序，我们需要首先在中断描述符表中添加键盘中断的中断描述符 要添加中断描述符，就要知道键盘中断对应的中断向量号 故而，我们的逻辑其实很简单\n添加键盘中断的中断向量号 添加键盘中断处理程序 构建中断描述符 打开键盘中断 /kernel/kernel.S\n首先在intr_entry_table中添加键盘中断的中断处理程序入口，键盘中断的中断号是0x21，为方便后续代码编写，以下添加了所有的中断号\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 VECTOR 0x20,ZERO\t;时钟中断对应的入口 VECTOR 0x21,ZERO\t;键盘中断对应的入口 VECTOR 0x22,ZERO\t;级联用的 VECTOR 0x23,ZERO\t;串口2对应的入口 VECTOR 0x24,ZERO\t;串口1对应的入口 VECTOR 0x25,ZERO\t;并口2对应的入口 VECTOR 0x26,ZERO\t;软盘对应的入口 VECTOR 0x27,ZERO\t;并口1对应的入口 VECTOR 0x28,ZERO\t;实时时钟对应的入口 VECTOR 0x29,ZERO\t;重定向 VECTOR 0x2a,ZERO\t;保留 VECTOR 0x2b,ZERO\t;保留 VECTOR 0x2c,ZERO\t;ps/2鼠标 VECTOR 0x2d,ZERO\t;fpu浮点单元异常 VECTOR 0x2e,ZERO\t;硬盘 VECTOR 0x2f,ZERO\t;保留 /kernel/interrupt.c\n修改中断描述符的总数量，原来只有33个中断描述符\n1 #define IDT_DESC_CNT 0x30 然后打开键盘中断\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 /*初始化可编程中断控制器8259A*/ static void pic_init(void) { /* 初始化主片 */ outb(PIC_M_CTRL, 0x11); // ICW1: 边沿触发,级联8259, 需要ICW4. outb(PIC_M_DATA, 0x20); // ICW2: 起始中断向量号为0x20,也就是IR[0-7] 为 0x20 ~ 0x27. outb(PIC_M_DATA, 0x04); // ICW3: IR2接从片. outb(PIC_M_DATA, 0x01); // ICW4: 8086模式, 正常EOI /* 初始化从片 */ outb(PIC_S_CTRL, 0x11); // ICW1: 边沿触发,级联8259, 需要ICW4. outb(PIC_S_DATA, 0x28); // ICW2: 起始中断向量号为0x28,也就是IR[8-15] 为 0x28 ~ 0x2F. outb(PIC_S_DATA, 0x02); // ICW3: 设置从片连接到主片的IR2引脚 outb(PIC_S_DATA, 0x01); // ICW4: 8086模式, 正常EOI /* 打开主片上IR0,也就是目前只接受时钟产生的中断 */ // outb(PIC_M_DATA, 0xfe); // outb(PIC_S_DATA, 0xff); /* 测试键盘,只打开键盘中断，其它全部关闭 */ outb(PIC_M_DATA, 0xfd); // 键盘中断在主片ir1引脚上，所以将这个引脚置0，就打开了 outb(PIC_S_DATA, 0xff); put_str(\u0026#34;pic_init done\\n\u0026#34;); } 接下来编写键盘驱动程序\n/device/keyboard.h\n1 2 3 4 #ifndef __DEVICE_KEYBOARD_H #define __DEVICE_KEYBOARD_H void keyboard_init(void); #endif /device/keyboard.c\n下述键盘驱动程序代码只做测试用，无论键盘的哪个按键被按下或者松开，都会只显示字符k，并未对键盘按键的情况做处理，后续我们再修改键盘驱动程序\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026#34;keyboard.h\u0026#34; #include \u0026#34;print.h\u0026#34; #include \u0026#34;interrupt.h\u0026#34; #include \u0026#34;io.h\u0026#34; #include \u0026#34;global.h\u0026#34; #define KBD_BUF_PORT 0x60\t// 键盘buffer寄存器端口号为0x60 /* 键盘中断处理程序 */ static void intr_keyboard_handler(void) { put_char(\u0026#39;k\u0026#39;); //每次必须要从8042读走键盘8048传递过来的数据，否则8042不会接收后续8048传递过来的数据 inb(KBD_BUF_PORT); return; } /* 键盘初始化 */ void keyboard_init() { put_str(\u0026#34;keyboard init start\\n\u0026#34;); register_handler(0x21, intr_keyboard_handler); //注册键盘中断处理函数 put_str(\u0026#34;keyboard init done\\n\u0026#34;); } 添加键盘中断初始化\n/kernel/init.c\n1 2 3 4 5 6 7 8 9 10 11 /*负责初始化所有模块 */ void init_all() { put_str(\u0026#34;init_all\\n\u0026#34;); idt_init(); // 初始化中断 mem_init(); // 初始化内存管理系统 thread_init(); // 初始化线程相关结构 timer_init(); // 时钟中断初始化 console_init(); // 终端初始化 keyboard_init(); // 键盘中断初始化 } 修改main.c测试键盘中断\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include \u0026#34;print.h\u0026#34; #include \u0026#34;init.h\u0026#34; #include \u0026#34;thread.h\u0026#34; #include \u0026#34;interrupt.h\u0026#34; #include \u0026#34;console.h\u0026#34; void thread_work_a(void *arg); void thread_work_b(void *arg); int main(void) { put_str(\u0026#34;I am kernel\\n\u0026#34;); init_all(); // thread_start(\u0026#34;thread_work_a\u0026#34;, 31, thread_work_a, \u0026#34;pthread_A \u0026#34;); // thread_start(\u0026#34;thread_work_b\u0026#34;, 8, thread_work_b, \u0026#34;pthread_B \u0026#34;); /*打开中断，主要是打开时钟中断，以让时间片轮转调度生效*/ intr_enable(); while (1); // { // console_put_str(\u0026#34;Main \u0026#34;); // } return 0; } /* 线程执行函数 */ void thread_work_a(void *arg) { char *para = (char *)arg; while (1) { console_put_str(para); } } /* 线程执行函数 */ void thread_work_b(void *arg) { char *para = (char *)arg; while (1) { console_put_str(para); } } 编译运行\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 mkdir -p bin #编译mbr nasm -o $(pwd)/bin/mbr -I $(pwd)/boot/include/ $(pwd)/boot/mbr.S dd if=$(pwd)/bin/mbr of=~/bochs/hd60M.img bs=512 count=1 conv=notrunc #编译loader nasm -o $(pwd)/bin/loader -I $(pwd)/boot/include/ $(pwd)/boot/loader.S dd if=$(pwd)/bin/loader of=~/bochs/hd60M.img bs=512 count=4 seek=2 conv=notrunc #编译print函数 nasm -f elf32 -o $(pwd)/bin/print.o $(pwd)/lib/kernel/print.S # 编译kernel nasm -f elf32 -o $(pwd)/bin/kernel.o $(pwd)/kernel/kernel.S # 编译switch nasm -f elf32 -o $(pwd)/bin/switch.o $(pwd)/thread/switch.S #编译main文件 gcc-4.4 -o $(pwd)/bin/main.o -c -fno-builtin -m32 -I $(pwd)/lib/kernel/ -I $(pwd)/lib/ -I $(pwd)/kernel/ -I $(pwd)/device/ -I $(pwd)/thread/ $(pwd)/kernel/main.c #编译interrupt文件 gcc-4.4 -o $(pwd)/bin/interrupt.o -c -fno-builtin -m32 -I $(pwd)/lib/kernel/ -I $(pwd)/lib/ -I $(pwd)/kernel/ $(pwd)/kernel/interrupt.c #编译init文件 gcc-4.4 -o $(pwd)/bin/init.o -c -fno-builtin -m32 -I $(pwd)/lib/kernel/ -I $(pwd)/lib/ -I $(pwd)/kernel/ -I $(pwd)/thread/ -I $(pwd)/device/ $(pwd)/kernel/init.c # 编译debug文件 gcc-4.4 -o $(pwd)/bin/debug.o -c -fno-builtin -m32 -I $(pwd)/lib/kernel/ -I $(pwd)/lib/ -I $(pwd)/kernel/ $(pwd)/kernel/debug.c # 编译string文件 gcc-4.4 -o $(pwd)/bin/string.o -c -fno-builtin -m32 -I $(pwd)/lib/kernel/ -I $(pwd)/lib/ -I $(pwd)/kernel/ $(pwd)/lib/string.c # 编译bitmap文件 gcc-4.4 -o $(pwd)/bin/bitmap.o -c -fno-builtin -m32 -I $(pwd)/lib/kernel/ -I $(pwd)/lib/ -I $(pwd)/kernel/ $(pwd)/lib/kernel/bitmap.c # 编译memory文件 gcc-4.4 -o $(pwd)/bin/memory.o -c -fno-builtin -m32 -I $(pwd)/lib/kernel/ -I $(pwd)/lib/ -I $(pwd)/kernel/ $(pwd)/kernel/memory.c # 编译thread文件 gcc-4.4 -o $(pwd)/bin/thread.o -c -fno-builtin -m32 -I $(pwd)/lib/kernel/ -I $(pwd)/lib/ -I $(pwd)/kernel/ -I $(pwd)/thread/ $(pwd)/thread/thread.c # 编译list文件 gcc-4.4 -o $(pwd)/bin/list.o -c -fno-builtin -m32 -I $(pwd)/lib/kernel/ -I $(pwd)/lib/ -I $(pwd)/kernel/ $(pwd)/lib/kernel/list.c # 编译timer文件 gcc-4.4 -o $(pwd)/bin/timer.o -c -fno-builtin -m32 -I $(pwd)/lib/kernel/ -I $(pwd)/lib/ -I $(pwd)/kernel/ -I $(pwd)/thread/ $(pwd)/device/timer.c # 编译sync文件 gcc-4.4 -o $(pwd)/bin/sync.o -c -fno-builtin -m32 -I $(pwd)/lib/kernel/ -I $(pwd)/lib/ -I $(pwd)/kernel/ -I $(pwd)/thread/ $(pwd)/thread/sync.c # 编译console文件 gcc-4.4 -o $(pwd)/bin/console.o -c -fno-builtin -m32 -I $(pwd)/lib/kernel/ -I $(pwd)/lib/ -I $(pwd)/kernel/ -I $(pwd)/thread/ $(pwd)/device/console.c # 编译keyboard文件 gcc-4.4 -o $(pwd)/bin/keyboard.o -c -fno-builtin -m32 -I $(pwd)/lib/kernel/ -I $(pwd)/lib/ -I $(pwd)/kernel/ -I $(pwd)/thread/ $(pwd)/device/keyboard.c #将main函数与print函数进行链接 ld -m elf_i386 -Ttext 0xc0001500 -e main -o $(pwd)/bin/kernel.bin $(pwd)/bin/main.o $(pwd)/bin/kernel.o $(pwd)/bin/init.o $(pwd)/bin/thread.o $(pwd)/bin/switch.o $(pwd)/bin/list.o $(pwd)/bin/sync.o $(pwd)/bin/keyboard.o $(pwd)/bin/console.o $(pwd)/bin/timer.o $(pwd)/bin/interrupt.o $(pwd)/bin/memory.o $(pwd)/bin/bitmap.o $(pwd)/bin/print.o $(pwd)/bin/string.o $(pwd)/bin/debug.o #将内核文件写入磁盘，loader程序会将其加载到内存运行 dd if=$(pwd)/bin/kernel.bin of=~/bochs/hd60M.img bs=512 count=200 conv=notrunc seek=9 #rm -rf bin/* 结果如下所示，我们按下了空格键和字母q键，由于按下和松开都会触发中断，因此每个按键会显示两次字符k，故共有四个字符k\n编写键盘驱动程序\r上一小节，我们测试了键盘驱动程序的流程，在这一小节，我们修改键盘驱动程序，以实现当按键被按下时，屏幕上会显示对应的字符\n/device/keyboard.c\n数据准备与定义\r按照扫描码表格定义每个扫描码对应的按键情况\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 /* 二维数组，用于记录从0x00到0x3a通码对应的按键的两种情况 （如0x02，不加shift表示1，加了shift表示！）的ascii码值,如果没有，则用ascii0替代 */ char keymap[][2] = { /* 0x00 */ {0, 0}, /* 0x01 */ {esc, esc}, /* 0x02 */ {\u0026#39;1\u0026#39;, \u0026#39;!\u0026#39;}, /* 0x03 */ {\u0026#39;2\u0026#39;, \u0026#39;@\u0026#39;}, /* 0x04 */ {\u0026#39;3\u0026#39;, \u0026#39;#\u0026#39;}, /* 0x05 */ {\u0026#39;4\u0026#39;, \u0026#39;$\u0026#39;}, /* 0x06 */ {\u0026#39;5\u0026#39;, \u0026#39;%\u0026#39;}, /* 0x07 */ {\u0026#39;6\u0026#39;, \u0026#39;^\u0026#39;}, /* 0x08 */ {\u0026#39;7\u0026#39;, \u0026#39;\u0026amp;\u0026#39;}, /* 0x09 */ {\u0026#39;8\u0026#39;, \u0026#39;*\u0026#39;}, /* 0x0A */ {\u0026#39;9\u0026#39;, \u0026#39;(\u0026#39;}, /* 0x0B */ {\u0026#39;0\u0026#39;, \u0026#39;)\u0026#39;}, /* 0x0C */ {\u0026#39;-\u0026#39;, \u0026#39;_\u0026#39;}, /* 0x0D */ {\u0026#39;=\u0026#39;, \u0026#39;+\u0026#39;}, /* 0x0E */ {backspace, backspace}, /* 0x0F */ {tab, tab}, /* 0x10 */ {\u0026#39;q\u0026#39;, \u0026#39;Q\u0026#39;}, /* 0x11 */ {\u0026#39;w\u0026#39;, \u0026#39;W\u0026#39;}, /* 0x12 */ {\u0026#39;e\u0026#39;, \u0026#39;E\u0026#39;}, /* 0x13 */ {\u0026#39;r\u0026#39;, \u0026#39;R\u0026#39;}, /* 0x14 */ {\u0026#39;t\u0026#39;, \u0026#39;T\u0026#39;}, /* 0x15 */ {\u0026#39;y\u0026#39;, \u0026#39;Y\u0026#39;}, /* 0x16 */ {\u0026#39;u\u0026#39;, \u0026#39;U\u0026#39;}, /* 0x17 */ {\u0026#39;i\u0026#39;, \u0026#39;I\u0026#39;}, /* 0x18 */ {\u0026#39;o\u0026#39;, \u0026#39;O\u0026#39;}, /* 0x19 */ {\u0026#39;p\u0026#39;, \u0026#39;P\u0026#39;}, /* 0x1A */ {\u0026#39;[\u0026#39;, \u0026#39;{\u0026#39;}, /* 0x1B */ {\u0026#39;]\u0026#39;, \u0026#39;}\u0026#39;}, /* 0x1C */ {enter, enter}, /* 0x1D */ {ctrl_l_char, ctrl_l_char}, /* 0x1E */ {\u0026#39;a\u0026#39;, \u0026#39;A\u0026#39;}, /* 0x1F */ {\u0026#39;s\u0026#39;, \u0026#39;S\u0026#39;}, /* 0x20 */ {\u0026#39;d\u0026#39;, \u0026#39;D\u0026#39;}, /* 0x21 */ {\u0026#39;f\u0026#39;, \u0026#39;F\u0026#39;}, /* 0x22 */ {\u0026#39;g\u0026#39;, \u0026#39;G\u0026#39;}, /* 0x23 */ {\u0026#39;h\u0026#39;, \u0026#39;H\u0026#39;}, /* 0x24 */ {\u0026#39;j\u0026#39;, \u0026#39;J\u0026#39;}, /* 0x25 */ {\u0026#39;k\u0026#39;, \u0026#39;K\u0026#39;}, /* 0x26 */ {\u0026#39;l\u0026#39;, \u0026#39;L\u0026#39;}, /* 0x27 */ {\u0026#39;;\u0026#39;, \u0026#39;:\u0026#39;}, /* 0x28 */ {\u0026#39;\\\u0026#39;\u0026#39;, \u0026#39;\u0026#34;\u0026#39;}, /* 0x29 */ {\u0026#39;`\u0026#39;, \u0026#39;~\u0026#39;}, /* 0x2A */ {shift_l_char, shift_l_char}, /* 0x2B */ {\u0026#39;\\\\\u0026#39;, \u0026#39;|\u0026#39;}, /* 0x2C */ {\u0026#39;z\u0026#39;, \u0026#39;Z\u0026#39;}, /* 0x2D */ {\u0026#39;x\u0026#39;, \u0026#39;X\u0026#39;}, /* 0x2E */ {\u0026#39;c\u0026#39;, \u0026#39;C\u0026#39;}, /* 0x2F */ {\u0026#39;v\u0026#39;, \u0026#39;V\u0026#39;}, /* 0x30 */ {\u0026#39;b\u0026#39;, \u0026#39;B\u0026#39;}, /* 0x31 */ {\u0026#39;n\u0026#39;, \u0026#39;N\u0026#39;}, /* 0x32 */ {\u0026#39;m\u0026#39;, \u0026#39;M\u0026#39;}, /* 0x33 */ {\u0026#39;,\u0026#39;, \u0026#39;\u0026lt;\u0026#39;}, /* 0x34 */ {\u0026#39;.\u0026#39;, \u0026#39;\u0026gt;\u0026#39;}, /* 0x35 */ {\u0026#39;/\u0026#39;, \u0026#39;?\u0026#39;}, /* 0x36\t*/ {shift_r_char, shift_r_char}, /* 0x37 */ {\u0026#39;*\u0026#39;, \u0026#39;*\u0026#39;}, /* 0x38 */ {alt_l_char, alt_l_char}, /* 0x39 */ {\u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, /* 0x3A */ {caps_lock_char, caps_lock_char}}; 其中不可见字符以及控制字符的显式定义宏为\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #define esc \u0026#39;\\033\u0026#39; // esc 和 delete都没有\\转义字符这种形式，用8进制代替 #define delete \u0026#39;\\0177\u0026#39; #define enter \u0026#39;\\r\u0026#39; #define tab \u0026#39;\\t\u0026#39; #define backspace \u0026#39;\\b\u0026#39; // 功能性 不可见字符均设置为0 #define char_invisible 0 #define ctrl_l_char char_invisible #define ctrl_r_char char_invisible #define shift_l_char char_invisible #define shift_r_char char_invisible #define alt_l_char char_invisible #define alt_r_char char_invisible #define caps_lock_char char_invisible 接下来定义控制字符的通码和断码\n1 2 3 4 5 6 7 8 9 10 /// 定义控制字符的通码和断码 #define shift_l_make 0x2a #define shift_r_make 0x36 #define alt_l_make 0x38 #define alt_r_make 0xe038 #define alt_r_break 0xe0b8 #define ctrl_l_make 0x1d #define ctrl_r_make 0xe01d #define ctrl_r_break 0xe09d #define caps_lock_make 0x3a 由于控制字符常常和其余键作为组合键使用，因此需要记录控制字符的状态\n1 2 3 4 5 int ctrl_status = 0; // 用于记录是否按下ctrl键 int shift_status = 0; // 用于记录是否按下shift int alt_status = 0; // 用于记录是否按下alt键 int caps_lock_status = 0; // 用于记录是否按下大写锁定 int ext_scancode = 0; // 用于记录是否是扩展码 键盘驱动程序逻辑\r首先从8042芯片中读取扫描码，需要注意的是，8042每次只接受一个字节的扫描码，但是有些按键的扫描码是两个字节，因此会触发两次中断，并向8042依次发送这两个字节的数据\n因此，需要根据第一次接受到的扫描码是否是0xe0，如果是，说明该按键的扫描码是由两个字节组成的，需要再次接受一个字节的扫描码，然后才能拼接出完整的两个字节的扫描码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 从0x60端口读入一个字 uint16_t scancode = inb(KBD_BUF_PORT); // 如果传入是0xe0，说明是处理两字节按键的扫描码，那么就应该立即退出去取出下一个字节 if (scancode == 0xe0) { ext_scancode = 1; return; } // 如果能进入这个if，那么ext_scancode==1，说明上次传入的是两字节按键扫描码的第一个字节 if (ext_scancode) { scancode |= (0xe000); // 合并扫描码，这样两字节的按键的扫描码就得到了完整取出 ext_scancode = 0; } 接受到扫描码后需要判断是断码还是通码，然后分别进行处理，而由以上我们知道\n断码=0x80+通码\n因此有\n1 2 // 断码=通码+0x80，如果是断码，那么\u0026amp;出来结果！=0，那么break_code值为1 int break_code = ((scancode \u0026amp; 0x0080) != 0); 如果是断码，说明松开了按键\n如果松开的按键是字母键，则不进行处理 如果松开的是控制按键，则清除对应控制按键的状态（因为控制按键在按下的时候我们会置状态位，因此松开的时候需要清除） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 如果是断码，就要判断是否是控制按键的断码 // 如果是，就要将表示他们按下的标志清零，如果不是，就不处理。最后都要退出程序 if (break_code) { // 将扫描码(现在是断码)还原成通码 uint16_t make_code = (scancode \u0026amp;= 0xff7f); if (make_code == ctrl_l_make || make_code == ctrl_r_make) ctrl_status = 0; if (make_code == shift_l_make || make_code == shift_r_make) shift_status = 0; if (make_code == alt_l_make || make_code == alt_r_make) alt_status = 0; return; } 以下是通码对应的处理逻辑\n判断按键是否是控制键（ctrl、alt、shift、大写锁定键）：如果是，说明用户可能在使用组合键，因此首先记录该控制按键的状态是被按下了，然后返回接受下一个中断的按键（这里我们并没有实现具体的组合键处理情况） 判断按键是否是特殊两个字母的键（和shift可以组合使用的键）：如果是，则判断shift按键的状态是否被按下，如果被按下就打印转换的字符，如果shift状态没有被按下，就直接打印对应字符即可 判断正常字母按键：正常字母按键可能会和shift或者大写锁定键组合使用，但只有一个会起作用，但无论是哪个起作用，都将shift状态位置为1，表示接下来该字母输出的是大写 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 // 如果是通码，首先保证我们只处理这些数组中定义了的键，以及右alt和ctrl。 else if ((scancode \u0026gt; 0x00 \u0026amp;\u0026amp; scancode \u0026lt; 0x3b) || (scancode == alt_r_make) || (scancode == ctrl_r_make)) { // 是否开启shift转换标志 int shift = 0; // 将扫描码留下低字节，这就是在数组中对应的索引 uint8_t index = (scancode \u0026amp; 0x00ff); if (scancode == ctrl_l_make || scancode == ctrl_r_make) { ctrl_status = 1; return; } if (scancode == shift_l_make || scancode == shift_r_make) { shift_status = 1; return; } if (scancode == alt_l_make || scancode == alt_r_make) { alt_status = 1; return; } if (scancode == caps_lock_make) // 大写锁定键是按一次，然后取反 { caps_lock_status = !caps_lock_status; return; } if ((scancode \u0026lt; 0x0e) || (scancode == 0x29) || (scancode == 0x1a) || (scancode == 0x1b) || (scancode == 0x2b) || (scancode == 0x27) || (scancode == 0x28) || (scancode == 0x33) || (scancode == 0x34) || (scancode == 0x35)) { /*代表两个字母的键 0x0e 数字\u0026#39;0\u0026#39;~\u0026#39;9\u0026#39;,字符\u0026#39;-\u0026#39;,字符\u0026#39;=\u0026#39; 0x29 字符\u0026#39;`\u0026#39; 0x1a 字符\u0026#39;[\u0026#39; 0x1b 字符\u0026#39;]\u0026#39; 0x2b 字符\u0026#39;\\\\\u0026#39; 0x27 字符\u0026#39;;\u0026#39; 0x28 字符\u0026#39;\\\u0026#39;\u0026#39; 0x33 字符\u0026#39;,\u0026#39; 0x34 字符\u0026#39;.\u0026#39; 0x35 字符\u0026#39;/\u0026#39; */ if (shift_status) // 如果同时按下了shift键 shift = true; } else { // 默认字母键 if (shift_status + caps_lock_status == 1) shift = 1; // shift和大写锁定，那么判断是否按下了一个，而且不能是同时按下，那么就能确定是要开启shift } put_char(keymap[index][shift]); // 打印字符 return; } 编译运行\n如下是运行的结果，我在键盘输入的是“nihao hello world”\n可以看到程序正常显示了我的按键情况\n环形输入缓冲区\r到现在，我们的键盘驱动仅能够输出咱们所键入的按键，这还没有什么实际用途。\n在键盘上操作是为了与系统进行交互，交互的过程一般是键入各种shell 命令，然后shel 解析并执行。\nshell 命令是由多个字符组成的，并且要以回车键结束，因此咱们在键入命令的过程中，必须要找个缓冲区把已键入的信息存起来，当凑成完整的命令名时再一并由其他模块处理。\n本节咱们要构建这个缓冲区\n环形缓冲区本质上是用数组进行表示，并使用模运算实现区域的回绕 当缓冲区满时，要阻塞生产者继续向缓冲区写入字符 当缓冲区空时，要阻塞消费者取字符 以下是具体代码，实现较为简单，不再赘述细节\n/device/ioqueue.h\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #ifndef __DEVICE_IOQUEUE_H #define __DEVICE_IOQUEUE_H #include \u0026#34;stdint.h\u0026#34; #include \u0026#34;thread.h\u0026#34; #include \u0026#34;sync.h\u0026#34; // 定义缓冲区大小 #define bufsize 64 /*环形队列*/ struct ioqueue { struct lock lock; /* 生产者,缓冲区不满时就继续往里面放数据, * 否则就睡眠,此项记录哪个生产者在此缓冲区上睡眠。*/ struct task_struct *producer; /* 消费者,缓冲区不空时就继续从往里面拿数据, * 否则就睡眠,此项记录哪个消费者在此缓冲区上睡眠。*/ struct task_struct *consumer; // 缓冲区大小 char buf[bufsize]; // 队首,数据往队首处写入 int32_t head; // 队尾,数据从队尾处读出 int32_t tail; }; void ioqueue_init(struct ioqueue *ioq); bool ioq_full(struct ioqueue *ioq); bool ioq_empty(struct ioqueue *ioq); char ioq_getchar(struct ioqueue *ioq); void ioq_putchar(struct ioqueue *ioq, char byte); #endif /device/ioqueue.c\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 #include \u0026#34;ioqueue.h\u0026#34; #include \u0026#34;interrupt.h\u0026#34; #include \u0026#34;global.h\u0026#34; #include \u0026#34;debug.h\u0026#34; /*初始化io队列*/ void ioqueue_init(struct ioqueue *ioq) { lock_init(\u0026amp;ioq-\u0026gt;lock); ioq-\u0026gt;producer = ioq-\u0026gt;consumer = NULL; ioq-\u0026gt;head = ioq-\u0026gt;tail = 0; } static int32_t next_pos(int32_t pos) { return (pos + 1) % bufsize; } /*判断队列是否已满*/ bool ioq_full(struct ioqueue *ioq) { ASSERT(intr_get_status() == INTR_OFF); return next_pos(ioq-\u0026gt;head) == ioq-\u0026gt;tail; } /*判断队列是否为空*/ bool ioq_empty(struct ioqueue *ioq) { ASSERT(intr_get_status() == INTR_OFF); return ioq-\u0026gt;head == ioq-\u0026gt;tail; } /* 使当前生产者或消费者在此缓冲区上等待 传入参数是ioq-\u0026gt;producer或者ioq-\u0026gt;consumer */ static void ioq_wait(struct task_struct **waiter) { ASSERT(*waiter == NULL \u0026amp;\u0026amp; waiter != NULL); // *waiter = running_thread(); thread_block(TASK_BLOCKED); } /* 唤醒waiter */ static void ioq_wakeup(struct task_struct **waiter) { ASSERT(*waiter != NULL); thread_unblock(*waiter); *waiter = NULL; } /* 消费者从ioq队列中获取一个字符 */ char ioq_getchar(struct ioqueue *ioq) { ASSERT(intr_get_status() == INTR_OFF); while (ioq_empty(ioq)) { lock_acquire(\u0026amp;ioq-\u0026gt;lock); ioq_wait(\u0026amp;ioq-\u0026gt;consumer); lock_release(\u0026amp;ioq-\u0026gt;lock); } char byte = ioq-\u0026gt;buf[ioq-\u0026gt;tail]; ioq-\u0026gt;tail = next_pos(ioq-\u0026gt;tail); //缓冲区不满，通知生产者继续添加字符 if (ioq-\u0026gt;producer != NULL) ioq_wakeup(\u0026amp;ioq-\u0026gt;producer); return byte; } /* 生产者往ioq队列中写入一个字符byte */ void ioq_putchar(struct ioqueue *ioq, char byte) { ASSERT(intr_get_status() == INTR_OFF); while (ioq_full(ioq)) { lock_acquire(\u0026amp;ioq-\u0026gt;lock); ioq_wait(\u0026amp;ioq-\u0026gt;producer); lock_release(\u0026amp;ioq-\u0026gt;lock); } ioq-\u0026gt;buf[ioq-\u0026gt;head] = byte; ioq-\u0026gt;head = next_pos(ioq-\u0026gt;head); //缓冲区不空，通知消费者取字符 if (ioq-\u0026gt;consumer != NULL) ioq_wakeup(\u0026amp;ioq-\u0026gt;consumer); } 接下来我们需要进行测试\n生产者自然是键盘驱动程序 为了模拟消费者，我们在main函数中添加两个子线程，两个线程都用于从缓冲区中取字符 由于有两个线程取字符，因此每次按下键盘后，字符可能由不同的线程接收并显示在屏幕，我们在代码中显示每次显示的字符是由哪个线程打印的 之前为了测试键盘中断，我们关闭了时钟中断，仅打开了键盘中断，而此时由于要使用子线程，因此我们需要开启时钟中断\n/kernel/interrupt.c\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 /*初始化可编程中断控制器8259A*/ static void pic_init(void) { /* 初始化主片 */ outb(PIC_M_CTRL, 0x11); // ICW1: 边沿触发,级联8259, 需要ICW4. outb(PIC_M_DATA, 0x20); // ICW2: 起始中断向量号为0x20,也就是IR[0-7] 为 0x20 ~ 0x27. outb(PIC_M_DATA, 0x04); // ICW3: IR2接从片. outb(PIC_M_DATA, 0x01); // ICW4: 8086模式, 正常EOI /* 初始化从片 */ outb(PIC_S_CTRL, 0x11); // ICW1: 边沿触发,级联8259, 需要ICW4. outb(PIC_S_DATA, 0x28); // ICW2: 起始中断向量号为0x28,也就是IR[8-15] 为 0x28 ~ 0x2F. outb(PIC_S_DATA, 0x02); // ICW3: 设置从片连接到主片的IR2引脚 outb(PIC_S_DATA, 0x01); // ICW4: 8086模式, 正常EOI /* 打开主片上IR0,也就是目前只接受时钟产生的中断 */ // outb(PIC_M_DATA, 0xfe); // outb(PIC_S_DATA, 0xff); /* 测试键盘,只打开键盘中断，其它全部关闭 */ // outb(PIC_M_DATA, 0xfd); // 键盘中断在主片ir1引脚上，所以将这个引脚置0，就打开了 // outb(PIC_S_DATA, 0xff); // 同时打开时钟中断与键盘中断 outb(PIC_M_DATA, 0xfc); outb(PIC_S_DATA, 0xff); put_str(\u0026#34;pic_init done\\n\u0026#34;); } /kernel/main.c\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 #include \u0026#34;print.h\u0026#34; #include \u0026#34;init.h\u0026#34; #include \u0026#34;thread.h\u0026#34; #include \u0026#34;interrupt.h\u0026#34; #include \u0026#34;console.h\u0026#34; /* 临时为测试添加 */ #include \u0026#34;ioqueue.h\u0026#34; #include \u0026#34;keyboard.h\u0026#34; void thread_work_a(void *arg); void thread_work_b(void *arg); int main(void) { put_str(\u0026#34;I am kernel\\n\u0026#34;); init_all(); thread_start(\u0026#34;consumer_a\u0026#34;, 31, thread_work_a, \u0026#34;consumer_A:\u0026#34;); thread_start(\u0026#34;consumer_b\u0026#34;, 8, thread_work_b, \u0026#34;consumer_B:\u0026#34;); /*打开中断，主要是打开时钟中断，以让时间片轮转调度生效*/ intr_enable(); while (1) ; return 0; } /* 线程执行函数 */ void thread_work_a(void *arg) { char *para = (char *)arg; while (1) { enum intr_status old_status = intr_disable(); if (!ioq_empty(\u0026amp;kbd_buf)) { console_put_str(para); char byte = ioq_getchar(\u0026amp;kbd_buf); console_put_char(byte); console_put_str(\u0026#34; \u0026#34;); } intr_set_status(old_status); } } /* 线程执行函数 */ void thread_work_b(void *arg) { char *para = (char *)arg; while (1) { enum intr_status old_status = intr_disable(); if (!ioq_empty(\u0026amp;kbd_buf)) { console_put_str(para); char byte = ioq_getchar(\u0026amp;kbd_buf); console_put_char(byte); console_put_str(\u0026#34; \u0026#34;); } intr_set_status(old_status); } } 编译运行\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 mkdir -p bin #编译mbr nasm -o $(pwd)/bin/mbr -I $(pwd)/boot/include/ $(pwd)/boot/mbr.S dd if=$(pwd)/bin/mbr of=~/bochs/hd60M.img bs=512 count=1 conv=notrunc #编译loader nasm -o $(pwd)/bin/loader -I $(pwd)/boot/include/ $(pwd)/boot/loader.S dd if=$(pwd)/bin/loader of=~/bochs/hd60M.img bs=512 count=4 seek=2 conv=notrunc #编译print函数 nasm -f elf32 -o $(pwd)/bin/print.o $(pwd)/lib/kernel/print.S # 编译kernel nasm -f elf32 -o $(pwd)/bin/kernel.o $(pwd)/kernel/kernel.S # 编译switch nasm -f elf32 -o $(pwd)/bin/switch.o $(pwd)/thread/switch.S #编译main文件 gcc-4.4 -o $(pwd)/bin/main.o -c -fno-builtin -m32 -I $(pwd)/lib/kernel/ -I $(pwd)/lib/ -I $(pwd)/kernel/ -I $(pwd)/device/ -I $(pwd)/thread/ $(pwd)/kernel/main.c #编译interrupt文件 gcc-4.4 -o $(pwd)/bin/interrupt.o -c -fno-builtin -m32 -I $(pwd)/lib/kernel/ -I $(pwd)/lib/ -I $(pwd)/kernel/ $(pwd)/kernel/interrupt.c #编译init文件 gcc-4.4 -o $(pwd)/bin/init.o -c -fno-builtin -m32 -I $(pwd)/lib/kernel/ -I $(pwd)/lib/ -I $(pwd)/kernel/ -I $(pwd)/thread/ -I $(pwd)/device/ $(pwd)/kernel/init.c # 编译debug文件 gcc-4.4 -o $(pwd)/bin/debug.o -c -fno-builtin -m32 -I $(pwd)/lib/kernel/ -I $(pwd)/lib/ -I $(pwd)/kernel/ $(pwd)/kernel/debug.c # 编译string文件 gcc-4.4 -o $(pwd)/bin/string.o -c -fno-builtin -m32 -I $(pwd)/lib/kernel/ -I $(pwd)/lib/ -I $(pwd)/kernel/ $(pwd)/lib/string.c # 编译bitmap文件 gcc-4.4 -o $(pwd)/bin/bitmap.o -c -fno-builtin -m32 -I $(pwd)/lib/kernel/ -I $(pwd)/lib/ -I $(pwd)/kernel/ $(pwd)/lib/kernel/bitmap.c # 编译memory文件 gcc-4.4 -o $(pwd)/bin/memory.o -c -fno-builtin -m32 -I $(pwd)/lib/kernel/ -I $(pwd)/lib/ -I $(pwd)/kernel/ $(pwd)/kernel/memory.c # 编译thread文件 gcc-4.4 -o $(pwd)/bin/thread.o -c -fno-builtin -m32 -I $(pwd)/lib/kernel/ -I $(pwd)/lib/ -I $(pwd)/kernel/ -I $(pwd)/thread/ $(pwd)/thread/thread.c # 编译list文件 gcc-4.4 -o $(pwd)/bin/list.o -c -fno-builtin -m32 -I $(pwd)/lib/kernel/ -I $(pwd)/lib/ -I $(pwd)/kernel/ $(pwd)/lib/kernel/list.c # 编译timer文件 gcc-4.4 -o $(pwd)/bin/timer.o -c -fno-builtin -m32 -I $(pwd)/lib/kernel/ -I $(pwd)/lib/ -I $(pwd)/kernel/ -I $(pwd)/thread/ $(pwd)/device/timer.c # 编译sync文件 gcc-4.4 -o $(pwd)/bin/sync.o -c -fno-builtin -m32 -I $(pwd)/lib/kernel/ -I $(pwd)/lib/ -I $(pwd)/kernel/ -I $(pwd)/thread/ $(pwd)/thread/sync.c # 编译console文件 gcc-4.4 -o $(pwd)/bin/console.o -c -fno-builtin -m32 -I $(pwd)/lib/kernel/ -I $(pwd)/lib/ -I $(pwd)/kernel/ -I $(pwd)/thread/ $(pwd)/device/console.c # 编译keyboard文件 gcc-4.4 -o $(pwd)/bin/keyboard.o -c -fno-builtin -m32 -I $(pwd)/lib/kernel/ -I $(pwd)/lib/ -I $(pwd)/kernel/ -I $(pwd)/thread/ $(pwd)/device/keyboard.c # 编译ioqueue文件 gcc-4.4 -o $(pwd)/bin/ioqueue.o -c -fno-builtin -m32 -I $(pwd)/lib/kernel/ -I $(pwd)/lib/ -I $(pwd)/kernel/ -I $(pwd)/thread/ $(pwd)/device/ioqueue.c #将main函数与print函数进行链接 ld -m elf_i386 -Ttext 0xc0001500 -e main -o $(pwd)/bin/kernel.bin $(pwd)/bin/main.o $(pwd)/bin/kernel.o $(pwd)/bin/init.o $(pwd)/bin/thread.o $(pwd)/bin/switch.o $(pwd)/bin/list.o $(pwd)/bin/sync.o $(pwd)/bin/console.o $(pwd)/bin/keyboard.o $(pwd)/bin/timer.o $(pwd)/bin/ioqueue.o $(pwd)/bin/interrupt.o $(pwd)/bin/memory.o $(pwd)/bin/bitmap.o $(pwd)/bin/print.o $(pwd)/bin/string.o $(pwd)/bin/debug.o #将内核文件写入磁盘，loader程序会将其加载到内存运行 dd if=$(pwd)/bin/kernel.bin of=~/bochs/hd60M.img bs=512 count=200 conv=notrunc seek=9 #rm -rf bin/* 以下是运行结果\n","date":"2024-12-27T00:00:00Z","image":"https://raw.githubusercontent.com/jl-sky/imageDatesets/master/2024/12/upgit_20241227_1735287198.jpg","permalink":"http://localhost:1313/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9C%9F%E8%B1%A1%E8%BF%98%E5%8E%9F%E7%AC%AC%E5%8D%81%E7%AB%A0%E4%BA%8C-%E9%94%AE%E7%9B%98%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E5%86%99%E4%B8%8E%E8%BE%93%E5%85%A5%E7%B3%BB%E7%BB%9F/","title":"《操作系统真象还原》第十章（二） —— 键盘驱动程序的编写与输入系统"},{"content":"本章节所有代码托管在miniOS_32\n章节任务介绍\r问题复现\r在上一节中，我们实现了线程轮转调度，并分别实现了三个线程并发的在终端进行输出打印\n主线程 thread_work_a thread_work_b 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include \u0026#34;print.h\u0026#34; #include \u0026#34;init.h\u0026#34; #include \u0026#34;thread.h\u0026#34; #include \u0026#34;interrupt.h\u0026#34; void thread_work_a(void *arg); void thread_work_b(void *arg); int main(void) { put_str(\u0026#34;I am kernel\\n\u0026#34;); init_all(); thread_start(\u0026#34;thread_work_a\u0026#34;, 31, thread_work_a, \u0026#34;pthread_create_A\\n\u0026#34;); thread_start(\u0026#34;thread_work_b\u0026#34;, 8, thread_work_b, \u0026#34;pthread_create_B\\n\u0026#34;); /*打开中断，主要是打开时钟中断，以让时间片轮转调度生效*/ intr_enable(); while (1) { put_str(\u0026#34;Main\u0026#34;); } return 0; } /* 线程执行函数 */ void thread_work_a(void *arg) { char *para = (char *)arg; while (1) put_str(para); } /* 线程执行函数 */ void thread_work_b(void *arg) { char *para = (char *)arg; while (1) put_str(para); } 但如果持续输出会发现终端会爆出一个GP异常\n其原因在于，代码中三个线程对put_str函数的异步访问造成了数据混乱，因为put_str函数内部是通过对显存操作输出字符的，因此在这里三个线程对显存的并发访问造成了显存段的越界，从而爆出了GP异常\n其解决办法也简单，就是对put_str函数的访问上锁，其中最原始的上锁原理就是在访问公共资源前关中断，这样其余线程就无法通过中断切换上处理器访问显存这段公共资源，然后在访问资源结束后开中断，允许其余线程被调度上处理器访问显存\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 int main(void) { put_str(\u0026#34;I am kernel\\n\u0026#34;); init_all(); thread_start(\u0026#34;thread_work_a\u0026#34;, 31, thread_work_a, \u0026#34;pthread_create_A\\n\u0026#34;); thread_start(\u0026#34;thread_work_b\u0026#34;, 8, thread_work_b, \u0026#34;pthread_create_B\\n\u0026#34;); /*打开中断，主要是打开时钟中断，以让时间片轮转调度生效*/ intr_enable(); while (1) { intr_disable(); put_str(\u0026#34;Main\u0026#34;); intr_disable(); } return 0; } /* 线程执行函数 */ void thread_work_a(void *arg) { char *para = (char *)arg; while (1) { intr_disable(); put_str(para); intr_enable(); } } /* 线程执行函数 */ void thread_work_b(void *arg) { char *para = (char *)arg; while (1) { intr_disable(); put_str(para); intr_enable(); } } 但这种通过开关中断的方式实现互斥锁的弊端是很明显的\n禁用中断意味着当前代码段执行期间，系统无法响应中断。这不仅会影响进程或线程的切换，还可能使得系统无法及时响应硬件中断（如 I/O 操作），降低系统的实时性和响应性。 使用禁用中断实现互斥可能使代码变得难以理解和维护，尤其是在多线程环境中。因为禁用中断的作用是全局性的，可能会影响整个系统的稳定性和响应性。 在多核或多处理器系统中，禁用中断虽然能够阻止当前线程的中断，但它并不能防止其他核心/处理器上的线程执行。如果某个核心禁用了中断并进入临界区，但其他核心依然可以执行，导致多核系统中可能出现不同步的问题。 任务简介\r综上，本节我们将在多线程轮转调度的基础上介绍操作系统的同步机制——锁，同时实现一个互斥锁\n本节的主要任务有：\n实现操作系统的同步机制——锁 实现一个终端 信号量简介及其实现\r信号量简介\r信号量（Semaphore） 是一种用于控制对共享资源访问的同步机制，常用于并发编程中。它可以有效地解决多个线程或进程同时访问共享资源时可能发生的冲突或竞争条件。信号量通常用于协调线程或进程之间的执行顺序，确保并发程序能够正确地进行同步。\n同步机制的实现方式不止一种，我们在这里给出信号量与其余同步机制的区别和联系\n互斥锁（Mutex）： 互斥锁用于确保同一时刻只有一个线程可以访问某个资源，通常只有两种状态（锁定和解锁）。而信号量可以表示更复杂的情况（比如多个线程可以同时访问一个资源）。事实上，互斥锁是一种二元信号量 条件变量（Condition Variable）： 条件变量通常用于线程间的通知机制，允许一个线程等待某个条件的成立****，而信号量则是通过计数来控制资源访问**的。 事件（Event）： 事件通常用于线程间的通知机制，允许一个线程等待另一个线程的某个事件发生。而信号量不仅仅用于通知，还能用来管理资源的数量。 信号量的基本操作\r信号量可以看作是一个整型变量，用来表示资源的数量或许可以访问的共享资源的“可用”数量。信号量提供了两种基本操作：\nP操作（Proberen，通常叫做Wait或Down）： 这个操作会检查信号量的值。如果信号量的值大于0，信号量的值会减1，执行线程或进程可以继续执行。 如果信号量的值等于0，表示没有可用的资源，当前线程或进程会被阻塞，直到有资源可用。 V操作（Verhogen，通常叫做Signal或Up）： 这个操作会将信号量的值加1，并且如果有线程或进程因信号量值为0而被阻塞，则唤醒其中一个阻塞的线程。 信号量实现\r基于上述我们对信号量基本操作的介绍，要实现信号量，首先要实现线程的阻塞过程和解除阻塞过程\n/thread/thread.h\n1 2 3 4 /*将线程阻塞*/ void thread_block(enum task_status status); /*解除线程的阻塞状态*/ void thread_unblock(struct task_struct *pthread); /thread/thread.c\n线程的阻塞是一种主动行为，因此要阻塞自己的线程首先需要将自己插入阻塞队列（通常由第三方维护）中，然后调用阻塞函数将自己的PCB状态设置阻塞态，再调用调度函数从就绪队列中摘出一块准备好的线程切换到处理器执行，如下所示是阻塞函数的实现\n1 2 3 4 5 6 7 8 9 10 11 12 void thread_block(enum task_status status) { ASSERT(((status == TASK_BLOCKED) || (status == TASK_HANGING) || (status == TASK_WAITING))); enum intr_status old_status = intr_get_status(); /*修改当前线程状态为阻塞态 然后调用调度器从就绪队列摘取一块新线程执行*/ struct task_struct *cur_pthread = running_thread(); cur_pthread-\u0026gt;status = status; schedule(); intr_set_status(old_status); } 解除阻塞的行为由处理器完成，主要过程就是阻塞线程或进程的PCB状态设置为就绪态，然后将其插入就绪队列的头部，优先调用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 void thread_unblock(struct task_struct *pthread) { enum intr_status old_status = intr_get_status(); /*修改PCB状态为就绪态，同时插入就绪队列头部，优先调用*/ enum task_status status = pthread-\u0026gt;status; ASSERT(((status == TASK_BLOCKED) || (status == TASK_HANGING) || (status == TASK_WAITING))); if (status != TASK_READY) { if (elem_find(\u0026amp;thread_ready_list, \u0026amp;pthread-\u0026gt;general_tag)) PANIC(\u0026#34;thread_unblock: blocked thread in ready_list\\n\u0026#34;); list_append(\u0026amp;thread_ready_list, \u0026amp;pthread-\u0026gt;general_tag); pthread-\u0026gt;status = TASK_READY; } intr_set_status(old_status); } 接下来就是信号量的实现\n/thread/sync.h\n以下是信号量结构体的组成及其相关操作定义\n1 2 3 4 5 6 7 8 9 10 11 /*信号量结构体*/ struct semaphore { // 信号量值 uint8_t value; // 阻塞在当前信号量上的线程的阻塞队列 struct list waiters; }; void sema_init(struct semaphore *psema, uint8_t value); void sema_down(struct semaphore *psema); void sema_up(struct semaphore *psema); /thread/sync.c\n以下是信号量操作的具体实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 // 用于初始化信号量，传入参数就是指向信号量的指针与初值 void sema_init(struct semaphore *psema, uint8_t value) { psema-\u0026gt;value = value; // 为信号量赋初值 list_init(\u0026amp;psema-\u0026gt;waiters); // 初始化信号量的等待队列 } /*信号量的P操作*/ void sema_down(struct semaphore *psema) { // 对阻塞队列公共资源的访问需要关中断以避免访问过程中被打断 enum intr_status old_status = intr_disable(); // 如果当前可用资源（信号量的值）为0，则应当阻塞当前线程 while (psema-\u0026gt;value == 0) { if (elem_find(\u0026amp;psema-\u0026gt;waiters, \u0026amp;running_thread()-\u0026gt;general_tag)) PANIC(\u0026#34;sema_down: thread blocked has been in waiters_list\\n\u0026#34;); list_append(\u0026amp;psema-\u0026gt;waiters, \u0026amp;running_thread()-\u0026gt;general_tag); thread_block(TASK_BLOCKED); } // 可以让当前线程访问公共资源，同时让可访问的资源数减去一 psema-\u0026gt;value--; ASSERT(psema-\u0026gt;value == 0); // 恢复中断之前的状态 intr_set_status(old_status); } // 信号量的up操作，也就是+1操作，传入参数是指向要操作的信号量的指针。且释放信号量时，应唤醒阻塞在该信号量阻塞队列上的一个进程 void sema_up(struct semaphore *psema) { /* 关中断,保证原子操作 */ enum intr_status old_status = intr_disable(); ASSERT(psema-\u0026gt;value == 0); if (!list_empty(\u0026amp;psema-\u0026gt;waiters)) { // 判断信号量阻塞队列应为非空，这样才能执行唤醒操作 struct task_struct *thread_blocked = elem2entry(struct task_struct, general_tag, list_pop(\u0026amp;psema-\u0026gt;waiters)); thread_unblock(thread_blocked); } psema-\u0026gt;value++; ASSERT(psema-\u0026gt;value == 1); /* 恢复之前的中断状态 */ intr_set_status(old_status); } 同步机制——锁的实现\r互斥锁的实现\r/thread/sync.h\n互斥锁是一种二元信号量，因此基于信号量我们可以实现互斥锁\n1 2 3 4 5 6 7 8 9 10 11 12 13 /*锁结构*/ struct lock { // 锁的持有者 struct task_struct *holder; // 锁上的信号量 struct semaphore semaphore; // 加锁者加锁的次数，也就是加锁者访问公共资源的次数 uint32_t holder_repeat_nr; }; void lock_init(struct lock *plock); void lock_acquire(struct lock *plock); void lock_release(struct lock *plock); /thread/sync.c\n同理以下是互斥锁的具体操作实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 /*初始化锁*/ void lock_init(struct lock *plock) { plock-\u0026gt;holder = NULL; sema_init(\u0026amp;plock-\u0026gt;semaphore, 1); plock-\u0026gt;holder_repeat_nr = 0; } // 获取锁的函数,传入参数是指向锁的指针 void lock_acquire(struct lock *plock) { // 这是为了排除掉线程自己已经拿到了锁，但是还没有释放就重新申请的情况 if (plock-\u0026gt;holder != running_thread()) { sema_down(\u0026amp;plock-\u0026gt;semaphore); // 对信号量进行down操作 plock-\u0026gt;holder = running_thread(); ASSERT(plock-\u0026gt;holder_repeat_nr == 0); plock-\u0026gt;holder_repeat_nr = 1; // 申请了一次锁 } else { plock-\u0026gt;holder_repeat_nr++; } } // 释放锁的函数，参数是指向锁的指针 void lock_release(struct lock *plock) { ASSERT(plock-\u0026gt;holder == running_thread()); // 如果\u0026gt;1，说明自己多次申请了该锁，现在还不能立即释放锁 if (plock-\u0026gt;holder_repeat_nr \u0026gt; 1) { plock-\u0026gt;holder_repeat_nr--; return; } ASSERT(plock-\u0026gt;holder_repeat_nr == 1); // 判断现在lock的重复持有数是不是1只有为1，才能释放 plock-\u0026gt;holder = NULL; // 这句必须放在up操作前，因为现在并不在关中断下运行，有可能会被切换出去，如果在up后面，就可能出现还没有置空， // 就切换出去，此时有了信号量，下个进程申请到了，将holder改成下个进程，这个进程切换回来就把holder改成空，就错了 plock-\u0026gt;holder_repeat_nr = 0; sema_up(\u0026amp;plock-\u0026gt;semaphore); // 信号量的V操作,也是原子操作 } 输出终端实现\r基于互斥锁我们重新定义一个终端，以实现多线程的字符串打印\n代码逻辑其实很简单，就是在原来的字符打印、字符串打印和整数打印函数加上一层我们实现的互斥锁\n/device/console.h\n1 2 3 4 5 6 7 8 9 10 #ifndef __DEVICE_CONSOLE_H #define __DEVICE_CONSOLE_H #include \u0026#34;stdint.h\u0026#34; void console_init(void); void console_acquire(void); void console_release(void); void console_put_str(char *str); void console_put_char(uint8_t char_asci); void console_put_int(uint32_t num); #endif /device/console.c\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 #include \u0026#34;console.h\u0026#34; #include \u0026#34;print.h\u0026#34; #include \u0026#34;stdint.h\u0026#34; #include \u0026#34;sync.h\u0026#34; #include \u0026#34;thread.h\u0026#34; static struct lock console_lock; // 控制台锁 /* 初始化终端 */ void console_init() { lock_init(\u0026amp;console_lock); } /* 获取终端 */ void console_acquire() { lock_acquire(\u0026amp;console_lock); } /* 释放终端 */ void console_release() { lock_release(\u0026amp;console_lock); } /* 终端中输出字符串 */ void console_put_str(char *str) { console_acquire(); put_str(str); console_release(); } /* 终端中输出字符 */ void console_put_char(uint8_t char_asci) { console_acquire(); put_char(char_asci); console_release(); } /* 终端中输出16进制整数 */ void console_put_int(uint32_t num) { console_acquire(); put_int(num); console_release(); } 然后我们重新在main函数中进行测试\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 int main(void) { put_str(\u0026#34;I am kernel\\n\u0026#34;); init_all(); thread_start(\u0026#34;thread_work_a\u0026#34;, 31, thread_work_a, \u0026#34;pthread_A \u0026#34;); thread_start(\u0026#34;thread_work_b\u0026#34;, 8, thread_work_b, \u0026#34;pthread_B \u0026#34;); /*打开中断，主要是打开时钟中断，以让时间片轮转调度生效*/ intr_enable(); while (1) { console_put_str(\u0026#34;Main \u0026#34;); } return 0; } /* 线程执行函数 */ void thread_work_a(void *arg) { char *para = (char *)arg; while (1) { console_put_str(para); } } /* 线程执行函数 */ void thread_work_b(void *arg) { char *para = (char *)arg; while (1) { console_put_str(para); } } 编译运行\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 mkdir -p bin #编译mbr nasm -o $(pwd)/bin/mbr -I $(pwd)/boot/include/ $(pwd)/boot/mbr.S dd if=$(pwd)/bin/mbr of=~/bochs/hd60M.img bs=512 count=1 conv=notrunc #编译loader nasm -o $(pwd)/bin/loader -I $(pwd)/boot/include/ $(pwd)/boot/loader.S dd if=$(pwd)/bin/loader of=~/bochs/hd60M.img bs=512 count=4 seek=2 conv=notrunc #编译print函数 nasm -f elf32 -o $(pwd)/bin/print.o $(pwd)/lib/kernel/print.S # 编译kernel nasm -f elf32 -o $(pwd)/bin/kernel.o $(pwd)/kernel/kernel.S # 编译switch nasm -f elf32 -o $(pwd)/bin/switch.o $(pwd)/thread/switch.S #编译main文件 gcc-4.4 -o $(pwd)/bin/main.o -c -fno-builtin -m32 -I $(pwd)/lib/kernel/ -I $(pwd)/lib/ -I $(pwd)/kernel/ -I $(pwd)/device/ -I $(pwd)/thread/ $(pwd)/kernel/main.c #编译interrupt文件 gcc-4.4 -o $(pwd)/bin/interrupt.o -c -fno-builtin -m32 -I $(pwd)/lib/kernel/ -I $(pwd)/lib/ -I $(pwd)/kernel/ $(pwd)/kernel/interrupt.c #编译init文件 gcc-4.4 -o $(pwd)/bin/init.o -c -fno-builtin -m32 -I $(pwd)/lib/kernel/ -I $(pwd)/lib/ -I $(pwd)/kernel/ -I $(pwd)/thread/ -I $(pwd)/device/ $(pwd)/kernel/init.c # 编译debug文件 gcc-4.4 -o $(pwd)/bin/debug.o -c -fno-builtin -m32 -I $(pwd)/lib/kernel/ -I $(pwd)/lib/ -I $(pwd)/kernel/ $(pwd)/kernel/debug.c # 编译string文件 gcc-4.4 -o $(pwd)/bin/string.o -c -fno-builtin -m32 -I $(pwd)/lib/kernel/ -I $(pwd)/lib/ -I $(pwd)/kernel/ $(pwd)/lib/string.c # 编译bitmap文件 gcc-4.4 -o $(pwd)/bin/bitmap.o -c -fno-builtin -m32 -I $(pwd)/lib/kernel/ -I $(pwd)/lib/ -I $(pwd)/kernel/ $(pwd)/lib/kernel/bitmap.c # 编译memory文件 gcc-4.4 -o $(pwd)/bin/memory.o -c -fno-builtin -m32 -I $(pwd)/lib/kernel/ -I $(pwd)/lib/ -I $(pwd)/kernel/ $(pwd)/kernel/memory.c # 编译thread文件 gcc-4.4 -o $(pwd)/bin/thread.o -c -fno-builtin -m32 -I $(pwd)/lib/kernel/ -I $(pwd)/lib/ -I $(pwd)/kernel/ -I $(pwd)/thread/ $(pwd)/thread/thread.c # 编译list文件 gcc-4.4 -o $(pwd)/bin/list.o -c -fno-builtin -m32 -I $(pwd)/lib/kernel/ -I $(pwd)/lib/ -I $(pwd)/kernel/ $(pwd)/lib/kernel/list.c # 编译timer文件 gcc-4.4 -o $(pwd)/bin/timer.o -c -fno-builtin -m32 -I $(pwd)/lib/kernel/ -I $(pwd)/lib/ -I $(pwd)/kernel/ -I $(pwd)/thread/ $(pwd)/device/timer.c # 编译sync文件 gcc-4.4 -o $(pwd)/bin/sync.o -c -fno-builtin -m32 -I $(pwd)/lib/kernel/ -I $(pwd)/lib/ -I $(pwd)/kernel/ -I $(pwd)/thread/ $(pwd)/thread/sync.c # 编译console文件 gcc-4.4 -o $(pwd)/bin/console.o -c -fno-builtin -m32 -I $(pwd)/lib/kernel/ -I $(pwd)/lib/ -I $(pwd)/kernel/ -I $(pwd)/thread/ $(pwd)/device/console.c #将main函数与print函数进行链接 ld -m elf_i386 -Ttext 0xc0001500 -e main -o $(pwd)/bin/kernel.bin $(pwd)/bin/main.o $(pwd)/bin/kernel.o $(pwd)/bin/init.o $(pwd)/bin/thread.o $(pwd)/bin/switch.o $(pwd)/bin/list.o $(pwd)/bin/sync.o $(pwd)/bin/console.o $(pwd)/bin/timer.o $(pwd)/bin/interrupt.o $(pwd)/bin/memory.o $(pwd)/bin/bitmap.o $(pwd)/bin/print.o $(pwd)/bin/string.o $(pwd)/bin/debug.o #将内核文件写入磁盘，loader程序会将其加载到内存运行 dd if=$(pwd)/bin/kernel.bin of=~/bochs/hd60M.img bs=512 count=200 conv=notrunc seek=9 #rm -rf bin/* 运行结果如下所示\n","date":"2024-12-23T00:00:00Z","image":"https://raw.githubusercontent.com/jl-sky/imageDatesets/master/2024/12/upgit_20241223_1734950685.jpg","permalink":"http://localhost:1313/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9C%9F%E8%B1%A1%E8%BF%98%E5%8E%9F%E7%AC%AC%E5%8D%81%E7%AB%A0%E4%B8%80-%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E4%B9%8B%E4%BA%92%E6%96%A5%E9%94%81%E5%AE%9E%E7%8E%B0%E4%B8%8E%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/","title":"《操作系统真象还原》第十章（一） —— 同步机制之互斥锁实现与输出系统"},{"content":"本章节所有代码托管在miniOS_32\n章节任务介绍\r任务简介\r上一节，我们成功模拟pthread_create创建了新的线程并成功执行\n本节我们将介绍如何实现多线程轮转调度\n本节的主要任务有：\n创建多线程轮转调度的数据结构——双向链表 借时钟中断完成多线程的时间片轮转调度 任务目标\r/kernel/main.c\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include \u0026#34;print.h\u0026#34; #include \u0026#34;init.h\u0026#34; #include \u0026#34;thread.h\u0026#34; #include \u0026#34;interrupt.h\u0026#34; void thread_work_a(void *arg); void thread_work_b(void *arg); int main(void) { put_str(\u0026#34;I am kernel\\n\u0026#34;); init_all(); thread_start(\u0026#34;thread_work_a\u0026#34;, 31, thread_work_a, \u0026#34;pthread_create_A\\n\u0026#34;); thread_start(\u0026#34;thread_work_b\u0026#34;, 8, thread_work_b, \u0026#34;pthread_create_B\\n\u0026#34;); /*打开中断，主要是打开时钟中断，以让时间片轮转调度生效*/ intr_enable(); while (1) { put_str(\u0026#34;Main\u0026#34;); } return 0; } /* 线程执行函数 */ void thread_work_a(void *arg) { char *para = (char *)arg; while (1) put_str(para); } /* 线程执行函数 */ void thread_work_b(void *arg) { char *para = (char *)arg; while (1) put_str(para); } 如上所示，我们将实现多线程轮转——当用户创建thread_work_a和thread_work_b两个线程时，操作系统能够为每个线程分配时间片，并根据时间片进行轮转调度两个线程\n线程组织队列——双向链表\r如图所示，为了实现多线程的轮转调度，我们需要使用队列将存储线程信息的PCB组织起来，如就绪队列、阻塞队列等，为此需要首先需要定义这种数据结构——双向链表\n/lib/kernel/list.h\n首先定义链表的节点类型，将来其将作为PCB中的数据成员，负责将线程的PCB串联起来\n1 2 3 4 5 6 /*链表节点类型*/ struct list_elem { struct list_elem *prev; struct list_elem *next; }; 接下来定义双向链表的结构\n1 2 3 4 5 6 7 8 /*双链表类型*/ struct list { /*头结点*/ struct list_elem head; /*尾节点*/ struct list_elem tail; }; 然后是对链表的操作函数原型的定义\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 /*链表初始化*/ void list_init(struct list *); /*头插法*/ void list_insert_before(struct list_elem *cur, struct list_elem *elem); /*在链表头部插入元素*/ void list_push(struct list *plist, struct list_elem *elem); /*在链表尾部插入元素*/ void list_append(struct list *plist, struct list_elem *elem); /*移除元素*/ void list_remove(struct list_elem *pelem); /*弹出链表头部元素*/ struct list_elem *list_pop(struct list *plist); /*判断链表是否为空*/ bool list_empty(struct list *plist); /*获取链表长度*/ uint32_t list_len(struct list *plist); /*在链表中查找节点*/ bool elem_find(struct list *plist, struct list_elem *obj_elem); // 定义个叫function的函数类型，返回值是int，参数是链表结点指针与一个整形值 typedef bool(function)(struct list_elem *, int arg); /*判断链表中是否有节点elem 使得func(elem,arg)成立*/ struct list_elem *list_traversal(struct list *plist, function func, int arg); void list_iterate(struct list *plist); 以下是对链表操作的实现\n/lib/kernel/list.c\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 #include \u0026#34;list.h\u0026#34; #include \u0026#34;interrupt.h\u0026#34; /*初始化双向链表*/ void list_init(struct list *list) { list-\u0026gt;head.prev = NULL; list-\u0026gt;head.next = \u0026amp;list-\u0026gt;tail; list-\u0026gt;tail.prev = \u0026amp;list-\u0026gt;head; list-\u0026gt;tail.next = NULL; } /*把链表元素elem插入在元素cur之前*/ void list_insert_before(struct list_elem *cur, struct list_elem *elem) { // 插入元素之前先关中断，确保元素插入过程中不会被中断影响 enum intr_status old_status = intr_disable(); elem-\u0026gt;prev = cur-\u0026gt;prev; elem-\u0026gt;next = cur; cur-\u0026gt;prev-\u0026gt;next = elem; cur-\u0026gt;prev = elem; // 恢复关中断之前的状态 intr_set_status(old_status); } /*在链表头部插入元素*/ void list_push(struct list *plist, struct list_elem *elem) { list_insert_before(plist-\u0026gt;head.next, elem); } /*在链表尾部添加元素*/ void list_append(struct list *plist, struct list_elem *elem) { list_insert_before(\u0026amp;plist-\u0026gt;tail, elem); } /*删除链表元素节点*/ void list_remove(struct list_elem *pelem) { enum intr_status old_status = intr_disable(); pelem-\u0026gt;prev-\u0026gt;next = pelem-\u0026gt;next; pelem-\u0026gt;next-\u0026gt;prev = pelem-\u0026gt;prev; intr_set_status(old_status); } /*弹出链表头部元素*/ struct list_elem *list_pop(struct list *plist) { struct list_elem *elem = plist-\u0026gt;head.next; list_remove(elem); return elem; } /*在链表中查找元素obj_elem*/ bool elem_find(struct list *plist, struct list_elem *obj_elem) { struct list_elem *ptr = plist-\u0026gt;head.next; while (ptr != \u0026amp;plist-\u0026gt;tail) { if (ptr == obj_elem) return true; ptr = ptr-\u0026gt;next; } return false; } /*判断链表是否为空*/ bool list_empty(struct list *plist) { return (plist-\u0026gt;head.next == \u0026amp;plist-\u0026gt;tail); } /*返回链表长度*/ uint32_t list_len(struct list *plist) { struct list_elem *ptr = plist-\u0026gt;head.next; uint32_t len = 0; while (ptr != \u0026amp;plist-\u0026gt;tail) { ++len; ptr = ptr-\u0026gt;next; } return len; } /* 把链表plist中的每个元素elem和arg传给回调函数func, * arg给func用来判断elem是否符合条件. * 本函数的功能是遍历列表内所有节点elem * 逐个判断链表中是否有节点elem使得func(elem,arg)成立。 * 找到符合条件的元素返回元素指针,否则返回NULL. */ struct list_elem *list_traversal(struct list *plist, function func, int arg) { struct list_elem *ptr = plist-\u0026gt;head.next; if (list_empty(plist)) return NULL; while (ptr != \u0026amp;plist-\u0026gt;tail) { if (func(ptr, arg)) return ptr; ptr = ptr-\u0026gt;next; } return NULL; } 这部分内容相对简单，读者看代码即可明白\n唯一需要主要的是**，由于队列是公共资源，对于它的修改一定要保证为原子操作**，所以在对队列的修改操作都需要通过intr disable将中断关闭，旧中断状态用变量 old status 保存，以此保证修改操作的原子性(不可拆分、连续性),操作结束后再通过“intr set status(old status)”将中断恢复。\n多线程轮转调度\r轮转调度前的数据准备\r我们主要通过时钟中断进行线程调度，其主要过程如下：\n每个线程在运行之前都被分配一个时间片，这个时间片其实就是PCB中的优先级priority 假如thread_work_a这个线程被分配的时间片为31个时钟周期，那么每当线程thread_work_a运行一个时钟周期（也就是没发生一次时钟中断）之后，时间片就减一 因此我们需要有一个变量来记录线程可运行的剩余时间，也就是PCB当中的ticks 当ticks的值减为0的时候，就表示该线程的时间片用完了 此时调度函数便将该线程的状态从运行态修改为就绪态，然后将其插入到就绪态的末尾，并从就绪队列的头部弹出一个新的线程上cpu运行，然后继续上述过程，每运行一个时钟就减去一个时钟，直到可用的时钟用完继续切换 经过以上描述，我们需要为线程的PCB新增一些数据成员：\n用以表示该线程可运行的剩余时间（时钟数）：ticks 用以表示线程从运行开始到当前时间一共运行的时间：elapsed_ticks 用以将所有处于就绪状态的PCB连接起来，使其成为一个就绪队列的节点成员：general_tag 用以将所有线程PCB连接起来（只要是线程就连接，不管其处于什么状态），使其成为一个记录所有线程的队列的节点成员：all_list_tag 如下所示，是我们增添新成员后的PCB结构体\n/thread/thread.h\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 /*PCB结构体*/ struct task_struct { // 线程栈的栈顶指针 uint32_t *self_kstack; // 线程状态 enum task_status status; // 线程的优先级 uint8_t priority; // 线程函数名 char name[16]; // 线程在一个时间片上可运行的剩余时间（时钟数） uint8_t ticks; //记录线程从运行开始，已经运行的时间（时钟数） uint32_t elapsed_ticks; //用于连接就绪队列或者阻塞队列 struct list_elem general_tag; //用于连接存储所有线程的队列 struct list_elem all_list_tag; /* 进程自己页表的虚拟地址 由于线程共享进程的虚拟地址空间 因此线程PCB中此值为NULL */ uint32_t pgdir; // 用于PCB结构体的边界标记 uint32_t stack_magic; }; 同时我们需要定义就绪队列和存储所有线程的队列，以及其他必要的数据结构\n/thread/thread.c\n1 2 3 4 5 6 7 8 // 主线程PCB struct task_struct *main_thread; // 线程就绪队列 struct list thread_ready_list; // 存储所有任务的队列 struct list thread_all_list; // 存储临时队列节点 static struct list_elem *thread_tag; 由于PCB结构体已经修改，因此需要修改PCB的初始化逻辑，线程栈运行信息的初始化不必修改\n轮转调度前的初始化\r修改线程PCB初始化\r首先是PCB的初始化\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 /*初始化PCB*/ void init_thread(struct task_struct *pthread, char *name, int prio) { memset(pthread, 0, sizeof(*pthread)); strcpy(pthread-\u0026gt;name, name); // pthread-\u0026gt;status = TASK_RUNNGING; if (pthread == main_thread) pthread-\u0026gt;status = TASK_RUNNING; else pthread-\u0026gt;status = TASK_READY; pthread-\u0026gt;priority = prio; // 初始化线程在一个时间片上可运行的剩余时间 pthread-\u0026gt;ticks = prio; // 记录线程从运行开始，已经运行的时间 pthread-\u0026gt;elapsed_ticks = 0; /* 线程没有自己的地址空间 进程的pcb这一项才有用，指向自己的页表虚拟地址 */ pthread-\u0026gt;pgdir = (uint32_t)NULL; /* 一个线程的栈空间分配一页空间，将PCB放置在栈底 pthread是申请的一页空间的起始地址，因此加上一页的大小，就是栈顶指针 */ pthread-\u0026gt;self_kstack = (uint32_t *)((uint32_t)pthread + PG_SIZE); /*PCB的边界标记，防止栈顶指针覆盖掉PCB的内容*/ pthread-\u0026gt;stack_magic = 0x20241221; } 与之前PCB的初始化新增的部分是\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 if (pthread == main_thread) pthread-\u0026gt;status = TASK_RUNNING; else pthread-\u0026gt;status = TASK_READY; pthread-\u0026gt;priority = prio; // 初始化线程在一个时间片上可运行的剩余时间 pthread-\u0026gt;ticks = prio; // 记录线程从运行开始，已经运行的时间 pthread-\u0026gt;elapsed_ticks = 0; /* 线程没有自己的地址空间 进程的pcb这一项才有用，指向自己的页表虚拟地址 */ pthread-\u0026gt;pgdir = (uint32_t)NULL; 如前所述，priority是记录线程一个运行时间片的信息变量，ticks是记录线程剩余可运行的时钟数的信息变量，因此他们都被初始化为prio，其中prio是用户指定的，即线程的一个运行时间片时用户控制的；另外elapsed_ticks是记录线程从运行开始到当前时刻运行的所有时间，因此应该初始化为0\n需要另外说明的有两点\n其一，main_thread表示主线程，也就是内核main函数所代表的线程，由于之前我们在loader.S中加载内核并运行的时候，内核中并没有PCB，因此在这里我们需要也为其添加相关PCB信息，同时也因为main线程从一开始就是运行着的，因此应该对其PCB中的线程状态变量初始化为TASK_RUNNING\n其二，PCB中新增的pgdir变量，表示进程自己的页表虚拟地址，该信息是给将来的进程使用的，线程共享进程的虚拟地址空间，因此该值在这里应该为NULL\n线程运行函数的逻辑修改——就绪队列的初始化\r当PCB和线程栈的运行信息初始化后，就需要开始着手启动线程，但这是之前的逻辑\n但在这里，我们需要统一调度逻辑，因此，我们需要将准备好的PCB插入就绪队列和全队列中，将来由调度器从就绪队列中选择线程然后上CPU运行\n如下所示\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 /*根据线程栈的运行信息开始运行线程函数*/ struct task_struct *thread_start(char *name, int prio, thread_func function, void *func_args) { /* 1.分配一页的空间给线程作为线程执行的栈空间 */ struct task_struct *thread = get_kernel_pages(1); /* 2.初始化PCB，PCB里存放了线程的基本信息以及线程栈的栈顶指针 */ init_thread(thread, name, prio); /* 3.根据线程栈的栈顶指针，初始化线程栈，也就是初始化线程的运行信息 比如线程要执行的函数，以及函数参数 */ thread_create(thread, function, func_args); /* 4.将准备好PCB和运行信息的线程插入到就绪队列和存储所有任务的队列 */ ASSERT(!elem_find(\u0026amp;thread_ready_list, \u0026amp;thread-\u0026gt;general_tag)); list_append(\u0026amp;thread_ready_list, \u0026amp;thread-\u0026gt;general_tag); ASSERT(!elem_find(\u0026amp;thread_all_list, \u0026amp;thread-\u0026gt;all_list_tag)); list_append(\u0026amp;thread_all_list, \u0026amp;thread-\u0026gt;all_list_tag); // /*5.上述准备好线程运行时的栈信息后，即可运行执行函数了*/ // asm volatile(\u0026#34;movl %0,%%esp; \\ // pop %%ebp; \\ // pop %%ebx; \\ // pop %%edi; \\ // pop %%esi; \\ // ret\u0026#34; // : // : \u0026#34;g\u0026#34;(thread-\u0026gt;self_kstack) // : \u0026#34;memory\u0026#34;); return thread; } 以上我们对初始化逻辑进行一个总结\n初始化PCB 初始化线程栈的运行信息 将初始化所有信息的线程PCB插入就绪队列和全队列，将来由调度统一选择调度 在正式实现轮转调度之前，因为main线程的特殊性，我们还需要对main线程进行初始化，如下所示\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 /*获取当前正在运行的线程的PCB*/ struct task_struct *running_thread(void) { uint32_t esp; // 获取当前栈顶指针地址 asm(\u0026#34;mov %%esp,%0\u0026#34; : \u0026#34;=g\u0026#34;(esp)); /* 由于栈顶指针是在一页内存空间内，而PCB存储在这一页空间的起始地址处 因此栈顶指针地址取整得到的这一页空间的起始地址就是PCB的起始地址 */ return (struct task_struct *)(esp \u0026amp; 0xfffff000); } static void make_main_thread(void) { /* 因为main线程早已运行,咱们在loader.S中进入内核时的mov esp,0xc009f000, 就是为其预留了pcb,地址为0xc009e000,因此不需要通过get_kernel_page另分配一页*/ main_thread = running_thread(); init_thread(main_thread, \u0026#34;main\u0026#34;, 31); /* main函数是当前线程,当前线程不在thread_ready_list中, * 所以只将其加在thread_all_list中. */ ASSERT(!elem_find(\u0026amp;thread_all_list, \u0026amp;main_thread-\u0026gt;all_list_tag)); list_append(\u0026amp;thread_all_list, \u0026amp;main_thread-\u0026gt;all_list_tag); } // 初始化主线程 void thread_init(void) { put_str(\u0026#34;thread_init start\\n\u0026#34;); list_init(\u0026amp;thread_ready_list); list_init(\u0026amp;thread_all_list); make_main_thread(); put_str(\u0026#34;thread_init done\\n\u0026#34;); } 其初始化逻辑与之前是相同的，也就是对PCB和线程栈运行信息的初始化，但是由于main线程已经在运行，因此不需要对线程栈的运行信息进行初始化，也不需要将其添加到就绪队列，只需添加到全队列即可\n轮转调度\r接下来我们开始实现轮转调度\n首先是轮转调度的基本逻辑，如前所述\n每个线程在运行之前都被分配一个时间片，然后线程每执行一个时钟周期（每发生一次时钟中断），时间片就减一，直到减为0的时候就开始进行轮转调度 而我们知道，时钟中断无时无刻都在发生，每发生一次时钟中断都要触发一次时钟中断的中断处理程序，因此我们只需要修改时钟中断的中断处理程序，让其每次被调用的时候就将当前正在运行的线程可用时间（ticks）减去一，直到减为0的时候就调用调度函数 如下所示\n/device/timer.c\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 uint32_t ticks; // ticks是内核自中断开启以来总共的嘀嗒数 /* 时钟的中断处理函数 */ static void intr_timer_handler(void) { struct task_struct *cur_thread = running_thread(); // 检查栈是否溢出 ASSERT(cur_thread-\u0026gt;stack_magic == 0x20241221); // 记录此线程占用的cpu时间嘀 cur_thread-\u0026gt;elapsed_ticks++; // 从内核第一次处理时间中断后开始至今的滴哒数,内核态和用户态总共的嘀哒数 ticks++; if (cur_thread-\u0026gt;ticks == 0) { // 若进程时间片用完就开始调度新的进程上cpu schedule(); } else { // 将当前进程的时间片-1 cur_thread-\u0026gt;ticks--; } } 当然，我们要把上述中断处理程序注册到中断描述符表IDT中，如下所示，其中0x20是时钟中断的中断向量号\n1 2 3 4 5 6 7 void timer_init() { put_str(\u0026#34;timer_init start\\n\u0026#34;); /* 将时钟处理程序注册到IDT中 */ register_handler(0x20, intr_timer_handler); put_str(\u0026#34;timer_init done\\n\u0026#34;); } 具体的注册实现register_handler如下所示\n/kernel/interrupt.c\n1 2 3 4 5 6 /* 在中断处理程序数组第vector_no个元素中注册安装中断处理程序function */ void register_handler(uint8_t vector_no, intr_handler function) { /* idt_table数组中的函数是在进入中断后根据中断向量号调用的, * 见kernel/kernel.S的call [idt_table + %1*4] */ idt_table[vector_no] = function; } 上述由时钟中断触发的中断处理程序，最终当发生轮转调度时的处理如下所示\n把当前时间片已经用完的线程换到就绪队列尾 然后从就绪队列头取出一个新的线程换上执行新的时间片 /thread/thread.c\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 /*时间片轮转调度函数*/ void schedule(void) { ASSERT(intr_get_status() == INTR_OFF); /*在关中断的情况下 把当前时间片已经用完的线程换到就绪队列尾 然后从就绪队列头取出一个新的线程换上执行新的时间片 */ struct task_struct *cur = running_thread(); if (cur-\u0026gt;status == TASK_RUNNING) { ASSERT(!elem_find(\u0026amp;thread_ready_list, \u0026amp;cur-\u0026gt;general_tag)); list_append(\u0026amp;thread_ready_list, \u0026amp;cur-\u0026gt;general_tag); cur-\u0026gt;ticks = cur-\u0026gt;priority; cur-\u0026gt;status = TASK_READY; } else { /* 若此线程需要某事件发生后才能继续上cpu运行, 不需要将其加入队列,因为当前线程不在就绪队列中。*/ } /* 将thread_ready_list队列中的第一个就绪线程弹出,准备将其调度上cpu. */ ASSERT(!list_empty(\u0026amp;thread_ready_list)); thread_tag = NULL; // thread_tag清空 thread_tag = list_pop(\u0026amp;thread_ready_list); struct task_struct *next = elem2entry(struct task_struct, general_tag, thread_tag); next-\u0026gt;status = TASK_RUNNING; switch_to(cur, next); } 终于到了最后一步，将从就绪队列中拿到的新线程上cpu运行\n将当前正在运行的栈顶指针(esp)和寄存器映像保存到旧PCB中 将新PCB中的栈顶指针取出赋值给esp准备执行 借用ret指令弹出新线程的可执行函数地址，赋值给指令寄存器eip，正式运行新线程的执行函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 [bits 32] section .text global switch_to switch_to: ; 栈中此处是返回地址 push esi push edi push ebx push ebp ; 取出栈中的参数cur,cur = [esp+20] ; 即当前已经时间片运行结束的线程PCB mov eax,[esp+20] ; 保存栈顶指针esp到当前时间片运行结束的线程PCB的self_kstack字段, ; self_kstack在task_struct中的偏移为0, ; 所以直接往thread开头处存4字节便可。 mov [eax],esp ; 取出栈中的参数next, next = [esp+24] ; 即要被换上CPU的线程PCB mov eax,[esp+24] ;让esp指向新线程PCB中的运行栈的栈顶指针 mov esp,[eax] pop ebp pop ebx pop edi pop esi ; 返回到上面switch_to下面的那句注释的返回地址, ; 未由中断进入,第一次执行时会返回到kernel_thread ret\t编译运行\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 mkdir -p bin #编译mbr nasm -o $(pwd)/bin/mbr -I $(pwd)/boot/include/ $(pwd)/boot/mbr.S dd if=$(pwd)/bin/mbr of=~/bochs/hd60M.img bs=512 count=1 conv=notrunc #编译loader nasm -o $(pwd)/bin/loader -I $(pwd)/boot/include/ $(pwd)/boot/loader.S dd if=$(pwd)/bin/loader of=~/bochs/hd60M.img bs=512 count=4 seek=2 conv=notrunc #编译print函数 nasm -f elf32 -o $(pwd)/bin/print.o $(pwd)/lib/kernel/print.S # 编译kernel nasm -f elf32 -o $(pwd)/bin/kernel.o $(pwd)/kernel/kernel.S # 编译switch nasm -f elf32 -o $(pwd)/bin/switch.o $(pwd)/thread/switch.S #编译main文件 gcc-4.4 -o $(pwd)/bin/main.o -c -fno-builtin -m32 -I $(pwd)/lib/kernel/ -I $(pwd)/lib/ -I $(pwd)/kernel/ -I $(pwd)/device/ -I $(pwd)/thread/ $(pwd)/kernel/main.c #编译interrupt文件 gcc-4.4 -o $(pwd)/bin/interrupt.o -c -fno-builtin -m32 -I $(pwd)/lib/kernel/ -I $(pwd)/lib/ -I $(pwd)/kernel/ $(pwd)/kernel/interrupt.c #编译init文件 gcc-4.4 -o $(pwd)/bin/init.o -c -fno-builtin -m32 -I $(pwd)/lib/kernel/ -I $(pwd)/lib/ -I $(pwd)/kernel/ -I $(pwd)/thread/ -I $(pwd)/device/ $(pwd)/kernel/init.c # 编译debug文件 gcc-4.4 -o $(pwd)/bin/debug.o -c -fno-builtin -m32 -I $(pwd)/lib/kernel/ -I $(pwd)/lib/ -I $(pwd)/kernel/ $(pwd)/kernel/debug.c # 编译string文件 gcc-4.4 -o $(pwd)/bin/string.o -c -fno-builtin -m32 -I $(pwd)/lib/kernel/ -I $(pwd)/lib/ -I $(pwd)/kernel/ $(pwd)/lib/string.c # 编译bitmap文件 gcc-4.4 -o $(pwd)/bin/bitmap.o -c -fno-builtin -m32 -I $(pwd)/lib/kernel/ -I $(pwd)/lib/ -I $(pwd)/kernel/ $(pwd)/lib/kernel/bitmap.c # 编译memory文件 gcc-4.4 -o $(pwd)/bin/memory.o -c -fno-builtin -m32 -I $(pwd)/lib/kernel/ -I $(pwd)/lib/ -I $(pwd)/kernel/ $(pwd)/kernel/memory.c # 编译thread文件 gcc-4.4 -o $(pwd)/bin/thread.o -c -fno-builtin -m32 -I $(pwd)/lib/kernel/ -I $(pwd)/lib/ -I $(pwd)/kernel/ -I $(pwd)/thread/ $(pwd)/thread/thread.c # 编译list文件 gcc-4.4 -o $(pwd)/bin/list.o -c -fno-builtin -m32 -I $(pwd)/lib/kernel/ -I $(pwd)/lib/ -I $(pwd)/kernel/ $(pwd)/lib/kernel/list.c # 编译timer文件 gcc-4.4 -o $(pwd)/bin/timer.o -c -fno-builtin -m32 -I $(pwd)/lib/kernel/ -I $(pwd)/lib/ -I $(pwd)/kernel/ -I $(pwd)/thread/ $(pwd)/device/timer.c #将main函数与print函数进行链接 ld -m elf_i386 -Ttext 0xc0001500 -e main -o $(pwd)/bin/kernel.bin $(pwd)/bin/main.o $(pwd)/bin/thread.o $(pwd)/bin/switch.o $(pwd)/bin/list.o $(pwd)/bin/print.o $(pwd)/bin/init.o $(pwd)/bin/timer.o $(pwd)/bin/interrupt.o $(pwd)/bin/kernel.o $(pwd)/bin/memory.o $(pwd)/bin/bitmap.o $(pwd)/bin/string.o $(pwd)/bin/debug.o #将内核文件写入磁盘，loader程序会将其加载到内存运行 dd if=$(pwd)/bin/kernel.bin of=~/bochs/hd60M.img bs=512 count=200 conv=notrunc seek=9 #rm -rf bin/* 运行结果\n","date":"2024-12-22T00:00:00Z","image":"https://raw.githubusercontent.com/jl-sky/imageDatesets/master/2024/12/upgit_20241222_1734871213.png","permalink":"http://localhost:1313/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9C%9F%E8%B1%A1%E8%BF%98%E5%8E%9F%E7%AC%AC%E4%B9%9D%E7%AB%A0%E4%BA%8C-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%BD%AE%E8%BD%AC%E8%B0%83%E5%BA%A6/","title":"《操作系统真象还原》第九章（二） —— 多线程轮转调度"},{"content":"本章节所有代码托管在miniOS_32\n章节任务介绍\r任务简介\r上一节，我们初步完成了内核的内存管理部分的内容\n本节我们将正式开始操作系统进程管理的相关内容\n本节的主要任务有：\n创建并初始化PCB 模拟pthread_create函数创建线程并执行线程函数 任务目标\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include\u0026lt;pthread.h\u0026gt; #include\u0026lt;stdio.h\u0026gt; void* thread_work(void* args){ char* str=(char*)args; printf(\u0026#34;args is %s\\n\u0026#34;,str); return NULL; } int main(){ pthread_t tid; pthread_create(\u0026amp;tid,NULL,thread_work,\u0026#34;pthread_create\\n\u0026#34;); pthread_join(tid,NULL); return 0; } 本节我们将实现一个类似于pthread_create的函数，用于创建一个线程并执行传入的执行函数，最终实现的调用代码如下所示\n/kernel/main.c\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \u0026#34;print.h\u0026#34; #include \u0026#34;init.h\u0026#34; #include \u0026#34;thread.h\u0026#34; void thread_work(void *arg); int main(void) { put_str(\u0026#34;I am kernel\\n\u0026#34;); init_all(); thread_start(\u0026#34;thread_work\u0026#34;, 31, thread_work, \u0026#34;pthread_create\\n\u0026#34;); while (1); return 0; } /* 线程执行函数 */ void thread_work(void *arg) { char *para = (char *)arg; int i = 10; while (i--) put_str(para); } PCB简介\r如同上一节中的位图，位图是管理内存的数据结构，对于线程或者进程，也需要有一个数据结构对其进行管理，这个数据结构就是PCB。\nPCB（Process Control Block，进程控制块）是操作系统内部用于存储进程信息的数据结构。\n操作系统通过PCB来管理和调度进程。\nPCB 的生命周期：\n进程创建时：每当操作系统创建一个新的进程时，系统会为该进程分配一个PCB，初始化进程的各种信息； 进程执行时：进程在运行时，操作系统通过 PCB 来管理和调度进程。每当进程状态发生变化（如从就绪变为运行，或从运行变为阻塞），操作系统会更新 PCB； 进程终止时：当进程执行完毕或被终止时，操作系统会回收该进程的 PCB，并释放相关资源。 PCB的内容：\nPCB中包含了进程执行所需的各种信息，如进程状态、寄存器值、内存使用情况、I/O 状态等。\nPCB 的主要功能：\n进程管理：每个进程都有一个唯一的 PCB，操作系统通过它来追踪进程的状态、资源等信息。 上下文切换：当操作系统切换执行进程时，它会保存当前进程的 PCB，并加载下一个进程的 PCB，从而实现进程的上下文切换。 进程调度：操作系统通过PCB来选择下一个运行的进程。调度器根据进程的状态、优先级等信息做出决策。 以下是PCB的示意结构图\n在内核空间中创建并运行线程\r代码目录结构\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 . ├── bin │ ├── bitmap.o │ ├── debug.o │ ├── init.o │ ├── interrupt.o │ ├── kernel.bin │ ├── kernel.o │ ├── loader │ ├── main.o │ ├── mbr │ ├── memory.o │ ├── print.o │ ├── string.o │ └── thread.o ├── boot │ ├── include │ │ └── boot.inc │ ├── loader.S │ └── mbr.S ├── kernel │ ├── debug.c │ ├── debug.h │ ├── global.h │ ├── init.c │ ├── init.h │ ├── interrupt.c │ ├── interrupt.h │ ├── kernel.S │ ├── main.c │ ├── memory.c │ └── memory.h ├── lib │ ├── kernel │ │ ├── bitmap.c │ │ ├── bitmap.h │ │ ├── io.h │ │ ├── print.h │ │ └── print.S │ ├── stdint.h │ ├── string.c │ └── string.h ├── Makefile ├── start.sh └── thread ├── thread.c └── thread.h 数据结构定义\r/thread/thread.h\n定义进程或者线程的任务状态\n1 2 3 4 5 6 7 8 9 10 /*定义进程或者线程的任务状态*/ enum task_status { TASK_RUNNGING, TASK_READY, TASK_BLOCKED, TASK_WAITING, TASK_HANGING, TASK_DIED, }; 定义线程栈，存储线程执行时的运行信息\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 /*定义线程栈，存储线程执行时的运行信息*/ struct thread_stack { uint32_t ebp; uint32_t ebx; uint32_t edi; uint32_t esi; // 一个函数指针，指向线程执行函数，目的是为了实现通用的线程函数调用 void (*eip)(thread_func *func, void *func_args); // 以下三条是模仿call进入thread_start执行的栈内布局构建的，call进入就会压入参数与返回地址，因为我们是ret进入kernel_thread执行的 // 要想让kernel_thread正常执行，就必须人为给它造返回地址，参数 void(*unused_retaddr); // 一个栈结构占位 thread_func *function; void *func_args; }; 定义PCB，PCB的信息庞大复杂，我们将来一点点对其进行填充，本节只需要以下信息即可\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 /*PCB结构体*/ struct task_struct { // 线程栈的栈顶指针 uint32_t *self_kstack; // 线程状态 enum task_status status; // 线程的优先级 uint8_t priority; // 线程函数名 char name[16]; // 用于PCB结构体的边界标记 uint32_t stack_magic; }; 代码讲解\r代码逻辑\r向内存申请一页空间，分配给要创建的线程 初始化该线程的PCB 通过PCB中的栈顶指针进一步初始化线程栈的运行信息 正式运行线程执行函数 如下所示，thread_start就是我们最终要实现的用以模拟pthread_create的函数\n其包含了我们上述说的代码逻辑\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 /*根据线程栈的运行信息开始运行线程函数*/ struct task_struct *thread_start(char *name, int prio, thread_func function, void *func_args) { /*1.分配一页空间给线程作为线程执行的栈空间*/ struct task_struct *thread = get_kernel_pages(1); /*2.初始化PCB，PCB里存放了线程的基本信息以及线程栈的栈顶指针*/ init_thread(thread, name, prio); /* 3.根据线程栈的栈顶指针，初始化线程栈，也就是初始化线程的运行信息 比如线程要执行的函数，以及函数参数 */ thread_create(thread, function, func_args); /*4.上述准备好线程运行时的栈信息后，即可运行执行函数了*/ asm volatile(\u0026#34;movl %0,%%esp; \\ pop %%ebp; \\ pop %%ebx; \\ pop %%edi; \\ pop %%esi; \\ ret\u0026#34; : : \u0026#34;g\u0026#34;(thread-\u0026gt;self_kstack) : \u0026#34;memory\u0026#34;); return thread; } 关于最后执行运行函数的内联汇编代码，主要与线程栈的栈空间布局有关，我们在最后初始化栈空间的运行信息之后进行详细说明\n初始化PCB\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 /*PCB结构体*/ struct task_struct { // 线程栈的栈顶指针 uint32_t *self_kstack; // 线程状态 enum task_status status; // 线程的优先级 uint8_t priority; // 线程函数名 char name[16]; // 用于PCB结构体的边界标记 uint32_t stack_magic; }; PCB的初始化也就是对上述结构体进行初始化\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 /*初始化PCB*/ void init_thread(struct task_struct *pthread, char *name, int prio) { memset(pthread, 0, sizeof(*pthread)); strcpy(pthread-\u0026gt;name, name); pthread-\u0026gt;status = TASK_RUNNGING; pthread-\u0026gt;priority = prio; /* 一个线程的栈空间分配一页空间，将PCB放置在栈底 pthread是申请的一页空间的起始地址，因此加上一页的大小，就是栈顶指针 */ pthread-\u0026gt;self_kstack = (uint32_t *)((uint32_t)pthread + PG_SIZE); /*PCB的边界标记，防止栈顶指针覆盖掉PCB的内容*/ pthread-\u0026gt;stack_magic = 0x19991030; } 以下是创建的线程栈内存示意图\n初始化线程栈运行信息\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 /*根据PCB信息，初始化线程栈的运行信息*/ void thread_create(struct task_struct *pthread, thread_func function, void *func_args) { /*给线程栈空间的顶部预留出中断栈信息的空间*/ pthread-\u0026gt;self_kstack = (uint32_t *)((int)(pthread-\u0026gt;self_kstack) - sizeof(struct intr_stack)); /*给线程栈空间的顶部预留出线程栈信息的空间*/ pthread-\u0026gt;self_kstack = (uint32_t *)((int)(pthread-\u0026gt;self_kstack) - sizeof(struct thread_stack)); // 初始化线程栈，保存线程运行时需要的信息 struct thread_stack *kthread_stack = (struct thread_stack *)pthread-\u0026gt;self_kstack; // 线程执行函数 kthread_stack-\u0026gt;eip = kernel_thread; kthread_stack-\u0026gt;function = function; kthread_stack-\u0026gt;func_args = func_args; kthread_stack-\u0026gt;ebp = kthread_stack-\u0026gt;ebx = kthread_stack-\u0026gt;edi = kthread_stack-\u0026gt;esi = 0; } 其中线程执行函数如下所示\n1 2 3 4 static void kernel_thread(thread_func *function, void *func_args) { function(func_args); } 以下是初始化线程栈后的内存示意图\n创建并运行线程\r1 2 3 4 5 6 7 8 9 10 /*4.上述准备好线程运行时的栈信息后，即可运行执行函数了*/ asm volatile(\u0026#34;movl %0,%%esp; \\ pop %%ebp; \\ pop %%ebx; \\ pop %%edi; \\ pop %%esi; \\ ret\u0026#34; : : \u0026#34;g\u0026#34;(thread-\u0026gt;self_kstack) : \u0026#34;memory\u0026#34;); 如下所示，当线程栈初始化结束之后，栈顶指针首先弹出了寄存器映像\n1 2 3 4 pop %%ebp; \\ pop %%ebx; \\ pop %%edi; \\ pop %%esi; \\ 这样栈顶指针就指向了通用执行函数kernel_thread，这样接下来只需要调用kernel_thread，就调用了用户的执行函数\n于是接下来代码执行ret指令，ret指令会做两件事\n将当前栈顶指针的值弹出，然后赋值给指令寄存器EIP，这样就相当于调用了kernel_thread 由于弹出了栈顶指针的值，因此栈顶指针会回退 最后的结果如下所示\n于是接下来，根据c语言的函数调用约定，kernel_thread会取出占位的返回地址上边的两个参数，也就是执行函数的地址与执行函数的参数，然后调用执行函数运行\n完整代码\r/thread/thread.h\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 #ifndef __THREAD_THREAD_H #define __THREAD_THREAD_H #include \u0026#34;stdint.h\u0026#34; /*定义执行函数*/ typedef void thread_func(void *); /*定义进程或者线程的任务状态*/ enum task_status { TASK_RUNNGING, TASK_READY, TASK_BLOCKED, TASK_WAITING, TASK_HANGING, TASK_DIED, }; /*中断发生时调用中断处理程序的压栈情况*/ struct intr_stack { uint32_t vec_no; // pushad的压栈情况 uint32_t edi; uint32_t esi; uint32_t ebp; uint32_t esp_dummy; uint32_t ebx; uint32_t edx; uint32_t ecx; uint32_t eax; // 中断调用时处理器自动压栈的情况 uint32_t gs; uint32_t fs; uint32_t es; uint32_t ds; uint32_t err_code; void (*eip)(void); uint32_t cs; uint32_t eflags; void *esp; uint32_t ss; }; /*定义线程栈，存储线程执行时的运行信息*/ struct thread_stack { uint32_t ebp; uint32_t ebx; uint32_t edi; uint32_t esi; // 一个函数指针，指向线程执行函数，目的是为了实现通用的线程函数调用 void (*eip)(thread_func *func, void *func_args); // 以下三条是模仿call进入thread_start执行的栈内布局构建的，call进入就会压入参数与返回地址，因为我们是ret进入kernel_thread执行的 // 要想让kernel_thread正常执行，就必须人为给它造返回地址，参数 void(*unused_retaddr); // 一个栈结构占位 thread_func *function; void *func_args; }; /*PCB结构体*/ struct task_struct { // 线程栈的栈顶指针 uint32_t *self_kstack; // 线程状态 enum task_status status; // 线程的优先级 uint8_t priority; // 线程函数名 char name[16]; // 用于PCB结构体的边界标记 uint32_t stack_magic; }; /*初始化PCB*/ void init_thread(struct task_struct *pthread, char *name, int prio); /*根据PCB信息，初始化线程栈的运行信息*/ void thread_create(struct task_struct *pthread, thread_func function, void *func_args); /*根据线程栈的运行信息开始运行线程函数*/ struct task_struct *thread_start(char *name, int prio, thread_func function, void *func_args); #endif /thread/thread.c\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 #include \u0026#34;thread.h\u0026#34; #include \u0026#34;stdint.h\u0026#34; #include \u0026#34;string.h\u0026#34; #include \u0026#34;global.h\u0026#34; #include \u0026#34;memory.h\u0026#34; #define PG_SIZE 4096 static void kernel_thread(thread_func *function, void *func_args) { function(func_args); } /*初始化PCB*/ void init_thread(struct task_struct *pthread, char *name, int prio) { memset(pthread, 0, sizeof(*pthread)); strcpy(pthread-\u0026gt;name, name); pthread-\u0026gt;status = TASK_RUNNGING; pthread-\u0026gt;priority = prio; /*一个线程的栈空间分配一页空间，将PCB放置在栈底*/ pthread-\u0026gt;self_kstack = (uint32_t *)((uint32_t)pthread + PG_SIZE); pthread-\u0026gt;stack_magic = 0x19991030; } /*根据PCB信息，初始化线程栈的运行信息*/ void thread_create(struct task_struct *pthread, thread_func function, void *func_args) { /*给线程栈空间的顶部预留出中断栈信息的空间*/ pthread-\u0026gt;self_kstack = (uint32_t *)((int)(pthread-\u0026gt;self_kstack) - sizeof(struct intr_stack)); /*给线程栈空间的顶部预留出线程栈信息的空间*/ pthread-\u0026gt;self_kstack = (uint32_t *)((int)(pthread-\u0026gt;self_kstack) - sizeof(struct thread_stack)); // 初始化线程栈，保存线程运行时需要的信息 struct thread_stack *kthread_stack = (struct thread_stack *)pthread-\u0026gt;self_kstack; // 线程执行函数 kthread_stack-\u0026gt;eip = kernel_thread; kthread_stack-\u0026gt;function = function; kthread_stack-\u0026gt;func_args = func_args; kthread_stack-\u0026gt;ebp = kthread_stack-\u0026gt;ebx = kthread_stack-\u0026gt;edi = kthread_stack-\u0026gt;esi = 0; } /*根据线程栈的运行信息开始运行线程函数*/ struct task_struct *thread_start(char *name, int prio, thread_func function, void *func_args) { /*1.分配一页的空间给线程作为线程执行的栈空间*/ struct task_struct *thread = get_kernel_pages(1); /*2.初始化PCB，PCB里存放了线程的基本信息以及线程栈的栈顶指针*/ init_thread(thread, name, prio); /* 3.根据线程栈的栈顶指针，初始化线程栈，也就是初始化线程的运行信息 比如线程要执行的函数，以及函数参数 */ thread_create(thread, function, func_args); /*4.上述准备好线程运行时的栈信息后，即可运行执行函数了*/ asm volatile(\u0026#34;movl %0,%%esp; \\ pop %%ebp; \\ pop %%ebx; \\ pop %%edi; \\ pop %%esi; \\ ret\u0026#34; : : \u0026#34;g\u0026#34;(thread-\u0026gt;self_kstack) : \u0026#34;memory\u0026#34;); return thread; } 编译运行\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 mkdir -p bin #编译mbr nasm -o $(pwd)/bin/mbr -I $(pwd)/boot/include/ $(pwd)/boot/mbr.S dd if=$(pwd)/bin/mbr of=~/bochs/hd60M.img bs=512 count=1 conv=notrunc #编译loader nasm -o $(pwd)/bin/loader -I $(pwd)/boot/include/ $(pwd)/boot/loader.S dd if=$(pwd)/bin/loader of=~/bochs/hd60M.img bs=512 count=4 seek=2 conv=notrunc #编译print函数 nasm -f elf32 -o $(pwd)/bin/print.o $(pwd)/lib/kernel/print.S # 编译kernel nasm -f elf32 -o $(pwd)/bin/kernel.o $(pwd)/kernel/kernel.S #编译main文件 gcc-4.4 -o $(pwd)/bin/main.o -c -fno-builtin -m32 -I $(pwd)/lib/kernel/ -I $(pwd)/lib/ -I $(pwd)/kernel/ -I $(pwd)/thread/ $(pwd)/kernel/main.c #编译interrupt文件 gcc-4.4 -o $(pwd)/bin/interrupt.o -c -fno-builtin -m32 -I $(pwd)/lib/kernel/ -I $(pwd)/lib/ -I $(pwd)/kernel/ $(pwd)/kernel/interrupt.c #编译init文件 gcc-4.4 -o $(pwd)/bin/init.o -c -fno-builtin -m32 -I $(pwd)/lib/kernel/ -I $(pwd)/lib/ -I $(pwd)/kernel/ $(pwd)/kernel/init.c # 编译debug文件 gcc-4.4 -o $(pwd)/bin/debug.o -c -fno-builtin -m32 -I $(pwd)/lib/kernel/ -I $(pwd)/lib/ -I $(pwd)/kernel/ $(pwd)/kernel/debug.c # 编译string文件 gcc-4.4 -o $(pwd)/bin/string.o -c -fno-builtin -m32 -I $(pwd)/lib/kernel/ -I $(pwd)/lib/ -I $(pwd)/kernel/ $(pwd)/lib/string.c # 编译bitmap文件 gcc-4.4 -o $(pwd)/bin/bitmap.o -c -fno-builtin -m32 -I $(pwd)/lib/kernel/ -I $(pwd)/lib/ -I $(pwd)/kernel/ $(pwd)/lib/kernel/bitmap.c # 编译memory文件 gcc-4.4 -o $(pwd)/bin/memory.o -c -fno-builtin -m32 -I $(pwd)/lib/kernel/ -I $(pwd)/lib/ -I $(pwd)/kernel/ $(pwd)/kernel/memory.c # 编译thread文件 gcc-4.4 -o $(pwd)/bin/thread.o -c -fno-builtin -m32 -I $(pwd)/lib/kernel/ -I $(pwd)/lib/ -I $(pwd)/kernel/ -I $(pwd)/thread/ $(pwd)/thread/thread.c #将main函数与print函数进行链接 ld -m elf_i386 -Ttext 0xc0001500 -e main -o $(pwd)/bin/kernel.bin $(pwd)/bin/main.o $(pwd)/bin/thread.o $(pwd)/bin/print.o $(pwd)/bin/init.o $(pwd)/bin/interrupt.o $(pwd)/bin/kernel.o $(pwd)/bin/memory.o $(pwd)/bin/bitmap.o $(pwd)/bin/string.o $(pwd)/bin/debug.o #将内核文件写入磁盘，loader程序会将其加载到内存运行 dd if=$(pwd)/bin/kernel.bin of=~/bochs/hd60M.img bs=512 count=200 conv=notrunc seek=9 #rm -rf bin/* 运行结果如下所示\n可以看到，最后如期打印了执行函数中的信息\n","date":"2024-12-21T00:00:00Z","image":"https://raw.githubusercontent.com/jl-sky/imageDatesets/master/2024/12/upgit_20241221_1734775379.jpg","permalink":"http://localhost:1313/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9C%9F%E8%B1%A1%E8%BF%98%E5%8E%9F%E7%AC%AC%E4%B9%9D%E7%AB%A0%E4%B8%80-%E5%9C%A8%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4%E4%B8%AD%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B/","title":"《操作系统真象还原》第九章（一） —— 在内核空间中实现线程"},{"content":"本章节所有代码托管在miniOS_32\n章节任务介绍\r任务简介\r上一节，我们初步构建了管理内存需要的数据结构及其相关操作——位图\n本节我们将在上一节，的基础上正式实现操作系统的内存管理系统，直到malloc函数与free函数的完成\n本章的主要任务有：\n内存池的初始化 内存分配实现 最终实现的效果是\n内核程序向虚拟内存申请page个虚拟内存页面 操作系统在内核虚拟内存中寻找到空闲的连续page个虚拟页面 操作系统在内核物理内存池中找到page个物理页面（可能不连续） 逐一构建在虚拟内存池中找到的虚拟页面与在物理内存池中找到的物理页面之间的映射关系（本质上是在构建页表项和页目录项，然后装填页表和页目录表） 内存池的规划\r本节我们将规划实现三个内存池，分别是\n内核虚拟内存池 内核物理内存池 用户物理内存池 事实上，应该还有一个用户虚拟内存池，但这部分内容我们在线程管理部分再进行补充\n虚拟内存池规划在虚拟内存中，物理内存池规划在物理内存中，他们之间的关系通过页表进行关联\n物理内存池的规划\r目前为止，低1MB的物理内存是我们的内核相关代码和数据，从1MB往上2MB字节存放的是页目录表和内核页表内容，这两部分的数据我们是不能覆盖的，因此剩余的内存将供我们规划物理内存池\n我们在剩余空间中各取一半，分别最为用户物理内存池和内核物理内存池，如下所示\n虚拟内存池的规划\r目前我们暂时只对内核虚拟内存池（内核堆区空间）进行规划，在3GB ~ 4GB中间的内核虚拟空间中取一块作为虚拟内存池，其中起始地址为0xc0100000，也就是绕过低端的1MB内存\n位图的规划存放\r既然有物理内存池和虚拟内存池，位图作为管理内存空间的数据结构，当然也要有地方进行存放，这样我们才能从位图中知道哪些内存被使用了，哪些内存块是空闲的，从而进一步管理内存\n三种内存池对应着三种位图，由于我们还有一个用户虚拟内存池还暂时没有开辟，因此在这里应该是四种位图\n负责管理内核物理内存池的位图 负责管理用户物理内存池的位图 负责管理内核虚拟内存池的位图 负责管理用户虚拟内存池的位图 这里我们给出答案，我们位图放在低1MB字节物理空间中的内核文件中\n如下是我们在低1MB内存空间中已经使用的内存\n0x7c00 ~ 0x7e00是MBR程序 0x900是loader的起始地址 0x70000 ~ 0x9f000是我们内核文件的存放位置。0x70000是内核文件的起始地址，由于0x9fc000地址以下是我们可用的空间，因此我们选取0x9f000作为内核文件的最终位置（注意，这也意味着0x9f000其实就是内核的栈顶指针） 由于我们要把位图放在内核文件中，因此我们要在0x70000 ~ 0x9f000的空间中选取一块位置，另外我们规定一张位图的大小也占用4KB，也就是一页\n另外，将来我们要存放内核文件的PCB（占用4KB），所以0xc009e000 ~ 0xc009f000其实是拿来存放PCB的\n于是由于 0xc009e000已经是内核主线程的PCB，而一页大小为 0x1000，故再减去4页，即 0xc009e000-0x4000=0xc009a000。故我们的位图地址为0xc009a000，如下所示\n内存池的初始化\r代码目录结构\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 . ├── bin ├── boot │ ├── include │ │ └── boot.inc │ ├── loader.S │ └── mbr.S ├── kernel │ ├── debug.c │ ├── debug.h │ ├── global.h │ ├── init.c │ ├── init.h │ ├── interrupt.c │ ├── interrupt.h │ ├── kernel.S │ ├── main.c │ ├── memory.c │ └── memory.h ├── lib │ ├── kernel │ │ ├── bitmap.c │ │ ├── bitmap.h │ │ ├── io.h │ │ ├── print.h │ │ └── print.S │ ├── stdint.h │ ├── string.c │ └── string.h ├── Makefile └── start.sh 定义管理内存池的数据结构\r/kernel/memory.h\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #ifndef __KERNEL_MEMORY_H #define __KERNEL_MEMORY_H #include \u0026#34;stdint.h\u0026#34; #include \u0026#34;bitmap.h\u0026#34; /*管理虚拟内存池的数据结果*/ struct virtual_addr { struct bitmap vaddr_map; // 管理虚拟内存池的位图 uint32_t vaddr_start; // 虚拟内存池的起始地址 }; /*管理物理内存池的数据结构*/ struct pool { struct bitmap pool_bitmap; // 管理物理内存池的位图 uint32_t phy_addr_start; // 物理内存池的起始地址 uint32_t pool_size; // 物理内存池的大小 }; void mem_init(); #endif /kernel/memory.c\n如下定义需要的变量\n1 2 3 4 5 6 7 8 9 10 11 12 #define PG_SIZE 4096 /*虚拟内存池的位图在虚拟内存中的起始地址*/ #define MEM_BITMAP_BASE 0xc009a000 /*内核堆区的起始地址，堆区其实就是虚拟内存池*/ #define K_HEAP_START 0xc0100000 /*定义内核的虚拟内存池*/ struct virtual_addr kernel_vaddr; /*定义内核的物理内存池和用户的物理内存池*/ struct pool kernel_pool, user_pool; 在初始化三种内存池之前，我们需要首先找到当前可用的物理内存\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 所有内核页表占据的物理内存 一张页表占据4KB，共256张页表（一张页目录表+0号页表项和768号页表项共同指向的一张页表+769~1022号页表项指向的254张页表） */ uint32_t page_table_size = PG_SIZE * 256; // 目前已经使用的物理内存：0~1MB的内核空间+页表占据的空间 uint32_t used_mem = 0x100000 + page_table_size; // 当前所有可用的物理内存 uint32_t free_mem = all_mem - used_mem; // 当前所有可用的物理页数 uint16_t all_free_pages = free_mem / PG_SIZE; // 设置所有可用的内核物理页（物理内存池） uint16_t kernel_free_pages = all_free_pages / 2; // 设置所有可用的用户物理页（用户内存池） uint16_t user_free_pages = all_free_pages - kernel_free_pages; 如上所示\nall_mem表示物理内存总容量，该数值在loader.S中获取过，存放在0xb00位置处 used_mem表示当前已经使用的物理内存容量，包括低1MB的内核空间以及页目录表和255张页表占据的内存空间 于是free_mem就表示剩余可用的物理内存空间 由以上计算，我们就可以计算出内核物理内存池的起始地址、用户物理内存池的起始地址以及管理内核物理内存池和用户物理内存池的位图长度，如下所示\n1 2 3 4 5 6 7 8 9 10 11 12 /* 定义管理内核物理内存池的位图长度 位图中一个比特位管理一页物理内存，故用字节表示位图长度除以8即可 */ uint32_t kbm_length = kernel_free_pages / 8; // 定义管理用户物理内存池的位图长度 uint32_t ubm_length = user_free_pages / 8; // 内核物理内存池的起始地址 uint32_t kp_start = used_mem; // 用户物理内存池的起始地址 uint32_t up_start = kp_start + kernel_free_pages * PG_SIZE; 数据准备好之后，接下来初始化三种内存池\n初始化内核物理内存池\r1 2 3 4 5 /*以下初始化内核物理内存池*/ kernel_pool.pool_bitmap.btmp_bytes_len = kbm_length; kernel_pool.pool_bitmap.bits = (void *)MEM_BITMAP_BASE; kernel_pool.phy_addr_start = kp_start; kernel_pool.pool_size = kernel_free_pages * PG_SIZE; 初始化用户物理内存池\r1 2 3 4 5 /*以下初始化用户物理内存池*/ user_pool.pool_bitmap.btmp_bytes_len = ubm_length; user_pool.pool_bitmap.bits = (void *)(MEM_BITMAP_BASE + kbm_length); user_pool.phy_addr_start = up_start; user_pool.pool_size = user_free_pages * PG_SIZE; 初始化内核虚拟内存池\r1 2 3 4 5 /*初始化内核虚拟内存池*/ kernel_vaddr.vaddr_map.btmp_bytes_len = kbm_length; kernel_vaddr.vaddr_map.bits = (void *)(MEM_BITMAP_BASE + kbm_length + ubm_length); kernel_vaddr.vaddr_start = K_HEAP_START; bitmap_init(\u0026amp;kernel_vaddr.vaddr_map); 以下是完整的/kernel/memory.c\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 #include \u0026#34;memory.h\u0026#34; #include \u0026#34;print.h\u0026#34; #define PG_SIZE 4096 /*虚拟内存池的位图在虚拟内存中的起始地址*/ #define MEM_BITMAP_BASE 0xc009a000 /*内核堆区的起始地址，堆区其实就是虚拟内存池*/ #define K_HEAP_START 0xc0100000 /*定义内核的虚拟内存池*/ struct virtual_addr kernel_vaddr; /*定义内核的物理内存池和用户的物理内存池*/ struct pool kernel_pool, user_pool; /* 初始化内存池 参数：物理内存的所有容量，为32MB 该容量的数值存储在物理内存的0xb00处 */ static void mem_pool_init(uint32_t all_mem) { put_str(\u0026#34;memory pool init start!\\n\u0026#34;); /* 所有内核页表占据的物理内存 一张页表占据4KB，共256张页表（一张页目录表+0号页表项和768号页表项共同指向的一张页表+769~1022号页表项指向的254张页表） */ uint32_t page_table_size = PG_SIZE * 256; // 目前已经使用的物理内存：0~1MB的内核空间+页表占据的空间 uint32_t used_mem = 0x100000 + page_table_size; // 当前所有可用的物理内存 uint32_t free_mem = all_mem - used_mem; // 当前所有可用的物理页数 uint16_t all_free_pages = free_mem / PG_SIZE; // 设置所有可用的内核物理页（物理内存池） uint16_t kernel_free_pages = all_free_pages / 2; // 设置所有可用的用户物理页（用户内存池） uint16_t user_free_pages = all_free_pages - kernel_free_pages; /* 定义管理内核物理内存池的位图长度 位图中一个比特位管理一页物理内存，故用字节表示位图长度除以8即可 */ uint32_t kbm_length = kernel_free_pages / 8; // 定义管理用户物理内存池的位图长度 uint32_t ubm_length = user_free_pages / 8; // 内核物理内存池的起始地址 uint32_t kp_start = used_mem; // 用户物理内存池的起始地址 uint32_t up_start = kp_start + kernel_free_pages * PG_SIZE; /******************** 初始化物理内存池 **********************/ /*以下初始化内核物理内存池*/ kernel_pool.pool_bitmap.btmp_bytes_len = kbm_length; kernel_pool.pool_bitmap.bits = (void *)MEM_BITMAP_BASE; kernel_pool.phy_addr_start = kp_start; kernel_pool.pool_size = kernel_free_pages * PG_SIZE; /*以下初始化用户物理内存池*/ user_pool.pool_bitmap.btmp_bytes_len = ubm_length; user_pool.pool_bitmap.bits = (void *)(MEM_BITMAP_BASE + kbm_length); user_pool.phy_addr_start = up_start; user_pool.pool_size = user_free_pages * PG_SIZE; /******************** 输出物理内存池信息 **********************/ put_str(\u0026#34; kernel_pool_bitmap_start:\u0026#34;); put_int((int)kernel_pool.pool_bitmap.bits); put_str(\u0026#34; kernel_pool_phy_addr_start:\u0026#34;); put_int(kernel_pool.phy_addr_start); put_str(\u0026#34;\\n\u0026#34;); put_str(\u0026#34; user_pool_bitmap_start:\u0026#34;); put_int((int)user_pool.pool_bitmap.bits); put_str(\u0026#34; user_pool_phy_addr_start:\u0026#34;); put_int(user_pool.phy_addr_start); put_str(\u0026#34;\\n\u0026#34;); /*将位图置为0，初始化位图*/ bitmap_init(\u0026amp;kernel_pool.pool_bitmap); bitmap_init(\u0026amp;user_pool.pool_bitmap); /******************** 初始化虚拟内存池 **********************/ /*初始化内核虚拟内存池*/ kernel_vaddr.vaddr_map.btmp_bytes_len = kbm_length; kernel_vaddr.vaddr_map.bits = (void *)(MEM_BITMAP_BASE + kbm_length + ubm_length); kernel_vaddr.vaddr_start = K_HEAP_START; bitmap_init(\u0026amp;kernel_vaddr.vaddr_map); put_str(\u0026#34;memory pool init done!\\n\u0026#34;); } void mem_init() { put_str(\u0026#34;mem_init start\\n\u0026#34;); // 此处存放着物理内存容量，具体可见/boot/loader.S中total_mem_bytes的定义和计算 uint32_t mem_bytes_total = (*(uint32_t *)(0xb00)); // 初始化内存池 mem_pool_init(mem_bytes_total); put_str(\u0026#34;mem_init done\\n\u0026#34;); } 然后我们将内存池的初始化代码添加到/kernel/init.c中\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026#34;init.h\u0026#34; #include \u0026#34;print.h\u0026#34; #include \u0026#34;interrupt.h\u0026#34; #include \u0026#34;memory.h\u0026#34; /*初始化所有模块*/ void init_all() { put_str(\u0026#34;init_all\\n\u0026#34;); // 初始化中断 idt_init(); // 初始化内存管理系统 mem_init(); } 编译运行\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 mkdir -p bin #编译mbr nasm -o $(pwd)/bin/mbr -I $(pwd)/boot/include/ $(pwd)/boot/mbr.S dd if=$(pwd)/bin/mbr of=~/bochs/hd60M.img bs=512 count=1 conv=notrunc #编译loader nasm -o $(pwd)/bin/loader -I $(pwd)/boot/include/ $(pwd)/boot/loader.S dd if=$(pwd)/bin/loader of=~/bochs/hd60M.img bs=512 count=4 seek=2 conv=notrunc #编译print函数 nasm -f elf32 -o $(pwd)/bin/print.o $(pwd)/lib/kernel/print.S # 编译kernel nasm -f elf32 -o $(pwd)/bin/kernel.o $(pwd)/kernel/kernel.S #编译main文件 gcc-4.4 -o $(pwd)/bin/main.o -c -fno-builtin -m32 -I $(pwd)/lib/kernel/ -I $(pwd)/lib/ -I $(pwd)/kernel/ $(pwd)/kernel/main.c #编译interrupt文件 gcc-4.4 -o $(pwd)/bin/interrupt.o -c -fno-builtin -m32 -I $(pwd)/lib/kernel/ -I $(pwd)/lib/ -I $(pwd)/kernel/ $(pwd)/kernel/interrupt.c #编译init文件 gcc-4.4 -o $(pwd)/bin/init.o -c -fno-builtin -m32 -I $(pwd)/lib/kernel/ -I $(pwd)/lib/ -I $(pwd)/kernel/ $(pwd)/kernel/init.c # 编译debug文件 gcc-4.4 -o $(pwd)/bin/debug.o -c -fno-builtin -m32 -I $(pwd)/lib/kernel/ -I $(pwd)/lib/ -I $(pwd)/kernel/ $(pwd)/kernel/debug.c # 编译string文件 gcc-4.4 -o $(pwd)/bin/string.o -c -fno-builtin -m32 -I $(pwd)/lib/kernel/ -I $(pwd)/lib/ -I $(pwd)/kernel/ $(pwd)/lib/string.c # 编译bitmap文件 gcc-4.4 -o $(pwd)/bin/bitmap.o -c -fno-builtin -m32 -I $(pwd)/lib/kernel/ -I $(pwd)/lib/ -I $(pwd)/kernel/ $(pwd)/lib/kernel/bitmap.c # 编译memory文件 gcc-4.4 -o $(pwd)/bin/memory.o -c -fno-builtin -m32 -I $(pwd)/lib/kernel/ -I $(pwd)/lib/ -I $(pwd)/kernel/ $(pwd)/kernel/memory.c #将main函数与print函数进行链接 ld -m elf_i386 -Ttext 0xc0001500 -e main -o $(pwd)/bin/kernel.bin $(pwd)/bin/main.o $(pwd)/bin/print.o $(pwd)/bin/init.o $(pwd)/bin/interrupt.o $(pwd)/bin/kernel.o $(pwd)/bin/memory.o $(pwd)/bin/bitmap.o $(pwd)/bin/string.o $(pwd)/bin/debug.o #将内核文件写入磁盘，loader程序会将其加载到内存运行 dd if=$(pwd)/bin/kernel.bin of=~/bochs/hd60M.img bs=512 count=200 conv=notrunc seek=9 #rm -rf bin/* 运行结果如下所示\n如下，输出内存初始化的相关信息\n1 2 3 4 5 mem init startmemory pool init start! kernel pool bitmap start:c009A000 kernel pool phy_addr _start:200000 user pool bitmap start:C009A1E0 user pool phy addr start:1100000 memory pool init done! mem init done 内存管理第一步——分配页内存\r目标\r实现整页面的内存分配，我们最终会实现一个下边的函数，当传入参数3时，表示用户想获取3页内存，如果能够找到，就返回这3页内存的起始地址，否则返回NULL\n1 void *addr = get_kernel_pages(3); 代码逻辑\r在内核虚拟内存池中寻找到空闲的连续page个虚拟页面 在内核物理内存池中找到page个物理页面（可能不连续） 逐一构建找到的虚拟页面与物理页面之间的映射关系（本质上是在构建页表项和页目录项，然后装填页表和页目录表） 代码目录结构\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 . ├── bin ├── boot │ ├── include │ │ └── boot.inc │ ├── loader.S │ └── mbr.S ├── kernel │ ├── debug.c │ ├── debug.h │ ├── global.h │ ├── init.c │ ├── init.h │ ├── interrupt.c │ ├── interrupt.h │ ├── kernel.S │ ├── main.c │ ├── memory.c │ └── memory.h ├── lib │ ├── kernel │ │ ├── bitmap.c │ │ ├── bitmap.h │ │ ├── io.h │ │ ├── print.h │ │ └── print.S │ ├── stdint.h │ ├── string.c │ └── string.h ├── Makefile └── start.sh 数据结构准备\r我们在C语言中申请内存时，由于我们是用户程序，操作系统直接会在用户内存池中分配内存，但这对应到内核中具体的操作时，必须\n要“显式”指定在哪个内存池中申请，故我们在 memoryh 中新增了枚举结构 eum pool fags用来区分这两个内存池，此结构里面定义了两个成员\nPF KERNEL值为1，它代表内核物理内存池。 PFUSER值为2，它代表用户物理内存池 在/kernel/memory.h中添加相关信息\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 /*页表项属性宏*/ #define PG_P_1 1 // 页表项或页目录项存在属性位 #define PG_P_0 0 // 页表项或页目录项存在属性位 #define PG_RW_R 0 // R/W 属性位值, 读/执行 #define PG_RW_W 2 // R/W 属性位值, 读/写/执行 #define PG_US_S 0 // U/S 属性位值, 系统级 #define PG_US_U 4 // U/S 属性位值, 用户级 /*内存池类型*/ enum pool_flags { PF_KERNEL = 1, PF_USER = 2 }; /*返回虚拟地址vaddr所代表的pde（页目录项）的虚拟地址*/ uint32_t *pde_ptr(uint32_t vaddr); /*页表中添加虚拟地址_vaddr和物理地址_page_phyaddr的映射关系*/ uint32_t *pte_ptr(uint32_t vaddr); /*分配pg_cnt个页空间，成功也返回起始虚拟地址，失败则返回NULL*/ void *malloc_page(enum pool_flags pf, uint32_t pg_cnt); /*从内核物理内存池中申请pg_cnt页内存,成功则返回其虚拟地址,失败则返回NULL*/ void *get_kernel_pages(uint32_t pg_cnt); void malloc_init(void); 虚拟内存池中寻找连续的空闲虚拟页\r/kernel/memory.c\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 /* 在pf所指向的虚拟内存池中寻找pg_cnt空闲虚拟页，并分配之 */ static void *vaddr_get(enum pool_flags pf, uint32_t pg_cnt) { int vaddr_start = 0, bit_idx_start = -1; if (pf == PF_KERNEL) { /*内核虚拟内存池*/ // 寻找可用的连续页 bit_idx_start = bitmap_scan(\u0026amp;kernel_vaddr.vaddr_bitmap, pg_cnt); if (bit_idx_start == -1) return NULL; // 如果找到就将这些连续空间设置为已分配 uint32_t cnt = 0; while (cnt \u0026lt; pg_cnt) bitmap_set(\u0026amp;kernel_vaddr.vaddr_bitmap, bit_idx_start + cnt++, 1); vaddr_start = kernel_vaddr.vaddr_start + bit_idx_start * PG_SIZE; } else { /*用户虚拟内存池*/ } return (void *)vaddr_start; } 物理内存池中寻找空闲的物理页\r/kernel/memory.c\n1 2 3 4 5 6 7 8 9 10 11 12 /* 在m_pool(物理内存池数据结构)所指向的物理内存池中寻找一页空闲的物理页，并分配之 */ static void *palloc(struct pool *m_pool) { int bit_idx = bitmap_scan(\u0026amp;m_pool-\u0026gt;pool_bitmap, 1); if (bit_idx == -1) return NULL; bitmap_set(\u0026amp;m_pool-\u0026gt;pool_bitmap, bit_idx, 1); uint32_t page_phyaddr = ((bit_idx * PG_SIZE) + m_pool-\u0026gt;phy_addr_start); return (void *)page_phyaddr; }; 注意，不同于虚拟内存，物理内存很多时候是不连续的，而且我们也不需要他们是连续的，只需要虚拟内存是连续的，然后在页表中构建他们之间的映射关系即可，因此在这里我们实现的是在物理内存池中寻找一页空闲的物理页\n构建映射关系\r为了构建虚拟页和物理页的映射关系，我们需要装填页目录项和页表项，所以首先需要逆向推出虚拟页vaddr所在的页目录项和页表项虚拟地址，然后才能构建他们\n以下是通过虚拟页的虚拟地址获取其对应的页表项的虚拟地址\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // 取出虚拟地址的高10位 #define PDE_IDX(addr) ((addr \u0026amp; 0xffc00000) \u0026gt;\u0026gt; 22) // 取出虚拟地址的中间10位 #define PTE_IDX(addr) ((addr \u0026amp; 0x003ff000) \u0026gt;\u0026gt; 12) /* 返回虚拟地址vaddr所代表的pte（页表项）的虚拟地址 此举是为了取出虚拟地址vaddr所代表的页表项的内容 */ uint32_t *pte_ptr(uint32_t vaddr) { /* 0xffc00000：表示页目录表的第1023个页目录项，该页目录项的存储的是页目录表的物理地址(见loader.S中页目录项的初始化部分内容) vaddr \u0026amp; 0xffc00000：取出vaddr的高10位，也就是vaddr所代表的页目录项的索引 先访问到页目录表自己 + 再用页目录项pde(页目录内页表的索引)作为pte的索引访问到页表 + 再用pte的索引做为页内偏移 */ uint32_t *pte = (uint32_t *)(0xffc00000 + ((vaddr \u0026amp; 0xffc00000) \u0026gt;\u0026gt; 10) + PTE_IDX(vaddr) * 4); return pte; } 理下思路，处理器处理 32 位地址的三个步骤如下。\n(1)首先处理高10位的pde 索引，从而处理器得到页表物理地址。\n(2)其次处理中间10位的pte索引，进而处理器得到普通物理页的物理地址。\n(3)最后是把低12位作为普通物理页的页内偏移地址，此偏移地址加上物理页的物理地址，得到的地址之和便是最终的物理地址，处理器到此物理地址上进行读写操作。\n也就是说，我们要创造的这个新的虚拟地址new vaddr，它经过处理器以上三个步骤的拆分处理，最终会落到 vaddr 自身所在的pte的物理地址上。\npte 位于页表中，因此要想访问 vaddr 所在的 pte，必须先访问到页目录表，再通过其中的页目录项 pde，找到相应的页表，在页表中才是页表项 pte。\n因此，我们需要分别在地址的高 10 位、中间 10 位和低 12 位中填入合适的数，拼凑出满足此要求的新的32位地址newvaddr。\n第一步，先访问到页目录表。\n32 位虚拟地址中，高10位用于定位页目录项，由于最后一个页目录项保存的正是页目录表物理地址，我们可以让地址的高10位指向最后一个页目录项，即第1023个pde，这样刚好获取页目录表本身的物理地址。\n1023 换算成十六进制是0x3，将其移到高10后，变成0xffc00000。于是，0xffc00000让处理器自动在最后一个 pde 中取出页目录表物理地址，此处页目录表物理地址为0x100000，如果忘记的话，可以看看 boot/include/boot.inc 中的配置项 PAGE_DIR_TABLE_POS，其值便为 0x100000。\n在我们眼里,最后一个 pde 中的物理地址是页目录表地址,因为这是咱们在创建页表时提前安排好的 但处理器把保存在pde中的地址都视为页表地址，即处理器会把刚刚获得的页目录表当成页表来处理 第二步，找到页表。\n其次，处理器需要pte 索引。中间10位是页表项的索引，用来在页表中定位页表pte。\n我们在上一步中已经得到了页目录表物理地址(其实处理器把页目录表当成页表了)，页表地址保存在页目录项中，因此我们要先想办法访问到 vaddr 所在的页目录项。\n此时处理器已经把上一步获得的页目录表当成了页表，其需要的是 pte的索引，因此我们把 vaddr 的 pde 索引当作处理器视角中的 pte 索引就行了现在要做的是将参数 vaddr 的高10位(pde 索引)取出来，做新地址 new vaddr 的中间 10位(pte 索引)。\n于是我们先用按位与操作(vaddr\u0026amp;0xffc00000)获取高10位，再将其右移 10位，使其变成中间10位，就成了处理器眼中的pte索引。\n这样在处理器处理新地址 new vaddr的pte 索引时，以为接下来获得的是 pte 中的普通物理页地址，但这只是处理器视角中的情景。而事实上由于上一步我们获得的是页目录表地址，并且本步中传给它的pte索引是 vaddr 中的pde索引，故此时处理器获得的是 vaddr 中高10位的 pde索引所对应的 pde里保存的页表的物理地址,并不是 pte 中保存的普通物理页的物理地址。\n此时我们获得了vaddr 所在的页表物理地址。\n第三步，在页表中找到 pte。\n最后，处理器需要地址的低 12位。\n上一步中处理器认为已经找到了最终的物理页地址，所以它此时需要的是32位地址中的低12位，用该12位作为上一步中获取到的物理页的偏移量，当然，这依然只是处理器的视角。\n在我们眼里，上一步获得的是页表的物理地址，因此我们只要把 vaddr 的中间 10 位转换成处理器眼里的 12 位长度的页内偏移量就行了。\n由于地址的低 12 位寻址范围正好是一页的 4KB 大小，故处理器直接拿低 12位去寻址，不会再为其自动乘以4，因此，咱们得手动将vaddr的pte部分乘4后再交给处理器。这里的做法是先用PTE_IDX(vaddr) 获取 vaddr 的 pte 索引，即中间 10 位，再将其乘 4,即 PTE_IDX(vaddr)*4拼凑出了新虚拟地址new vaddr的低 12位。\n故0xffc00000+((vaddr \u0026amp;0xffc00000)\u0026gt;\u0026gt;10)+PTE_IDX(vaddr)*4的结果就是最终的新虚拟地址 new vaddr 的完整 32位数值，new vaddr 保存在指针变量 pte 中。由于此结果仅仅是个整型数值，需要将其通过强制类型转换，即(uint32_t *)，转换成32位整型地址。此时指针变量 pte 指向 vaddr 所在的 pte。最后通过 return pte 将此指针返回。\n同理，以下是返回虚拟地址vaddr所代表的pde（页目录项）的虚拟地址\n1 2 3 4 5 6 7 8 9 10 /* 返回虚拟地址vaddr所代表的pde（页目录项）的虚拟地址 此举是为了取出虚拟地址vaddr所代表的页目录项的内容 */ uint32_t *pde_ptr(uint32_t vaddr) { /* 0xfffff是用来访问到页表本身所在的地址 */ uint32_t *pde = (uint32_t *)((0xfffff000) + PDE_IDX(vaddr) * 4); return pde; } 由此，我们就可以构建申请的虚拟页和物理页之间映射关系了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 /* 页表中添加虚拟地址_vaddr和物理地址_page_phyaddr的映射关系 */ static void page_table_add(void *_vaddr, void *_page_phyaddr) { uint32_t vaddr = (uint32_t)_vaddr, page_phyaddr = (uint32_t)_page_phyaddr; uint32_t *pde = pde_ptr(vaddr); uint32_t *pte = pte_ptr(vaddr); /* 判断页目录内目录项的P位，若为1,则表示其指向的页表已存在，直接装填对应的页表项*/ if (*pde \u0026amp; 0x00000001) { // 如果页目录项P位为1，说明页目录项指向的页表存在，但是页表项不存在，则直接创建页表项 if (!(*pte \u0026amp; 0x00000001)) { // 填充页目录项 *pte = (page_phyaddr | PG_US_U | PG_RW_W | PG_P_1); } else { PANIC(\u0026#34;pte repeat\u0026#34;); *pte = (page_phyaddr | PG_US_U | PG_RW_W | PG_P_1); } } else { /* 页目录项指向的页表不存在，需要首先构建页表，然后再装填对应的页目录项和页表项 1.在物理内存池中寻找一页物理页分配给页表 2.将该页表初始化为0，防止这块内存的脏数据乱入 3.将该页表写入页目录项 4.构建页表项，填充进页表 */ // 在内核物理内存池找一页物理页分配给页表 uint32_t pde_phyaddr = (uint32_t)palloc(\u0026amp;kernel_pool); // 初始化页表清零 /* 访问到pde对应的物理地址,用pte取高20位便可. * 因为pte是基于该pde对应的物理地址内再寻址, * 把低12位置0便是该pde对应的物理页的起始*/ memset((void *)((int)pte \u0026amp; 0xfffff000), 0, PG_SIZE); // 将分配的页表物理地址写入页目录项 *pde = (pde_phyaddr | PG_US_U | PG_RW_W | PG_P_1); ASSERT(!(*pte \u0026amp; 0x00000001)); // 构建页表项，填充进页表 *pte = (page_phyaddr | PG_US_U | PG_RW_W | PG_P_1); } } 接下来，实现分配pg_cnt个页空间，成功则返回起始虚拟地址的函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 /* 分配pg_cnt个页空间，成功则返回起始虚拟地址，失败则返回NULL */ void *malloc_page(enum pool_flags pf, uint32_t pg_cnt) { /*********** malloc_page的原理是三个动作的合成: *********** 1通过vaddr_get在虚拟内存池中申请虚拟地址 2通过palloc在物理内存池中申请物理页 3通过page_table_add将以上得到的虚拟地址和物理地址在页表中完成映射 ***************************************************************/ ASSERT(pg_cnt \u0026gt; 0 \u0026amp;\u0026amp; pg_cnt \u0026lt; 3840); // 获取连续的pg_cnt个虚拟页 void *vaddr_start = vaddr_get(pf, pg_cnt); if (vaddr_start == NULL) return NULL; uint32_t vaddr = (uint32_t)vaddr_start, cnt = pg_cnt; struct pool *mem_pool = pf \u0026amp; PF_KERNEL ? \u0026amp;kernel_pool : \u0026amp;user_pool; /* 逐一申请物理页，然后再挨个映射进虚拟页 之所以物理页不能一次性申请，是因为物理页可能是离散的 但是虚拟页是连续的 */ while (cnt--) { void *page_phyaddr = palloc(mem_pool); if (page_phyaddr == NULL) return NULL; page_table_add((void *)vaddr, page_phyaddr); vaddr += PG_SIZE; } return vaddr_start; } 以下是/kernel/memory.c文件的完整内容\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 #include \u0026#34;memory.h\u0026#34; #include \u0026#34;print.h\u0026#34; #include \u0026#34;debug.h\u0026#34; #include \u0026#34;string.h\u0026#34; #define PG_SIZE 4096 /*虚拟内存池的位图在虚拟内存中的起始地址*/ #define MEM_BITMAP_BASE 0xc009a000 /*内核堆区的起始地址，堆区其实就是虚拟内存池*/ #define K_HEAP_START 0xc0100000 /*定义内核的虚拟内存池*/ struct virtual_addr kernel_vaddr; /*定义内核的物理内存池和用户的物理内存池*/ struct pool kernel_pool, user_pool; /* 初始化内存池 参数：物理内存的所有容量，为32MB 该容量的数值存储在物理内存的0xb00处 */ static void mem_pool_init(uint32_t all_mem) { put_str(\u0026#34;memory pool init start!\\n\u0026#34;); /* 所有内核页表占据的物理内存 一张页表占据4KB，共256张页表（一张页目录表+0号页目录项和768号页目录项共同指向的一张页表+769~1022号页表项指向的254张页表） */ uint32_t page_table_size = PG_SIZE * 256; // 目前已经使用的物理内存：0~1MB的内核空间+页表占据的空间 uint32_t used_mem = 0x100000 + page_table_size; // 当前所有可用的物理内存 uint32_t free_mem = all_mem - used_mem; // 当前所有可用的物理页数 uint16_t all_free_pages = free_mem / PG_SIZE; // 设置所有可用的内核物理页（物理内存池） uint16_t kernel_free_pages = all_free_pages / 2; // 设置所有可用的用户物理页（用户内存池） uint16_t user_free_pages = all_free_pages - kernel_free_pages; /* 定义管理内核物理内存池的位图长度 位图中一个比特位管理一页物理内存，故用字节表示位图长度除以8即可 */ uint32_t kbm_length = kernel_free_pages / 8; // 定义管理用户物理内存池的位图长度 uint32_t ubm_length = user_free_pages / 8; // 内核物理内存池的起始地址 uint32_t kp_start = used_mem; // 用户物理内存池的起始地址 uint32_t up_start = kp_start + kernel_free_pages * PG_SIZE; /******************** 初始化物理内存池 **********************/ /*以下初始化内核物理内存池*/ kernel_pool.pool_bitmap.btmp_bytes_len = kbm_length; kernel_pool.pool_bitmap.bits = (void *)MEM_BITMAP_BASE; kernel_pool.phy_addr_start = kp_start; kernel_pool.pool_size = kernel_free_pages * PG_SIZE; /*以下初始化用户物理内存池*/ user_pool.pool_bitmap.btmp_bytes_len = ubm_length; user_pool.pool_bitmap.bits = (void *)(MEM_BITMAP_BASE + kbm_length); user_pool.phy_addr_start = up_start; user_pool.pool_size = user_free_pages * PG_SIZE; /******************** 输出物理内存池信息 **********************/ put_str(\u0026#34; kernel_pool_bitmap_start:\u0026#34;); put_int((int)kernel_pool.pool_bitmap.bits); put_str(\u0026#34; kernel_pool_phy_addr_start:\u0026#34;); put_int(kernel_pool.phy_addr_start); put_str(\u0026#34;\\n\u0026#34;); put_str(\u0026#34; user_pool_bitmap_start:\u0026#34;); put_int((int)user_pool.pool_bitmap.bits); put_str(\u0026#34; user_pool_phy_addr_start:\u0026#34;); put_int(user_pool.phy_addr_start); put_str(\u0026#34;\\n\u0026#34;); /*将位图置为0，初始化位图*/ bitmap_init(\u0026amp;kernel_pool.pool_bitmap); bitmap_init(\u0026amp;user_pool.pool_bitmap); /******************** 初始化虚拟内存池 **********************/ /*初始化内核虚拟内存池*/ kernel_vaddr.vaddr_bitmap.btmp_bytes_len = kbm_length; kernel_vaddr.vaddr_bitmap.bits = (void *)(MEM_BITMAP_BASE + kbm_length + ubm_length); kernel_vaddr.vaddr_start = K_HEAP_START; bitmap_init(\u0026amp;kernel_vaddr.vaddr_bitmap); put_str(\u0026#34;memory pool init done!\\n\u0026#34;); } /* 在pf所指向的虚拟内存池中寻找pg_cnt空闲虚拟页，并分配之 */ static void *vaddr_get(enum pool_flags pf, uint32_t pg_cnt) { int vaddr_start = 0, bit_idx_start = -1; if (pf == PF_KERNEL) { /*内核虚拟内存池*/ // 寻找可用的连续页 bit_idx_start = bitmap_scan(\u0026amp;kernel_vaddr.vaddr_bitmap, pg_cnt); if (bit_idx_start == -1) return NULL; // 如果找到就将这些连续空间设置为已分配 uint32_t cnt = 0; while (cnt \u0026lt; pg_cnt) bitmap_set(\u0026amp;kernel_vaddr.vaddr_bitmap, bit_idx_start + cnt++, 1); vaddr_start = kernel_vaddr.vaddr_start + bit_idx_start * PG_SIZE; } else { /*用户虚拟内存池*/ } return (void *)vaddr_start; } /* 在m_pool(物理内存池数据结构)所指向的物理内存池中寻找一页空闲的物理页，并分配之 */ static void *palloc(struct pool *m_pool) { int bit_idx = bitmap_scan(\u0026amp;m_pool-\u0026gt;pool_bitmap, 1); if (bit_idx == -1) return NULL; bitmap_set(\u0026amp;m_pool-\u0026gt;pool_bitmap, bit_idx, 1); uint32_t page_phyaddr = ((bit_idx * PG_SIZE) + m_pool-\u0026gt;phy_addr_start); return (void *)page_phyaddr; }; // 取出虚拟地址的高10位 #define PDE_IDX(addr) ((addr \u0026amp; 0xffc00000) \u0026gt;\u0026gt; 22) // 取出虚拟地址的中间10位 #define PTE_IDX(addr) ((addr \u0026amp; 0x003ff000) \u0026gt;\u0026gt; 12) /* 返回虚拟地址vaddr所代表的pte（页表项）的虚拟地址 此举是为了取出虚拟地址vaddr所代表的页表项的内容 */ uint32_t *pte_ptr(uint32_t vaddr) { /* 0xffc00000：表示页目录表的第1023个页目录项，该页目录项的存储的是页目录表的物理地址(见loader.S中页目录项的初始化部分内容) vaddr \u0026amp; 0xffc00000：取出vaddr的高10位，也就是vaddr所代表的页目录项的索引 先访问到页目录表自己 + 再用页目录项pde(页目录内页表的索引)作为pte的索引访问到页表 + 再用pte的索引做为页内偏移 */ uint32_t *pte = (uint32_t *)(0xffc00000 + ((vaddr \u0026amp; 0xffc00000) \u0026gt;\u0026gt; 10) + PTE_IDX(vaddr) * 4); return pte; } /* 返回虚拟地址vaddr所代表的pde（页目录项）的虚拟地址 此举是为了取出虚拟地址vaddr所代表的页目录项的内容 */ uint32_t *pde_ptr(uint32_t vaddr) { /* 0xfffff是用来访问到页表本身所在的地址 */ uint32_t *pde = (uint32_t *)((0xfffff000) + PDE_IDX(vaddr) * 4); return pde; } /* 页表中添加虚拟地址_vaddr和物理地址_page_phyaddr的映射关系 */ static void page_table_add(void *_vaddr, void *_page_phyaddr) { uint32_t vaddr = (uint32_t)_vaddr, page_phyaddr = (uint32_t)_page_phyaddr; uint32_t *pde = pde_ptr(vaddr); uint32_t *pte = pte_ptr(vaddr); /* 判断页目录内目录项的P位，若为1,则表示其指向的页表已存在，直接装填对应的页表项*/ if (*pde \u0026amp; 0x00000001) { // 如果页目录项P位为1，说明页目录项指向的页表存在，但是页表项不存在，则直接创建页表项 if (!(*pte \u0026amp; 0x00000001)) { // 填充页目录项 *pte = (page_phyaddr | PG_US_U | PG_RW_W | PG_P_1); } else { PANIC(\u0026#34;pte repeat\u0026#34;); *pte = (page_phyaddr | PG_US_U | PG_RW_W | PG_P_1); } } else { /* 页目录项指向的页表不存在，需要首先构建页表，然后再装填对应的页目录项和页表项 1.在物理内存池中寻找一页物理页分配给页表 2.将该页表初始化为0，防止这块内存的脏数据乱入 3.将该页表写入页目录项 4.构建页表项，填充进页表 */ // 在内核物理内存池找一页物理页分配给页表 uint32_t pde_phyaddr = (uint32_t)palloc(\u0026amp;kernel_pool); // 初始化页表清零 /* 访问到pde对应的物理地址,用pte取高20位便可. * 因为pte是基于该pde对应的物理地址内再寻址, * 把低12位置0便是该pde对应的物理页的起始*/ memset((void *)((int)pte \u0026amp; 0xfffff000), 0, PG_SIZE); // 将分配的页表物理地址写入页目录项 *pde = (pde_phyaddr | PG_US_U | PG_RW_W | PG_P_1); ASSERT(!(*pte \u0026amp; 0x00000001)); // 构建页表项，填充进页表 *pte = (page_phyaddr | PG_US_U | PG_RW_W | PG_P_1); } } /* 分配pg_cnt个页空间，成功也返回起始虚拟地址，失败则返回NULL */ void *malloc_page(enum pool_flags pf, uint32_t pg_cnt) { /*********** malloc_page的原理是三个动作的合成: *********** 1通过vaddr_get在虚拟内存池中申请虚拟地址 2通过palloc在物理内存池中申请物理页 3通过page_table_add将以上得到的虚拟地址和物理地址在页表中完成映射 ***************************************************************/ ASSERT(pg_cnt \u0026gt; 0 \u0026amp;\u0026amp; pg_cnt \u0026lt; 3840); // 获取连续的pg_cnt个虚拟页 void *vaddr_start = vaddr_get(pf, pg_cnt); if (vaddr_start == NULL) return NULL; uint32_t vaddr = (uint32_t)vaddr_start, cnt = pg_cnt; struct pool *mem_pool = pf \u0026amp; PF_KERNEL ? \u0026amp;kernel_pool : \u0026amp;user_pool; /* 逐一申请物理页，然后再挨个映射进虚拟页 之所以物理页不能一次性申请，是因为物理页可能是离散的 但是虚拟页是连续的 */ while (cnt--) { void *page_phyaddr = palloc(mem_pool); if (page_phyaddr == NULL) return NULL; page_table_add((void *)vaddr, page_phyaddr); vaddr += PG_SIZE; } return vaddr_start; } /* 从内核物理内存池中申请pg_cnt页内存,成功则返回其虚拟地址,失败则返回NULL */ void *get_kernel_pages(uint32_t pg_cnt) { void *vaddr = malloc_page(PF_KERNEL, pg_cnt); if (vaddr) memset(vaddr, 0, pg_cnt * PG_SIZE); return vaddr; } /* 内存管理初始化入口 */ void mem_init(void) { put_str(\u0026#34;mem_init start\\n\u0026#34;); // 此处存放着物理内存容量，具体可见/boot/loader.S中total_mem_bytes的定义和计算 uint32_t mem_bytes_total = (*(uint32_t *)(0xb00)); // 初始化内存池 mem_pool_init(mem_bytes_total); put_str(\u0026#34;mem_init done\\n\u0026#34;); } 然后我们在/kernel/main.c文件中测试\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026#34;print.h\u0026#34; #include \u0026#34;init.h\u0026#34; #include \u0026#34;debug.h\u0026#34; #include \u0026#34;memory.h\u0026#34; int main(void) { put_str(\u0026#34;I am kernel\\n\u0026#34;); init_all(); // 初始化中断并打开时钟中断 void *addr = get_kernel_pages(3); put_str(\u0026#34;\\n get_kernel_pages start vaddr is:\u0026#34;); put_int((uint32_t)addr); put_str(\u0026#34;\\n\u0026#34;); while (1) ; return 0; } 编译运行\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 mkdir -p bin #编译mbr nasm -o $(pwd)/bin/mbr -I $(pwd)/boot/include/ $(pwd)/boot/mbr.S dd if=$(pwd)/bin/mbr of=~/bochs/hd60M.img bs=512 count=1 conv=notrunc #编译loader nasm -o $(pwd)/bin/loader -I $(pwd)/boot/include/ $(pwd)/boot/loader.S dd if=$(pwd)/bin/loader of=~/bochs/hd60M.img bs=512 count=4 seek=2 conv=notrunc #编译print函数 nasm -f elf32 -o $(pwd)/bin/print.o $(pwd)/lib/kernel/print.S # 编译kernel nasm -f elf32 -o $(pwd)/bin/kernel.o $(pwd)/kernel/kernel.S #编译main文件 gcc-4.4 -o $(pwd)/bin/main.o -c -fno-builtin -m32 -I $(pwd)/lib/kernel/ -I $(pwd)/lib/ -I $(pwd)/kernel/ $(pwd)/kernel/main.c #编译interrupt文件 gcc-4.4 -o $(pwd)/bin/interrupt.o -c -fno-builtin -m32 -I $(pwd)/lib/kernel/ -I $(pwd)/lib/ -I $(pwd)/kernel/ $(pwd)/kernel/interrupt.c #编译init文件 gcc-4.4 -o $(pwd)/bin/init.o -c -fno-builtin -m32 -I $(pwd)/lib/kernel/ -I $(pwd)/lib/ -I $(pwd)/kernel/ $(pwd)/kernel/init.c # 编译debug文件 gcc-4.4 -o $(pwd)/bin/debug.o -c -fno-builtin -m32 -I $(pwd)/lib/kernel/ -I $(pwd)/lib/ -I $(pwd)/kernel/ $(pwd)/kernel/debug.c # 编译string文件 gcc-4.4 -o $(pwd)/bin/string.o -c -fno-builtin -m32 -I $(pwd)/lib/kernel/ -I $(pwd)/lib/ -I $(pwd)/kernel/ $(pwd)/lib/string.c # 编译bitmap文件 gcc-4.4 -o $(pwd)/bin/bitmap.o -c -fno-builtin -m32 -I $(pwd)/lib/kernel/ -I $(pwd)/lib/ -I $(pwd)/kernel/ $(pwd)/lib/kernel/bitmap.c # 编译memory文件 gcc-4.4 -o $(pwd)/bin/memory.o -c -fno-builtin -m32 -I $(pwd)/lib/kernel/ -I $(pwd)/lib/ -I $(pwd)/kernel/ $(pwd)/kernel/memory.c #将main函数与print函数进行链接 ld -m elf_i386 -Ttext 0xc0001500 -e main -o $(pwd)/bin/kernel.bin $(pwd)/bin/main.o $(pwd)/bin/print.o $(pwd)/bin/init.o $(pwd)/bin/interrupt.o $(pwd)/bin/kernel.o $(pwd)/bin/memory.o $(pwd)/bin/bitmap.o $(pwd)/bin/string.o $(pwd)/bin/debug.o #将内核文件写入磁盘，loader程序会将其加载到内存运行 dd if=$(pwd)/bin/kernel.bin of=~/bochs/hd60M.img bs=512 count=200 conv=notrunc seek=9 #rm -rf bin/* 运行结果如下所示\n如图所示，屏幕上如预期打印了我们想要的信息\n内核物理内存池的起始物理地址，为0x200000 在main.c中申请到的连续三个页面的其实虚拟地址为0xc0100000。 ","date":"2024-12-20T00:00:00Z","image":"https://raw.githubusercontent.com/jl-sky/imageDatesets/master/2024/12/upgit_20241220_1734661126.jpg","permalink":"http://localhost:1313/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9C%9F%E8%B1%A1%E8%BF%98%E5%8E%9F%E7%AC%AC%E5%85%AB%E7%AB%A0%E4%BA%8C-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/","title":"《操作系统真象还原》第八章（二） —— 内存管理系统"},{"content":"本章节所有代码托管在miniOS_32\n章节任务介绍\r任务简介\r上一节，我们成功为我们的内核开启了中断机制，并使用时钟中断进行了测试\n本节我们将开启操作系统内存管理的相关内容\n本章的主要任务有：\n实现ASSERT断言 实现字符串处理函数 实现管理物理内存的数据结构位图 实现assert断言\r断言介绍\r断言（Assertion） 可视为一种调试工具，主要用于检测程序在运行时是否满足某个条件。如果断言条件为 真，程序继续执行；如果为 假，程序通常会停止执行并抛出错误信息，帮助开发者发现潜在的问题。\n断言语句通常具有以下结构：\n1 assert( condition, \u0026#34;Error message if condition is false\u0026#34;) condition 是你期望为真的条件。 如果 condition 为 True，程序继续执行。 如果 condition 为 False，则会抛出一个异常或错误，并输出后面的错误信息。 断言实现\r中断状态控制\r一方面，当内核运行中出现问题时，多属于严重的错误，着实没必要再运行下去了。另一方面，断言在输出报错信息时，屏幕输出不应该被其他进程干扰，这样咱们才能专注于报错信息。\n综上两点原因,ASSERT排查出错误后，最好在关中断的情况下打印报错信息。\n内核运行时，为了通过时钟中断定时调度其他任务，大部分情况下中断是打开的，因此我们需要实现一些可以控制中断开关的函数\n如下，在/kernel/interrupt.h中添加中断状态的数据结构，以及控制中断状态的函数声明\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 /*定义中断状态*/ enum intr_status { INTR_OFF, // 表示中断关闭 INTR_ON // 表示中断打开 }; /* 获取当前中断状态 */ enum intr_status intr_get_status(void); /* 开中断并返回开中断前的状态*/ enum intr_status intr_enable(void); /* 关中断,并且返回关中断前的状态 */ enum intr_status intr_disable(void); /* 将中断状态设置为status */ enum intr_status intr_set_status(enum intr_status); 然后我们在/kernel/interrupt.c中实现其功能\n获取中断状态\r如下是eflags寄存器中所有的控制状态位\n其中第9位，IF位用于表示和控制中断状态\nIF位为1，表示系统处于开中断状态 IF位为0，表示系统处于关中断状态 第9位的十六进制数为0x2000，故我们以此作为掩码，来获取eflags中IF位的值，从而获取中断状态\n如下定义IF位的掩码\n1 2 3 /*eflags寄存器中的if位的掩码*/ #define EFLAGS_IF 0x00000200 // 表示eflags寄存器中的if位为1 // 将该宏与当前的if位（中断状态）进行与操作，即可获取当前的中断状态 同时利用IF位的掩码定义获取IF位的宏\n1 2 3 4 5 6 7 /* 功能：获取eflags寄存器中的值 pushfl将eflags寄存器中的值压入栈顶，再使用popl将栈顶的值弹出到EFLAG_VAR所在内存中 该约束自然用表示内存的字母，但是内联汇编中没有专门表示约束内存的字母，所以只能用g 代表可以是任意寄存器，内存或立即数 */ #define GET_EFLAGS(EFLAG_VAR) asm volatile(\u0026#34;pushfl;pop %0\u0026#34; : \u0026#34;=g\u0026#34;(EFLAG_VAR)) 接下来就可以实现获取中断状态的函数了，如下所示\n1 2 3 4 5 6 7 /* 获取当前中断状态 */ enum intr_status intr_get_status() { uint32_t eflags = 0; GET_EFLAGS(eflags); return (EFLAGS_IF \u0026amp; eflags) ? INTR_ON : INTR_OFF; } 开中断控制函数\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 /* 开中断并返回开中断前的状态*/ enum intr_status intr_enable() { enum intr_status old_status; if (INTR_ON == intr_get_status()) { old_status = INTR_ON; return old_status; } else { old_status = INTR_OFF; asm volatile(\u0026#34;sti\u0026#34;); // 开中断,sti指令将IF位置1 return old_status; } } 注，sti指令用于开中断\n关中断控制函数\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /* 关中断,并且返回关中断前的状态 */ enum intr_status intr_disable() { enum intr_status old_status; if (INTR_ON == intr_get_status()) { old_status = INTR_ON; asm volatile(\u0026#34;cli\u0026#34; : : : \u0026#34;memory\u0026#34;); // 关中断,cli指令将IF位置0 // cli指令不会直接影响内存。然而，从一个更大的上下文来看，禁用中断可能会影响系统状态， // 这个状态可能会被存储在内存中。所以改变位填 \u0026#34;memory\u0026#34; 是为了安全起见，确保编译器在生成代码时考虑到这一点。 return old_status; } else { old_status = INTR_OFF; return old_status; } } 设置中断状态函数\r1 2 3 4 5 /* 将中断状态设置为status */ enum intr_status intr_set_status(enum intr_status status) { return status \u0026amp; INTR_ON ? intr_enable() : intr_disable(); // enable与disable函数会返回旧中断状态 } 断言实现\r我们首先在/kernel/debug.h中定义ASSERT的断言宏\n1 2 3 4 5 6 7 8 9 10 11 12 /* 如果CONDITION条件为真则什么也不做 否则就输出相关断言信息 */ #define ASSERT(CONDITION) \\ if (CONDITION) \\ { \\ } \\ else \\ { \\ PANIC(#CONDITION); \\ } // 加#后，传入的参数变成字符串 其实现逻辑很简单，如果CONDITION条件为真，则什么也不做，否则就调用PANIC宏，将判断为假的条件作为字符串参数传入，然后打印错误信息\n其中PANIC宏的实现如下\n1 2 3 4 5 6 7 void panic_spin(char *filename, int line, const char *func, const char *condition); /* ...是可变参数，也就是随便你传多少个参数，然后原封不动地传到__VA_ARGS_那里去 __FILE__,__LINE__,__func__是预定义宏，代表这个宏所在的文件名，行数，与函数名字，编译器处理 */ #define PANIC(...) panic_spin(__FILE__, __LINE__, __func__, __VA_ARGS__) 可以看到，PANIC宏的实现是通过调用panic_spin函数将错误信息进行打印实现的\npanic_spin函数定义在/kernel/debug.c中，如下所示\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 /* 打印文件名,行号,函数名,条件，并使程序悬停 */ void panic_spin(char *filename, int line, const char *func, const char *condition) { intr_disable(); // 发生错误时打印错误信息，不应该被打扰，因此需要关中断 put_str(\u0026#34;\\n\\n\\n!!!!! error !!!!!\\n\u0026#34;); put_str(\u0026#34;filename:\u0026#34;); put_str(filename); put_str(\u0026#34;\\n\u0026#34;); put_str(\u0026#34;line:0x\u0026#34;); put_int(line); put_str(\u0026#34;\\n\u0026#34;); put_str(\u0026#34;function:\u0026#34;); put_str((char *)func); put_str(\u0026#34;\\n\u0026#34;); put_str(\u0026#34;condition:\u0026#34;); put_str((char *)condition); put_str(\u0026#34;\\n\u0026#34;); while (1) ; } 代码编译\r1 gcc-4.4 -o $(pwd)/bin/debug.o -c -fno-builtin -m32 -I $(pwd)/lib/kernel/ -I $(pwd)/lib/ -I $(pwd)/kernel/ $(pwd)/kernel/debug.c 编译通过，没有出现任何问题\n实现字符串操作函数\r本节的代码依旧是准备工作，为了将来的开发工作更得心应手，本节打算实现与字符串相关的函数，此类函数以后会被经常用到\n以下是字符串操作函数的相关定义\n/lib/kernel/string.h\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #ifndef __LIB_STRING_H #define __LIB_STRING_H #include \u0026#34;stdint.h\u0026#34; /*内存初始化函数，将dst_起始的size个字节的初始化为value*/ void memset(void *dst_, uint8_t value, uint32_t size); /*内存拷贝函数，将src_起始处的size个字节的内容拷贝到dst_*/ void memcpy(void *dst_, const void *src_, uint32_t size); /* 比较两个地址的起始size字节的数据是否相等 相等则返回0 如果不相等，则比较第一个不相等的字节数据 */ int memcmp(const void *a_, const void *b_, uint32_t size); /*字符串拷贝*/ char *strcpy(char *dst_, const char *src_); /*获取字符串的长度*/ uint32_t strlen(const char *str); /* 比较两个字符串 若a_中的字符与b_中的字符全部相同，则返回0 如果不同，则比较第一个不同的字符 如果a_\u0026gt;b_返回1，反之返回-1 */ int8_t strcmp(const char *str1, const char *str2); /*从左到右查找字符串str中首次出现字符ch的地址*/ char *strchr(const char *string, const uint8_t ch); /*从后往前查找字符串str中首次出现字符ch的地址(不是下标,是地址)*/ char *strrchr(const char *string, const uint8_t ch); /* 将字符串src_拼接到dst_后,将回拼接的串地址 */ char *strcat(char *dst_, const char *src_); /* 在字符串str中查找指定字符ch出现的次数 */ uint32_t strchrs(const char *filename, uint8_t ch); #endif 可以看到，都是我们平时使用c语言时经常用到的函数，我们在这里只是简单重新实现了一下\n/lib/kernel/string.c\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 #include \u0026#34;string.h\u0026#34; #include \u0026#34;global.h\u0026#34; #include \u0026#34;debug.h\u0026#34; /*内存初始化函数，将dst_起始的size个字节的初始化为value*/ void memset(void *dst_, uint8_t value, uint32_t size) { ASSERT(dst_ != NULL); uint8_t *dst = (uint8_t *)dst_; /* 先执行*dst=value 然后执行dst++ */ while (size--) *dst++ = value; } /* 将src_起始处的size个字节的内容拷贝到dst_ */ void memcpy(void *dst_, const void *src_, uint32_t size) { ASSERT(dst_ != NULL \u0026amp;\u0026amp; src_ != NULL); uint8_t *src = (uint8_t *)src_; uint8_t *dst = (uint8_t *)dst_; while (size--) { *dst++ = *src++; } } /* 比较两个地址的起始size字节的数据是否相等 相等则返回0 如果不相等，则比较第一个不相等的字节数据 */ int memcmp(const void *a_, const void *b_, uint32_t size) { ASSERT(a_ != NULL \u0026amp;\u0026amp; b_ != NULL); const char *a = a_; const char *b = b_; while (size--) { if (*a != *b) { return *a \u0026gt; *b ? 1 : -1; } a++; b++; } return 0; } /* 字符串拷贝 */ char *strcpy(char *dst_, const char *src_) { ASSERT(dst_ != NULL \u0026amp;\u0026amp; src_ != NULL); char *res = dst_; while ((*dst_++ = *src_++)) ; return res; } /* 返回字符串的长度 */ uint32_t strlen(const char *str) { ASSERT(str != NULL); const char *p = str; while (*p++); return (p - str - 1); } /* 比较两个字符串 若a_中的字符与b_中的字符全部相同，则返回0 如果不同，则比较第一个不同的字符 如果a_\u0026gt;b_返回1，反之返回-1 */ int8_t strcmp(const char *str1, const char *str2) { ASSERT(str1 != NULL \u0026amp;\u0026amp; str2 != NULL); // 比较两个字符串 while (*str1 != \u0026#39;\\0\u0026#39; \u0026amp;\u0026amp; *str2 != \u0026#39;\\0\u0026#39;) { if (*str1 != *str2) { return (*str1 \u0026lt; *str2) ? -1 : 1; } ++str1; ++str2; } // 如果两个字符串走到末尾还是没有不同，比较它们的结束符 return (*str1 == *str2) ? 0 : (*str1 \u0026lt; *str2 ? -1 : 1); } /* 从左到右查找字符串str中首次出现字符ch的地址 const char *str，表示str指向的字符串内容不可改变 但是str指针值是可以改变的 */ char *strchr(const char *str, const uint8_t ch) { ASSERT(str != NULL); while (*str != 0) { if (*str == ch) return (char *)str; ++str; } return NULL; } /* 从后往前查找字符串str中首次出现字符ch的地址(不是下标,是地址) */ char *strrchr(const char *str, const uint8_t ch) { ASSERT(str != NULL); const char *last_char = NULL; /* 从头到尾遍历一次,若存在ch字符,last_char总是该字符最后一次出现在串中的地址(不是下标,是地址)*/ while (*str != 0) { if (*str == ch) { last_char = str; } str++; } return (char *)last_char; } /* 将字符串src_拼接到dst_后,将回拼接的串地址 */ char *strcat(char *dst_, const char *src_) { ASSERT(dst_ != NULL \u0026amp;\u0026amp; src_ != NULL); char *p = dst_; while (*p++) ; --p; while ((*p++ = *src_++)) ; return dst_; } /* 在字符串str中查找指定字符ch出现的次数 */ uint32_t strchrs(const char *str, uint8_t ch) { ASSERT(str != NULL); uint32_t cnt = 0; const char *p = str; while (*p != 0) { if (*p == ch) cnt++; ++p; } return cnt; } 这部分内容比较简单，具体实现细节不再赘述\n代码编译\n1 gcc-4.4 -o $(pwd)/bin/string.o -c -fno-builtin -m32 -I $(pwd)/lib/kernel/ -I $(pwd)/lib/ -I $(pwd)/kernel/ $(pwd)/lib/string.c 编译通过，没有问题\n位图实现\r位图简介\r在计算机的内存管理系统中，位图（Bitmap）是一种常用的数据结构，用于高效地管理内存的分配和回收。它通过使用一个位数组来表示内存中各个块（或页面）的状态，进而实现对内存资源的管理。每个二进制位代表一个固定大小的内存块（如页、页框或块），0和1的状态分别表示该内存块是“空闲”的或“已分配”的。\n位图的基本概念 在内存管理中，位图通常用于表示一个固定大小的内存块集合，每个内存块用一个二进制位来表示：\n0 表示该内存块是“空闲”的，即该内存块没有被分配。 1 表示该内存块是“已分配”的，即该内存块正在被使用。 例如，如果内存被分成了8个块，并且它们的分配情况如下：\n1 0 0 1 1 0 0 1 那么这个位图表示：\n第1、4、5、8个内存块已分配。 第2、3、6、7个内存块是空闲的。 位图在内存管理中的应用 位图通常用于以下几种内存管理任务：\n2.1 内存分配\n当需要为一个进程分配内存时，内存管理系统可以使用位图来查找一个或多个空闲的内存块。通过遍历位图，找到连续的若干个0位（表示空闲块），然后将这些空闲块标记为已分配（将相应的位设置为1）。\n2.2 内存回收\n当进程释放内存时，内存管理系统可以通过修改位图将相应的位重新设置为0，表示这些内存块已空闲，准备重新分配给其他进程。\n2.3 内存块分配策略\n位图使得内存管理系统能够轻松地选择空闲内存块。常见的策略包括：\n最佳适配：寻找最小的足够大空闲块。 最差适配：选择最大的空闲块。 首次适配：从位图中从头开始找到第一个符合要求的空闲块。 2.4 合并和拆分\n在某些系统中，内存分配和回收过程中可能会导致内存碎片。位图可以帮助检测空闲块的合并，尤其是在连续块被释放后，系统可以将这些空闲块合并成更大的空闲区域。\n位图的实现\r首先还是定义位图相关的数据结构以及操作函数的相关定义\n/lib/kernel/bitmap.h\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #ifndef __LIB_KERNEL_BITMAP_H #define __LIB_KERNEL_BITMAP_H #include \u0026#34;global.h\u0026#34; #define BITMAP_MASK 1 struct bitmap { // 这个数据结构就是用来管理整个位图 uint32_t btmp_bytes_len; // 记录整个位图的大小，单位为字节 uint8_t *bits; // 用来记录位图的起始地址，我们未来用这个地址遍历位图时，操作单位指定为最小的字节 }; /*位图初始化*/ void bitmap_init(struct bitmap *btmp); /*确定位图的bit_idx位是否为1，即判断某块内存是否被分配*/ bool bitmap_scan_test(struct bitmap *btmp, uint32_t bit_idx); /*在位图中寻找连续的cnt个0，以此来分配一块连续未被占用的内存*/ int bitmap_scan(struct bitmap *btmp, uint32_t cnt); /*将位图的某一位设置为1或0*/ void bitmap_set(struct bitmap *btmp, uint32_t bit_idx, int8_t value); #endif 接下来开始正式实现位图的相关操作\n/lib/kernel/bitmap.c\n1.位图的初始化\n1 2 3 4 5 /*位图初始化*/ void bitmap_init(struct bitmap *btmp) { memset(btmp-\u0026gt;bits, 0, btmp-\u0026gt;btmp_bytes_len); } 2.确定位图的bit_idx位是否为1\n1 2 3 4 5 6 7 8 9 10 /*确定位图的bit_idx位是否为1*/ bool bitmap_scan_test(struct bitmap *btmp, uint32_t bit_idx) { //获取bit_idx在位图中第几个字节 uint32_t byte_idx = bit_idx / 8; //获取bit_idx在位图中byte_idx字节处的第几个比特位 uint32_t bit_odd = bit_idx % 8; // 小端字节序，故低位在右侧 return (btmp-\u0026gt;bits[byte_idx] \u0026amp; (BITMAP_MASK \u0026lt;\u0026lt; bit_odd)); } 该函数的实现需要做以下几点说明\n参数bit_idx是字节级别的，在位图中表示一个索引 计算机内部采用小端字节序，因此掩码应该左移 3.在位图中寻找连续的cnt个0，以此来分配一块连续未被占用的内存\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 /* 在位图中寻找连续的cnt个0，以此来分配一块连续未被占用的内存 */ int bitmap_scan(struct bitmap *btmp, uint32_t cnt) { uint32_t idx_type = 0; /*先逐字节比较，找到第一个含有比特0位的字节，0xff=1111 1111*/ while (btmp-\u0026gt;bits[idx_type] == 0xff \u0026amp;\u0026amp; idx_type \u0026lt; btmp-\u0026gt;btmp_bytes_len) ++idx_type; ASSERT(idx_type \u0026lt; btmp-\u0026gt;btmp_bytes_len); if (idx_type == btmp-\u0026gt;btmp_bytes_len) return -1; /*在该字节内找到第一个为0的比特位*/ int idx_bit = 0; while ((uint8_t)(BITMAP_MASK \u0026lt;\u0026lt; idx_bit) \u0026amp; btmp-\u0026gt;bits[idx_type]) ++idx_bit; /*空闲位在位图内的下标*/ int bit_idx_start = idx_type * 8 + idx_bit; if (cnt == 1) return bit_idx_start; // 记录还剩余多少位没有判断 uint32_t bit_left = btmp-\u0026gt;btmp_bytes_len * 8 - bit_idx_start; uint32_t next_bit = bit_idx_start + 1; uint32_t count = 1; /*寻找剩余连续的0*/ bit_idx_start = -1; while (bit_left--) { if (!bitmap_scan_test(btmp, next_bit)) ++count; else count = 0; if (count == cnt) { bit_idx_start = next_bit - cnt + 1; break; } ++next_bit; } return bit_idx_start; } 4.将位图的某一位设置为1或0\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 /* 将位图的某一位设置为1或0 */ void bitmap_set(struct bitmap *btmp, uint32_t bit_idx, int8_t value) { ASSERT((value == 0) || (value == 1)); uint32_t idx_byte = bit_idx / 8; uint32_t idx_odd = bit_idx % 8; /* 一般都会用个0x1这样的数对字节中的位操作, * 将1任意移动后再取反,或者先取反再移位,可用来对位置0操作。*/ if (value) { // 如果value为1 btmp-\u0026gt;bits[idx_byte] |= (BITMAP_MASK \u0026lt;\u0026lt; idx_odd); } else { // 若为0 btmp-\u0026gt;bits[idx_byte] \u0026amp;= ~(BITMAP_MASK \u0026lt;\u0026lt; idx_odd); } } 代码编译\r1 gcc-4.4 -o $(pwd)/bin/bitmap.o -c -fno-builtin -m32 -I $(pwd)/lib/kernel/ -I $(pwd)/lib/ -I $(pwd)/kernel/ $(pwd)/lib/kernel/bitmap.c ","date":"2024-12-18T00:00:00Z","image":"https://raw.githubusercontent.com/jl-sky/imageDatesets/master/2024/12/upgit_20241218_1734521834.png","permalink":"http://localhost:1313/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9C%9F%E8%B1%A1%E8%BF%98%E5%8E%9F%E7%AC%AC%E5%85%AB%E7%AB%A0%E4%B8%80-%E4%BD%8D%E5%9B%BE%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/","title":"《操作系统真象还原》第八章（一） —— 位图及其实现"},{"content":"本章节所有代码托管在miniOS_32\n章节任务介绍\r任务简介\r上一节，我们构建了内核的第一个基本功能——打印字符及字符串\n本节我们将介绍有关中断的知识以及如何打开中断，最终我们将使用代码打开时钟中断进行测试\n本章的主要任务有：\n打开中断机制，并使用时钟中断进行测试 前置知识\r中断分类\r按照事件来源进行划分，中断可分为外部中断和内部中断，来自CPU外部的事件叫外部中断，而来自CPU内部的事件叫内部中断\n其中，外部中断按照是否可宕机划分，又可分为可屏蔽中断（意思是说，该中断事件不是太严重，还不能导致机器宕机，因此CPU可以暂时屏蔽掉不处理）和不可屏蔽中断（该类中断事件非常严重，会导致机器宕机，因此CPU应当立即处理，不可屏蔽）。\n另外，内部中断也可以按照中断是否正常划分为软中断和异常，其中异常又可为故障（Fault）、陷阱（Trap）、终止（Abort）三种\n如下所示\n外部中断 可屏蔽中断 不可屏蔽中断 内部中断 软中断 异常 故障（Fault） 陷阱（Trap） 终止（Abort） 外部中断\r外部中断是指来自CPU外部的中断事件，外部中断的中断源必须是某个硬件，因此外部中断也叫硬件中断，例如来自网卡、打印机、硬盘等事件的中断等\n如图所示，CPU为所有的硬件中断提供了两条信号线，所有来自外设的中断信号都可以通过这两条信号线链接到CPU\nINTR：用于接收来自硬件设备如硬盘、网卡、打印机发出的可屏蔽中断。 这类中断事件不会影响系统运行，因此CPU可以通过eflags寄存器的IF位将这些外设发出的中断屏蔽掉，甚至不处理 中断处理程序对于这类事件的处理可分为两部分进行处理 上半部处理：在关中断情况下进行处理，只完成中断应答或者硬件复位等重要性工作 下半部处理：在开中断的情况下处理，开始真正处理中断发生的事件，由于在开中断情况下处理，因此如果有新的中断发生，则该旧中断的下半部就会被换下CPU，转而去执行新中断的上半部，至于旧中断的下半部何时处理则取决于调度算法 可屏蔽中断的数量有限，每一种中断源都可以有一个中断向量号 NMI：用于接受外部硬件发出的不可屏蔽中断。通过NMI信号线发给CPU的中断信号，都表示系统发生了致命的错误 这类中断事件的发生说明一定会影响系统的运行，如电源掉电、内存读写错误、总线奇偶校验错误等，必须要处理，CPU不可对齐屏蔽，不能坐视不理 所有的不可屏蔽中断只有一个中断向量号，为2号中断，这是因为不可屏蔽中断发生的时候基本任务软件已经无法解决，没必要按照事件再分配多余的中断向量号了 内部中断\r内部中断又可分为软中断和异常\n软中断：由软件主动发出的中断的信号，并不属于客观上的某种错误 以下我们在程序中写的可以发出的软中断指令 int 8位立即数，即系统调用 int3，调试断点指令 into，中断溢出指令 bound，检查数组索引越界指令 异常：异常是指指令执行期间CPU内部产生的错误 上述软中断列举的几个中断指令，除了第一个系统调用指令，其余三个也都可成为异常，因此他们都有一定风险在指令执行期间产生错误。此外，如DIV除法指令的分母为0，将引发0号异常；处理器无法识别某个机器码时也会发起6号异常 异常按照轻重程度也分为三种 Fault，即故障，这类错误是可修复的，如缺页异常 Trap，即陷阱，如int3断点调试指令，当int3发出这类异常并处理结束后可继续返回向下执行 Abort，即终止，这是最严重的异常类型，一旦出现错误将无法修复，程序也将无法继续执行，因此操作系统为了自保，只能将此程序从进程表中去掉 中断描述符表\r中断向量号与门描述符\r上表即是计算机支持的所有中断和异常\n中断机制本质上是来了一个中断信号后，调用相应的中断处理程序进行处理，所以CPU为了统一中断管理，就为每个中断信号分配一个整数，用此整数作为中断的D，这个整数就是所谓的中断向量，然后用此D作为中断描述符表中的索引，然后找到对应的表项，进而即可从中找到对应的中断处理程序。\n其中\n异常和不可屏蔽的中断向量号由CPU自动提供 可屏蔽中断的中断向量号由中断代理（接下来要介绍的8259A）提供 软中断的中断向量号有软件提供 由于一个中断向量号对应一个中断处理程序，所以需要有一张表对这个对应过程进行管理\n在实模式下，用于存储中断处理程序入口的表叫中断向量表(Interrupt Vector Table，IVT)\n我们接下来要介绍的是在保护模式下使用的中断描述符表(Interrupt Descriptor Table,IDT)\n中断描述符表是保护模式下用于存储中断处理程序入口的表，当CPU 接收一个中断时，需要用中断向量在此表中检索对应的描述符，在该描述符中找到中断处理程序的起始地址，然后执行中断处理程序。\nIDT中除了有中断描述符，还有任务门描述、陷阱门描述符、调用门描述符，他们统称为门描述符，IDT中只有门描述符\n所有的描述符都是8个字节，段描述符描述的是一段内存（如内存的基址、大小和属性），而门描述符描述的是一段代码（中断处理程序）\n以下是中断门描述符的格式，我们将来要通过构造它来填充IDT\n以下是其他三种门描述符的格式\n其中，在现代linux系统中，任务门和调用门用的很少，而我们在本节中也主要使用中断门描述符\n中断描述符表寄存器\rGDT需要有一个寄存器（IDTR）用于存储GDT的地址，IDT也需要有一个寄存器来存储IDT的地址，即IDTR，以下是IDTR的结构格式\n其中0 ~ 15位存储IDT的表界限（表大小-1），16 ~ 47位存储IDT表基址\n加载IDT的指令方式是\nlidt 48位内存数据 中断处理过程\r完整的中断过程分为CPU外和CPU内两部分。\nCPU外:外部设备的中断由中断代理芯片接收，处理后将该中断的中断向量号发送到CPU。 CPU 内:CPU执行该中断向量号对应的中断处理程序。 发生在CPU外的中断过程由接下来介绍的中段代理8259A完成\n以下是发生在CPU内部的中断处理过程\n如图所示\n由于IDT中全都是门描述符，所以图中某门描述符”表示中断门、陷阱门或任务门 中断发生后,eflags中的NT位和TF位会被置0 如果中断对应的门描述符是中断门,标志寄存器 eflags中的IF位被自动置0，避免中断嵌套，即中断处理过程中又来了个新的中断，这是为防止在处理某个中断的过程中又来了一个相同的中断。这表示默认情况下，处理器会在无人打扰的方式下执行中断门描述符中的中断处理例程 若中断发生时对应的描述符是任务门或陷阱门的话，CPU是不会将IF位清0的。因为陷阱门主要用于调试，它允许 CPU响应更高级别的中断，所以允许中断嵌套。而对任务门来说，这是执行一个新任务 **从中断返回的指令是iret，它从栈中弹出数据到寄存器cs、eip、eflags**等，根据特权级是否改变，判断是否要恢复旧栈。也就是说是否将栈中位于SS_old和ESP_old 位置的值弹出到寄存ss和 esp。当中断处理程序执行完成返回后，通过iret指令从栈中恢复eflags 的内容 可编程中断控制器8259A\r8259A芯片介绍\r为了让CPU获得每个外部设备的中断信号，最好的方式是在CPU中为每一个外设准备一个引脚接收中断，但这是不可能的，计算机中挂了很多外部设备，而且外设数量是没有上限的，无论CPU 中准备多少引脚都不够用。\n上一节中我们说到，可屏蔽中断是通过INTR信号线进入CPU的，一般可独立运行的外部设备，如打印机、声卡等，其发出的中断都是可屏蔽中断，都共享这一根INTR信号线通知CPU。\n但是，任务是串行在 CPU 上执行的，CPU每次只能执行一个任务，如果同时有多个外设发出中断，而 CPU只能先处理一个，它无法指定先响应哪个。同时，为了不使这些中断丢失，也需要为它们单独维护一个中断队列\n这就是中断代理的作用，由它负责对所有可屏蔽中断仲裁，决定哪个中断优先被 CPU受理，同时向CPU提供中断向量号等功能\n如图所示，有关8259A芯片需要做以下几点说明\nIntel 处理器共支持 256 个中断，但8259A 只可以管理8个中断，所以为了多支持一些中断设备，需要将多个8259A 组合，也就是级联，有了级联这种组合后，每一个 8259A就被称为1片。 若采用级联方式，即多片8259A芯片串连在一起，最多可级联9个,也就是最多支持 64个中断（片8259A通过级联可支持7n+1个中断源）。 级联时只能有一片 8259A为主片 master，其余的均为从片 slave。 来自从片的中断只能传递给主片，再由主片向上传递给 CPU，也就是说只有主片才会向CPU发送INT中断信号。 8259A芯片编程\r在8259A 内部有两组寄存器\n一组是初始化命令寄存器组，用来保存初始化命令字(Imitialization Command Words，ICW)，ICW共4个，ICW1~ICW4。\n另一组寄存器是操作命令寄存器组，用来保存操作命令字(Operation Command Word,OCW)，OCW共3个，OCW1~OCW3。\n所以，我们对8259A的编程，也分为初始化和操作两部分\n初始化部分操作，用来确定是否需要级联，设置起始中断向量号，设置中断结束模式。其编程就是往 8259A 的端口发送一系列 ICW。 由于从一开始就要决定 8259A的工作状态，所以要一次性写入很多设置，某些设置之间是具有关联、依赖性的，也许后面的某个设置会依赖前面某个ICW 写入的设置所以这部分要求严格的顺序，必须依次写入ICW1、ICW2、ICW3、ICW4。 操作部分是用OCW来操作控制8259A，前面所说的中断屏蔽和中断结束，就是通过往8259A端口发送 OCW 实现的。 OCW的发送顺序不固定，3个之中先发送哪个都可以。 编写中断处理程序\r启用中断\r代码目录结构\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 . ├── bin ├── boot\t//计算机启动代码文件 │ ├── include │ │ └── boot.inc │ ├── loader.S │ └── mbr.S ├── kernel │ ├── global.h\t//各种描述符、段选择子等字段的宏定义文件 │ ├── init.c │ ├── init.h │ ├── interrupt.c\t//构造IDT、IDTR、打开时钟中断文件 │ ├── interrupt.h │ ├── kernel.S\t//定义中断处理程序文件 │ └── main.c ├── lib │ ├── kernel │ │ ├── io.h\t//将对8259A的汇编控制代码封装为易用的c代码 │ │ ├── print.h │ │ └── print.S │ └── stdint.h ├── Makefile\t//编译脚本，Makefile形式的编译脚本 ├── start.sh\t//编译脚本，有更清晰的编译命令和编译顺序，方便读者理解 └── test\t//内联汇编测试文件 ├── base_asm.c ├── inlineASM.c ├── mem.c ├── reg.c └── reg_constraint.c 代码核心逻辑\r定义中断处理程序 通过中断处理程序构造中断描述符 把中断描述符填充进IDT构造IDT 在中断代理中暂时只打开时钟中断，也就是说只有时钟中断才能通过中断代理告知CPU，其余的中断信号都被拦截 定义中断处理程序\r/kernel/kernel.S\n中断处理程序通过宏进行循环构造\n汇编中宏语法格式为\n1 2 3 4 ;宏定义的语法格式为： ; %macro 宏名 参数个数 ;参数顺序由占位符表示，如%1表示第一个参数，%2表示第二个参数 ; 宏定义 ; %endmacro 以下是中断处理程序的宏\n这段中断处理程序的代码逻辑很简单，当其被调用时\n首先打印字符串intr_str 然后给8259A芯片发生信号结束中断 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 %macro VECTOR 2 ;定义VECTOR宏，该宏用于定义中断处理程序 ;参数1表示中断向量号，参数2表示错误码 section .text ;中断处理程序的代码段 intr%1entry: ;这是一个标号，用于表示中断程序的入口地址，即中断程序的函数名 %2 ;如果一个中断有错误码，则什么都不做，否则压入0作填充 ;这段代码是为了模拟中断发生，如果我们中断调用后这段字符串打印出来了，说明我们的中断逻辑是正确的 push intr_str ;压入put_str的调用参数 call put_str add esp,4 ;回收put_str函数压入的字符串参数的栈帧空间 ;由于intr_str是一个指针类型，而该系统为32bit，因此该参数占用4个字节空间 ;上述中断发生模拟结束后要结束中断 mov al,0x20 ;中断结束命令EOI out 0xa0,al ;向主片发送OCW2,其中EOI位为1，告知结束中断，详见书p317 out 0x20,al ;向从片发送OCW2,其中EOI位为1，告知结束中断 add esp,4 ;抛弃有错误码的中断（如果有） iret ;中断返回 section .data dd intr%1entry ;存储各个中断入口程序的地址，形成intr_entry_table数组,定义的地址是4字节，32位 %endmacro 这段宏共有两个参数，这两个参数都是占位符\n参数一表示中断号 这个中断号是拿来填充中断处理程序的函数名 比如这段宏调用VECTOR 0x00,ZERO，第一个参数是0x00，于是它代表的中断处理程序的函数名就是intr0x00entry 参数二是一个填充字段。 中断处理程序在被调用前CPU会压入ss、eip、eflags寄存器等值进行保存，但是有点中断处理程序还会额外压入错误码信息，而有的不压入，于是为了保持栈结构的统一，定义了这个参数，这个参数是一个操作 其作用是，如果某个中断处理程序压入了错误码，则该参数代表的操作为空操作，什么也不做 否则就压入4字节的0以作填充 以下是通过调用上述宏构造的33个中断处理程序\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 ; 调用之前写好的VECTOR宏来批量生成中断处理函数， ; 传入参数是中断号码与上面中断宏的%2步骤，这个步骤是什么都不做，还是压入0,详情看p303 VECTOR 0x00,ZERO VECTOR 0x01,ZERO VECTOR 0x02,ZERO VECTOR 0x03,ZERO VECTOR 0x04,ZERO VECTOR 0x05,ZERO VECTOR 0x06,ZERO VECTOR 0x07,ZERO VECTOR 0x08,ERROR_CODE VECTOR 0x09,ZERO VECTOR 0x0a,ERROR_CODE VECTOR 0x0b,ERROR_CODE VECTOR 0x0c,ZERO VECTOR 0x0d,ERROR_CODE VECTOR 0x0e,ERROR_CODE VECTOR 0x0f,ZERO VECTOR 0x10,ZERO VECTOR 0x11,ERROR_CODE VECTOR 0x12,ZERO VECTOR 0x13,ZERO VECTOR 0x14,ZERO VECTOR 0x15,ZERO VECTOR 0x16,ZERO VECTOR 0x17,ZERO VECTOR 0x18,ERROR_CODE VECTOR 0x19,ZERO VECTOR 0x1a,ERROR_CODE VECTOR 0x1b,ERROR_CODE VECTOR 0x1c,ZERO VECTOR 0x1d,ERROR_CODE VECTOR 0x1e,ERROR_CODE VECTOR 0x1f,ZERO VECTOR 0x20,ZERO 之所以定义33个中断处理程序，是因为中断向量0 ~ 19为处理器内部固定的异常类型，20 ~ 31是Imntel保留的，可用的最低中断向量号是32\n构造IDT\r/kernel/interrupt.c\n首先按照中断描述符的格式定义中断描述符的结构体\n1 2 3 4 5 6 7 8 9 // 定义中断描述符结构体 struct gate_desc { uint16_t func_offset_low_word; // 中断处理程序在目标代码段的偏移量（低字） uint16_t selector; // 选择子字段 uint8_t dcount; // 此项为双字计数字段，是门描述符中的第4字节。这个字段无用 uint8_t attribute; // 属性字段（包含P位、DPL位、S位、TYPE位） uint16_t func_offset_high_word; // 中断处理程序在目标代码段的偏移量（高字） }; 我们需要通过中断描述符构造IDT，当然也需要定义IDT，其实就是个gate_desc（中断描述符j结构体定义）类型的数组\n1 2 // 定义中断门描述符结构体数组，形成中断描述符表idt，该数组中的元素是中断描述符 static struct gate_desc idt[IDT_DESC_CNT]; 接下来首先按照中断描述符的格式填充中断描述符\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 /* 函数功能：构建中断描述符 函数实现：按照中断描述符结构体定义填充字段 参数： 中断门描述符地址 属性 中断处理函数 */ static void make_idt_desc(struct gate_desc *p_gdesc, uint8_t attr, intr_handler function) { p_gdesc-\u0026gt;func_offset_low_word = (uint32_t)function \u0026amp; 0x0000FFFF; p_gdesc-\u0026gt;selector = SELECTOR_K_CODE; p_gdesc-\u0026gt;dcount = 0; p_gdesc-\u0026gt;attribute = attr; p_gdesc-\u0026gt;func_offset_high_word = ((uint32_t)function \u0026amp; 0xFFFF0000) \u0026gt;\u0026gt; 16; } 然后调用上述函数，将中断描述符循环填充进IDT以构造IDT\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 /* 函数功能：构建中断描述符表idt 函数实现：循环调用make_idt_desc构建中断描述符，形成中断描述符表idt 参数：中断描述符表中的某个中断描述符地址，属性字段，中断处理函数地址 */ static void idt_desc_init(void) { int i; for (i = 0; i \u0026lt; IDT_DESC_CNT; i++) { make_idt_desc(\u0026amp;idt[i], IDT_DESC_ATTR_DPL0, intr_entry_table[i]); } put_str(\u0026#34; idt_desc_init done\\n\u0026#34;); } 其中intr_entry_table保存的就是kernel.S定义的33个中断处理程序的入口地址（函数地址）\n打开时钟中断\r最后一步的工作就是初始化8259A芯片，同时打开时钟中断，只让时钟中断的信号经过中断代理告知CPU\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 /*初始化可编程中断控制器8259A*/ static void pic_init() { /* 初始化主片 */ outb(PIC_M_CTRL, 0x11); // ICW1: 边沿触发,级联8259, 需要ICW4. outb(PIC_M_DATA, 0x20); // ICW2: 起始中断向量号为0x20,也就是IR[0-7] 为 0x20 ~ 0x27. outb(PIC_M_DATA, 0x04); // ICW3: IR2接从片. outb(PIC_M_DATA, 0x01); // ICW4: 8086模式, 正常EOI /* 初始化从片 */ outb(PIC_S_CTRL, 0x11); // ICW1: 边沿触发,级联8259, 需要ICW4. outb(PIC_S_DATA, 0x28); // ICW2: 起始中断向量号为0x28,也就是IR[8-15] 为 0x28 ~ 0x2F. outb(PIC_S_DATA, 0x02); // ICW3: 设置从片连接到主片的IR2引脚 outb(PIC_S_DATA, 0x01); // ICW4: 8086模式, 正常EOI /* 打开主片上IR0,也就是目前只接受时钟产生的中断 */ outb(PIC_M_DATA, 0xfe); outb(PIC_S_DATA, 0xff); put_str(\u0026#34;pic_init done\\n\u0026#34;); } 其中有关对8259A的操作和控制函数定义在\n/lib/kernel/io.h\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #ifndef __LIB_IO_H #define __LIB_IO_H #include \u0026#34;stdint.h\u0026#34; // 一次送一字节的数据到指定端口，static指定只在本.h内有效，inline是让处理器将函数编译成内嵌的方式，就是在该函数调用处原封不动地展开 // 此函数有两个参数，一个端口号，一个要送往端口的数据 static inline void outb(uint16_t port, uint8_t data) { /********************************************************* a表示用寄存器al或ax或eax,对端口指定N表示0~255, d表示用dx存储端口号, %b0表示对应al,%w1表示对应dx */ asm volatile(\u0026#34;outb %b0, %w1\u0026#34; : : \u0026#34;a\u0026#34;(data), \u0026#34;Nd\u0026#34;(port)); } // 利用outsw（端口输出串，一次一字）指令，将ds:esi指向的addr处起始的word_cnt(存在ecx中)个字写入端口port,ecx与esi会自动变化 static inline void outsw(uint16_t port, const void *addr, uint32_t word_cnt) { /********************************************************* +表示此限制即做输入又做输出. outsw是把ds:esi处的16位的内容写入port端口, 我们在设置段描述符时, 已经将ds,es,ss段的选择子都设置为相同的值了,此时不用担心数据错乱。*/ asm volatile(\u0026#34;cld; rep outsw\u0026#34; : \u0026#34;+S\u0026#34;(addr), \u0026#34;+c\u0026#34;(word_cnt) : \u0026#34;d\u0026#34;(port)); } // S表示寄存器esi/si /* 将从端口port读入的一个字节返回 */ static inline uint8_t inb(uint16_t port) { uint8_t data; asm volatile(\u0026#34;inb %w1, %b0\u0026#34; : \u0026#34;=a\u0026#34;(data) : \u0026#34;Nd\u0026#34;(port)); return data; } /* 将从端口port读入的word_cnt个字写入addr */ static inline void insw(uint16_t port, void *addr, uint32_t word_cnt) { /****************************************************** insw是将从端口port处读入的16位内容写入es:edi指向的内存, 我们在设置段描述符时, 已经将ds,es,ss段的选择子都设置为相同的值了, 此时不用担心数据错乱。*/ asm volatile(\u0026#34;cld; rep insw\u0026#34; : \u0026#34;+D\u0026#34;(addr), \u0026#34;+c\u0026#34;(word_cnt) : \u0026#34;d\u0026#34;(port) : \u0026#34;memory\u0026#34;); } // D表示寄存器edi/di //通知编译器，内存已经被改变了 #endif 填充IDTR，加载IDT\r调用上述函数，完成所有的初始化工作后，按照IDTR的格式构造IDTR，以加载IDT\n1 2 3 4 5 6 7 8 9 10 11 12 13 /*完成有关中断的所有初始化工作*/ void idt_init() { put_str(\u0026#34;idt_init start\\n\u0026#34;); idt_desc_init(); // 构建中段描述符表 pic_init(); // 初始化中断控制器，只接受来自时钟中断的信号 /* 加载idt */ uint64_t idt_operand = (((uint64_t)(uint32_t)idt \u0026lt;\u0026lt; 16) | (sizeof(idt) - 1)); // 定义要加载到IDTR寄存器中的值 asm volatile(\u0026#34;lidt %0\u0026#34; : : \u0026#34;m\u0026#34;(idt_operand)); put_str(\u0026#34;idt_init done\\n\u0026#34;); } 中断测试\r/kernel/main.c\n1 2 3 4 5 6 7 8 9 #include \u0026#34;print.h\u0026#34; #include \u0026#34;init.h\u0026#34; void main(void) { put_str(\u0026#34;I am kernel\\n\u0026#34;); init_all();\t// 初始化中断，同时只放行时钟中断 asm volatile(\u0026#34;sti\u0026#34;); // 为演示中断处理,在此临时开中断，sti是开中断指令 while (1); } 完整源码可参见miniOS_32\n编译运行\r编译脚本\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 mkdir -p bin #编译mbr nasm -o $(pwd)/bin/mbr -I $(pwd)/boot/include/ $(pwd)/boot/mbr.S dd if=$(pwd)/bin/mbr of=~/bochs/hd60M.img bs=512 count=1 conv=notrunc #编译loader nasm -o $(pwd)/bin/loader -I $(pwd)/boot/include/ $(pwd)/boot/loader.S dd if=$(pwd)/bin/loader of=~/bochs/hd60M.img bs=512 count=4 seek=2 conv=notrunc #编译print函数 nasm -f elf32 -o $(pwd)/bin/print.o $(pwd)/lib/kernel/print.S # 编译kernel nasm -f elf32 -o $(pwd)/bin/kernel.o $(pwd)/kernel/kernel.S #编译main函数 gcc-4.4 -o $(pwd)/bin/main.o -c -fno-builtin -m32 -I $(pwd)/lib/kernel/ -I $(pwd)/lib/ -I $(pwd)/kernel/ $(pwd)/kernel/main.c #编译interrupt gcc-4.4 -o $(pwd)/bin/interrupt.o -c -fno-builtin -m32 -I $(pwd)/lib/kernel/ -I $(pwd)/lib/ -I $(pwd)/kernel/ $(pwd)/kernel/interrupt.c #编译init gcc-4.4 -o $(pwd)/bin/init.o -c -fno-builtin -m32 -I $(pwd)/lib/kernel/ -I $(pwd)/lib/ -I $(pwd)/kernel/ $(pwd)/kernel/init.c #将main函数与print函数进行链接 ld -m elf_i386 -Ttext 0xc0001500 -e main -o $(pwd)/bin/kernel.bin $(pwd)/bin/main.o $(pwd)/bin/print.o $(pwd)/bin/init.o $(pwd)/bin/interrupt.o $(pwd)/bin/kernel.o #将内核文件写入磁盘，loader程序会将其加载到内存运行 dd if=$(pwd)/bin/kernel.bin of=~/bochs/hd60M.img bs=512 count=200 conv=notrunc seek=9 #rm -rf bin/* 运行结果如下\n在bochs中调试IDT结果如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 \u0026lt;bochs:2\u0026gt; info idt Interrupt Descriptor Table (base=0xc0002c40, limit=263): IDT[0x00]=32-Bit Interrupt Gate target=0x0008:0xc0001810, DPL=0 IDT[0x01]=32-Bit Interrupt Gate target=0x0008:0xc0001829, DPL=0 IDT[0x02]=32-Bit Interrupt Gate target=0x0008:0xc0001842, DPL=0 IDT[0x03]=32-Bit Interrupt Gate target=0x0008:0xc000185b, DPL=0 IDT[0x04]=32-Bit Interrupt Gate target=0x0008:0xc0001874, DPL=0 IDT[0x05]=32-Bit Interrupt Gate target=0x0008:0xc000188d, DPL=0 IDT[0x06]=32-Bit Interrupt Gate target=0x0008:0xc00018a6, DPL=0 IDT[0x07]=32-Bit Interrupt Gate target=0x0008:0xc00018bf, DPL=0 IDT[0x08]=32-Bit Interrupt Gate target=0x0008:0xc00018d8, DPL=0 IDT[0x09]=32-Bit Interrupt Gate target=0x0008:0xc00018f0, DPL=0 IDT[0x0a]=32-Bit Interrupt Gate target=0x0008:0xc0001909, DPL=0 IDT[0x0b]=32-Bit Interrupt Gate target=0x0008:0xc0001921, DPL=0 IDT[0x0c]=32-Bit Interrupt Gate target=0x0008:0xc0001939, DPL=0 IDT[0x0d]=32-Bit Interrupt Gate target=0x0008:0xc0001952, DPL=0 IDT[0x0e]=32-Bit Interrupt Gate target=0x0008:0xc000196a, DPL=0 IDT[0x0f]=32-Bit Interrupt Gate target=0x0008:0xc0001982, DPL=0 IDT[0x10]=32-Bit Interrupt Gate target=0x0008:0xc000199b, DPL=0 IDT[0x11]=32-Bit Interrupt Gate target=0x0008:0xc00019b4, DPL=0 IDT[0x12]=32-Bit Interrupt Gate target=0x0008:0xc00019cc, DPL=0 IDT[0x13]=32-Bit Interrupt Gate target=0x0008:0xc00019e5, DPL=0 IDT[0x14]=32-Bit Interrupt Gate target=0x0008:0xc00019fe, DPL=0 IDT[0x15]=32-Bit Interrupt Gate target=0x0008:0xc0001a17, DPL=0 IDT[0x16]=32-Bit Interrupt Gate target=0x0008:0xc0001a30, DPL=0 IDT[0x17]=32-Bit Interrupt Gate target=0x0008:0xc0001a49, DPL=0 IDT[0x18]=32-Bit Interrupt Gate target=0x0008:0xc0001a62, DPL=0 IDT[0x19]=32-Bit Interrupt Gate target=0x0008:0xc0001a7a, DPL=0 IDT[0x1a]=32-Bit Interrupt Gate target=0x0008:0xc0001a93, DPL=0 IDT[0x1b]=32-Bit Interrupt Gate target=0x0008:0xc0001aab, DPL=0 IDT[0x1c]=32-Bit Interrupt Gate target=0x0008:0xc0001ac3, DPL=0 IDT[0x1d]=32-Bit Interrupt Gate target=0x0008:0xc0001adc, DPL=0 IDT[0x1e]=32-Bit Interrupt Gate target=0x0008:0xc0001af4, DPL=0 IDT[0x1f]=32-Bit Interrupt Gate target=0x0008:0xc0001b0c, DPL=0 IDT[0x20]=32-Bit Interrupt Gate target=0x0008:0xc0001b25, DPL=0 改进中断\r代码目录结构\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 . ├── bin ├── boot\t//计算机启动代码文件 │ ├── include │ │ └── boot.inc │ ├── loader.S │ └── mbr.S ├── kernel │ ├── global.h\t//各种描述符、段选择子等字段的宏定义文件 │ ├── init.c │ ├── init.h │ ├── interrupt.c\t//构造IDT、IDTR、打开时钟中断文件 │ ├── interrupt.h │ ├── kernel.S\t//定义中断处理程序文件 │ └── main.c ├── lib │ ├── kernel │ │ ├── io.h\t//将对8259A的汇编控制代码封装为易用的c代码 │ │ ├── print.h │ │ └── print.S │ └── stdint.h ├── Makefile\t//编译脚本，Makefile形式的编译脚本 ├── start.sh\t//编译脚本，有更清晰的编译命令和编译顺序，方便读者理解 改进代码\r上述我们代码中，我们通过宏定义了33个中断处理程序，但是由一个问题，那就是我们的中断处理程序的具体实现是通过汇编写的，这很不利、于我们将来使用c语言自定义中断处理程序的具体实现，针对这个问题，我们主要做以下几点改进\n修改/kernel/kernel.S对中断处理程序的定义逻辑\n让中断在进入中断处理程序之后，具体的处理实现通过调用c函数来完成，而不是全部耦合进汇编代码里\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 extern idt_table section .data ;定义数据段 global intr_entry_table ;定义中断处理程序数据，数组的元素值是中断处理程序，共33个 intr_entry_table: ;宏定义的语法格式为： ; %macro 宏名 参数个数 ; 宏定义 ; %endmacro %macro VECTOR 2 ;定义VECTOR宏，该宏用于定义中断处理程序 section .text ;中断处理程序的代码段 intr%1entry: ;这是一个标号，用于表示中断程序的入口地址，即中断程序的函数名 %2 ;压入中断错误码（如果有） push ds ; 以下是保存上下文环境 push es push fs push gs pushad ; 如果是从片上进入的中断,除了往从片上发送EOI外,还要往主片上发送EOI mov al,0x20 ; 中断结束命令EOI out 0xa0,al ;向主片发送OCW2,其中EOI位为1，告知结束中断，详见书p317 out 0x20,al ;向从片发送OCW2,其中EOI位为1，告知结束中断 push %1\t; 不管idt_table中的目标程序是否需要参数,都一律压入中断向量号,调试时很方便 call [idt_table + %1*4] ; 调用idt_table中的C版本中断处理函数 jmp intr_exit section .data dd intr%1entry ;存储各个中断入口程序的地址，形成intr_entry_table数组,定义的地址是4字节，32位 %endmacro section .text global intr_exit intr_exit: ; 以下是恢复上下文环境 add esp, 4\t; 跳过中断号 popad pop gs pop fs pop es pop ds add esp, 4\t;对于会压入错误码的中断会抛弃错误码（这个错误码是执行中断处理函数之前CPU自动压入的），对于不会压入错误码的中断，就会抛弃上面push的0 iretd\t; 从中断返回,32位下iret等同指令iretd 在上述修正后的代码里，当所有初始化工作完成，开始执行中断处理的时候，我们通过调用c函数完成，这样就把具体的中断处理逻辑解放了出来，而不是全部耦合进一段代码里\n可以看到，具体的调用其实是按照中断号（宏定义的第一个参数%1）调用IDT的对应表项，这个表项里对应的是具体中断实现函数\n1 call [idt_table + %1*4] ; 调用idt_table中的C版本中断处理函数 具体的调用实现在/kernel/interrupt.c文件中\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 #if 1 /*用c语言定义中断处理函数的具体实现，不再用汇编语言在kernel.S中定义中断处理函数的实现*/ // 参数：中断向量号 static void general_intr_handler(uint8_t vec_nr) { // 伪中断向量，无需处理 if (vec_nr == 0x27 || vec_nr == 0x2f) { return; } put_str(\u0026#34;int vector:0x\u0026#34;); put_int(vec_nr); put_char(\u0026#39;\\n\u0026#39;); } #endif /* 完成一般中断处理函数注册及异常名称注册 */ static void exception_init(void) { // 完成一般中断处理函数注册及异常名称注册 int i; for (i = 0; i \u0026lt; IDT_DESC_CNT; i++) { /* idt_table数组中的函数是在进入中断后根据中断向量号调用的, 见kernel/kernel.S的call [idt_table + %1*4] */ idt_table[i] = general_intr_handler; // 默认为general_intr_handler // 以后会由register_handler来注册具体处理函数。 intr_name[i] = \u0026#34;unknown\u0026#34;; // 先统一赋值为unknown } intr_name[0] = \u0026#34;#DE Divide Error\u0026#34;; intr_name[1] = \u0026#34;#DB Debug Exception\u0026#34;; intr_name[2] = \u0026#34;NMI Interrupt\u0026#34;; intr_name[3] = \u0026#34;#BP Breakpoint Exception\u0026#34;; intr_name[4] = \u0026#34;#OF Overflow Exception\u0026#34;; intr_name[5] = \u0026#34;#BR BOUND Range Exceeded Exception\u0026#34;; intr_name[6] = \u0026#34;#UD Invalid Opcode Exception\u0026#34;; intr_name[7] = \u0026#34;#NM Device Not Available Exception\u0026#34;; intr_name[8] = \u0026#34;#DF Double Fault Exception\u0026#34;; intr_name[9] = \u0026#34;Coprocessor Segment Overrun\u0026#34;; intr_name[10] = \u0026#34;#TS Invalid TSS Exception\u0026#34;; intr_name[11] = \u0026#34;#NP Segment Not Present\u0026#34;; intr_name[12] = \u0026#34;#SS Stack Fault Exception\u0026#34;; intr_name[13] = \u0026#34;#GP General Protection Exception\u0026#34;; intr_name[14] = \u0026#34;#PF Page-Fault Exception\u0026#34;; // intr_name[15] 第15项是intel保留项，未使用 intr_name[16] = \u0026#34;#MF x87 FPU Floating-Point Error\u0026#34;; intr_name[17] = \u0026#34;#AC Alignment Check Exception\u0026#34;; intr_name[18] = \u0026#34;#MC Machine-Check Exception\u0026#34;; intr_name[19] = \u0026#34;#XF SIMD Floating-Point Exception\u0026#34;; } 上述代码的逻辑是\n我们把具体的中断处理实现通过general_intr_handler完成，然后把general_intr_handler放在IDT中，这样便可通过中断号调用对应的中断处理程序了\n编译运行\r","date":"2024-12-17T00:00:00Z","image":"https://raw.githubusercontent.com/jl-sky/imageDatesets/master/2024/12/upgit_20241218_1734522164.png","permalink":"http://localhost:1313/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9C%9F%E8%B1%A1%E8%BF%98%E5%8E%9F%E7%AC%AC%E4%B8%83%E7%AB%A0-%E6%89%93%E5%BC%80%E4%B8%AD%E6%96%AD%E6%9C%BA%E5%88%B6/","title":"《操作系统真象还原》第七章 —— 打开中断机制"},{"content":"本章节所有代码托管在miniOS_32\n章节任务介绍\r任务简介\r上一节，我们介绍了程序的基本结构以及程序是如何加载到内存的，同时成功的加载了内核到内存\n本节我们将正式书写内核代码\n本章的主要任务有：\n实现内核的单个字符打印 实现内核字符串打印功能 前置知识\r汇编层间的函数调用\r函数调用涉及两个问题\n参数传递的方式 参数传递的顺序 先回答第一个问题，参数传递的方式\n首先，我们需要知道，现代编译器在处理函数调用进行参数传递有两种方式\n寄存器传递 栈空间传递 以下是当前的64位操作系统的寄存器概览\n如果参数的个数小于7个，则采用寄存器传递，因为寄存器传递参数速度较快。这7个寄存器分别是 rdi，传递第一个参数 rsi，传递第二个参数 rdx，传递第三个参数 rcx，传递第四个参数 r8，传递第五个参数 r9，传递第六个参数 当参数个数大于等于7个，多余的参数则使用栈空间传递 当然，我们目前要做的是32位操作系统（如果想了解更多有关现代编译器过程调用细节可参看《深入理解计算机系统》），其调用约定还相对没那么多，当参数个数小于等于5个的时候使用寄存器传递，当参数个数大于5的时候使用栈空间传递，以下是我们目前使用的参数传递寄存器约定\nebx存储第一个参数 ecx存储第二个参数 edx存储第三个参数 esi存储第四个参数 edi存储第五个参数 接下来，我们回答第二个问题，参数传递的顺序\n调用者按照逆序存储参数 被调用者顺序取出参数 我们以一段代码说明\n1 2 int subtract(int a,int b); //被调用者 int sub=subtract(3,2); //调用者 以下是调用者的汇编代码，这里为了说明问题用的是栈空间传递参数\n1 2 3 4 5 ;调用者 push 2 ;压入参数b push 3 ;压入参数a call subtract ;调用subtract函数 add esp,8 ;回收栈空间 以下是被调用者的汇编代码\n1 2 3 4 5 6 7 8 9 10 ;被调用者，也就是subtract subtract: push ebp mov ebp,esp mov eax,[ebp+8] ;取出第一个参数a add eax,[ebp+0xc] ;取出第二个参数b pop ebp ret 需要知道，call指令在调用函数时做了两件事\n将call指令的下一条指令的地址压入栈中，作为函数的返回地址 修改eip寄存器（指令寄存器，用于取出指令送给cpu执行）的值为subtract符号的地址 相对的，ret指令也做了两件事\n弹出调用者压在栈中的返回地址 修改eip寄存器的值为弹出的返回地址 因此，其调用过程如下所示\n由此可以看到，计算机正是通过call和ret这两条指令完成函数的调用和恢复的，但需要知道的是，从本质上说，这两天指令仅仅只是修改eip寄存器用的，并不能保证恢复环境的时候正确，因此有了以下框架\n1 2 3 4 5 6 7 push ebp mov ebp,esp ;函数体 pop ebp ret 这个框架是每个函数都要做的，事实上，在高级语言中\n函数的左括号对应的就是前两条指令 函数的右括号对应的是最后两个指令 c语言与汇编语言的混合调用\r如果想了解更多有关函数调用的细节可参考《深入理解计算机系统》第三章的内容，这里也推荐一个网站，供大家学习使用\nCompiler Explorer\n有了上述知识，我们知道高级语言的底层其实就是汇编语言，因此本质上两者是想通的，接下来我们实战以作说明\n1 2 3 4 5 #include\u0026lt;unistd.h\u0026gt; int main(){ write(1,\u0026#34;hello world\\n\u0026#34;,13); return 0; } 以上是一段简单的使用c语言调用系统函数write，接下来我们看如果使用汇编语言怎么写\nsyscall_write.S\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 section .data sys_call db \u0026#39;Hello from syscall write!\u0026#39;, 0xa ; 0xa 为换行符 sys_call_len equ $ - sys_call str_c db \u0026#39;Hello from simu write!\u0026#39;,0xa str_c_len equ $ - str_c section .text global _start _start: ;------- 模拟c语言的系统调用write -------- push str_c_len push str_c push 1 call simu_write add esp,12 ;------ 调用 sys_write --------- mov eax, 4 ; sys_write 系统调用号 mov ebx, 1 ; 文件描述符 1（标准输出） mov ecx, sys_call ; 消息的地址 mov edx, sys_call_len ; 消息的长度 int 0x80 ; 执行系统调用 ; 程序结束 mov eax, 1 ; sys_exit 系统调用号 xor ebx, ebx ; 退出码 0 int 0x80 ; 执行系统调用 simu_write: push ebp mov ebp,esp mov eax,4 mov ebx,[ebp+8] mov ecx,[ebp+12] mov edx,[ebp+16] int 0x80 pop ebp ret 注意，所有的系统调用最底层的入口只有一个，那就是0x80号中断，针对不同的功能有不同的功能号，如4号功能代表write调用，1号功能代表退出，这些功能号像是参数，由操作系统通过eax传递\n编译链接上述代码，即可验证结果\n1 2 nasm -f elf32 syscall_write.S -o syscall_write.o ld -m elf_i386 syscall_write.o -o syscall_write.bin 接下来我们看c语言和汇编语言是如果相互调用的\nC_with_S_c.c\n1 2 3 4 5 6 extern void asm_print(char*,int); void c_print(char* str){ int len=0; while(str[len++]); asm_print(str,len); } 这段代码想必大家都能看懂，c_print函数通过将传入的参数str传递给asm_print函数进行打印，只不过接下来我们将通过汇编实现asm_print函数，同时我们在汇编代码中传递字符串参数给c_print\n所以本质上二者的调用关系应该是\n汇编代码首先传递字符串参数给c_print 然后c_print将参数再回传给汇编代码中的asm_print函数 asm_print函数最终负责将字符串打印出来 C_with_S_S.S\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 section .data str: db \u0026#34;asm print says:hello wolrd!\u0026#34;,0xa,0 str_len equ $ - str section .text extern c_print global _start _start: push str call c_print add esp,4 mov eax,1 int 0x80 global asm_print asm_print: push ebp mov ebp,esp mov eax,4 mov ebx,1 mov ecx,[ebp+8] mov edx,[ebp+12] int 0x80 pop ebp ret 编译\n1 2 nasm -f elf32 ./C_with_S_S.S -o C_with_S_S.o gcc-4.4 -m32 -c ./C_with_S_c.c -o C_with_S_c.o 链接\n1 ld -m elf_i386 ./C_with_S_c.o C_with_S_S.o -o main 运行\n1 2 minios@robot:~/osCode/miniOS_32/ch6/task1/test/asm_with_c$ ./main asm print says:hello wolrd! 内核初步完善\r代码目录结构\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 . ├── bin\t//所有二进制文件目录 │ ├── kernel.bin │ ├── loader │ ├── main.o │ ├── mbr │ └── print.o ├── boot\t//计算机启动目录 │ ├── include\t//定义mbr和loader进行初始化工作需要的宏 │ │ └── boot.inc │ ├── loader.S │ └── mbr.S ├── kernel\t//内核源文件 │ └── main.c ├── lib\t//库文件 │ ├── kernel\t//内核库文件 │ │ ├── print.h │ │ └── print.S │ └── stdint.h ├── Makefile ├── start.sh\t//编译链接脚本 └── test\t//章节知识学习测试代码 ├── asm_print │ ├── start.sh │ └── syscall_write.S ├── asm_with_c │ ├── C_with_S_c.c │ ├── C_with_S_S.S │ └── start.sh └── main.c 实现单字符打印\r接下来我们将实现内核的第一个功能——单个字符打印，本节字符打印的源代码依旧采用汇编形式\n数据类型定义\r/lib/std_int.h\n1 2 3 4 5 6 7 8 9 10 11 #ifndef __LIB_STDINT_H #define __LIB_STDINT_H typedef signed char int8_t; typedef signed short int int16_t; typedef signed int int32_t; typedef signed long long int int64_t; typedef unsigned char uint8_t; typedef unsigned short int uint16_t; typedef unsigned int uint32_t; typedef unsigned long long int uint64_t; #endif 字符打印头文件定义\r/lib/kernel/print.h\n1 2 3 4 5 #ifndef __LIB_KERNEL_PRINT_H #define __LIB_KERNEL_PRINT_H #include \u0026#34;stdint.h\u0026#34; //stdint.h中定义了数据类型 void put_char(uint8_t char_asci); // 在stdint.h中uint8_t的定义是unsigned char #endif 字符打印源文件实现\r/lib/kernel/print.S\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 TI_GDT equ 0 RPL0 equ 0 SELECTOR_VIDEO equ (0x0003\u0026lt;\u0026lt;3)+TI_GDT+RPL0;定义显存段选择子 [bits 32] section .text global put_char ;通过global关键字将put_char函数定义为全局符号 ;使其对外部文件可见 ;================= put_char函数实现 ================= put_char: pushad ;push all double,压入所有双字长的寄存器 ;入栈顺序为eax-\u0026gt;ecx-\u0026gt;edx-\u0026gt;ebx-\u0026gt;esp-\u0026gt;ebp-\u0026gt;esi-\u0026gt;edi mov ax,SELECTOR_VIDEO mov gs,ax ;为gs寄存器赋予显存段的选择子 ;---------------- 获取光标的坐标位置 ---------------- ; 以下代码用于获取光标的坐标位置(一维索引，如第一行的坐标范围为0~79,第二行为80~159) ; 其中光标的坐标位置存放在光标坐标寄存器中 ; 其中索引为0eh的寄存器和索引为0fh的寄存器分别存放光标高8位和低8位 ; 访问CRT controller寄存器组的寄存器，需要先往端口地址为0x03d4的寄存器写入索引 ; 从端口地址为0x03d5的数据寄存器中读写数据 mov dx,0x03d4 ;将0x03d4的端口写入dx寄存器中 mov al,0x0e ;将需要的索引值写入al寄存器中 out dx,al ;向0x03d4端口写入0x0e索引 mov dx,0x03d5 in al,dx ;从0x03d5端口处获取光标高8位 mov ah,al ;ax寄存器用于存放光标坐标， ;因此将光标坐标的高8位数据存放到ah中 ;同上，以下代码获取光标坐标的低8位 mov dx,0x03d4 mov al,0x0f out dx,al mov dx,0x03d5 in al,dx ;此时ax中就存放着读取到的光标坐标值 mov bx,ax ;bx寄存器不仅是光标坐标值，同时也是下一个可打印字符的位置 ;而我们习惯于bx作为基址寄存器，以后的处理都要基于bx寄存器 ;因此才将获取到的光标坐标值赋值为bx ;---------------- 参数（待打印的字符）传递 ---------------- mov ecx,[esp+36] ;前边已经压入了8个双字（一个字2个字节）的寄存器， ;加上put_char函数的4字节返回地址 ;所以待打印的字符在栈顶偏移36字节的位置 cmp cl,0xd ;回车符处理 jz .is_carriage_return cmp cl,0xa ;换行符处理 jz .is_line_feed cmp cl,0x8 ;退格键处理 jz .is_backspace jmp .put_other ;正常字符处理 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;---------------- 退格键处理 ---------------- ;处理思路： ;1.将光标位置减一 ;2.将待删除的字符使用空格字符(ASCII:0x20)代替 .is_backspace: dec bx ;bx中存储光标的坐标位置，将光标坐标位置减去一，即模拟退格 shl bx,1 ;由于文本模式下一个字符占用两个字节(第一个字节表示字符的ASCII码，第二个字节表示字符的属性)， ;故光标位置乘以2(shl左移指令)就是光标处字符的第一个字节的偏移量 mov byte[gs:bx],0x20 ;将空格键存入待删除字符处 inc bx ;此时bx中存储的是字待删除字符的第一个字节位置， ;使用inc指令将bx加1后就是该字符的第二个字节的位置 mov byte[gs:bx],0x07 ;将黑底白字(0x07)属性加入到该字符处 shr bx,1 ;bx除以2，恢复光标坐标位置 jmp .set_cursor ;去设置光标位置, 这样光标位置才能真正在视觉上更新 ;将cx指向的字符放入到光标处 .put_other: shl bx,1 ;将光标坐标转换为内存偏移量 mov byte[gs:bx],cl ;将cx指向的字符放入到光标处 inc bx ;bx指向当前字符的下一个字节处，存放当前字符属性 mov byte[gs:bx],0x07 ;存放字符属性 shr bx,1 ;将内存偏移量恢复为光标坐标值 inc bx ;bx指向下一个待写入字符位置 cmp bx,2000 ;80*25=2000，判断是否字符已经写满屏了 jl .set_cursor ;更新光标坐标值 ;---------------- 换行处理 ---------------- ;思路：首先将光标移动到本行行首，之后再将光标移动到下一行行首 .is_line_feed: .is_carriage_return: xor dx,dx ;将光标移动到本行行首 mov ax,bx ;将光标值给ax，以作除法之用 mov si,80 div si ;除法操作，ax/si,结果ax存储商，dx存储余数 ;每行80个字符，光标值除以80得出的余数便是当前光标所在行的字符个数 sub bx,dx ;光标值减去光标当前行的字符个数，就将光标移动到本行行首的位置 .is_carriage_return_end: add bx,80 ;将光标移动到下一行行首 cmp bx,2000 ;屏幕的每屏的可显示80*25=2000个字符（25行，每行80个字符） ;这行代码和接下来jl .set_cursor这段代码的作用是 ;判断当前光标值是否小于2000 ;如果小于2000说明当前光标仍旧在本屏内，则代码直接跳转到.set_cursor更新光标值即可 ;否则说明需要滚动屏幕了，继续向下执行滚屏部分的代码.roll_screen .is_line_feed_end: jl .set_cursor ;---------------- 滚屏处理 ---------------- ;思路:屏幕行范围是0~24,滚屏的原理是将屏幕的1~24行搬运到0~23行,再将第24行用空格填充 ; mosd指令会按照指定的次数复制每次 4 字节 ; 源地址：由 SI（源数据位置寄存器）指向。 ; 目标地址：由 DI（目标位置寄存器）指向。 ; 计数器：由 CX（在 16 位模式下）或 ECX（在 32 位模式下）寄存器控制，表示要复制的数据块的元素个数（每个元素是 4 字节）。 ; 每执行一次 movsd，SI 和 DI 会分别递增 4（因为是复制 32 位数据），ECX 会减 1，直到 ECX 变为 0。 .roll_screen: cld ;清除eflags寄存器的方向标志位DF，使得内存移动地址从低地址向高地址移动 ;若方向标志位被设置，则字符串的内存移动地址从高地址向低地址移动 mov ecx,960 ;共移动2000-80=1920个字符，每个字符占2个字节，故共需移动1920*2=3840个字节 ;movsd指令每次移动4个字节，故共需执行该指令3840/4=960次数 mov esi,0xb80a0 ;第1行行首地址，要复制的起始地址 mov edi,0xb8000 ;第0行行首地址，要复制的目的地址 rep movsd ;rep(repeat)指令，重复执行movsd指令，执行的次数在ecx寄存器中 ;将最后一行填充为空白 mov ebx,3840 ;更新光标位置为最后一行首字符第一个字节的位置 mov ecx,80 .cls: mov word[gs:ebx],0x0720 ;0x0720是黑底白字的空格键 add ebx,2 loop .cls mov bx,1920 ;将光标值重置为1920,最后一行的首字符. ;---------------- 更新光标值 ---------------- .set_cursor: ;将光标设为bx值 ;1 先设置高8位 mov dx, 0x03d4\t;索引寄存器 mov al, 0x0e\t;用于提供光标位置的高8位 out dx, al mov dx, 0x03d5\t;通过读写数据端口0x3d5来获得或设置光标位置 mov al, bh out dx, al ;2 再设置低8位 mov dx, 0x03d4 mov al, 0x0f out dx, al mov dx, 0x03d5 mov al, bl out dx, al .put_char_done: popad ret 内核主函数\r/kernel/main.c\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026#34;print.h\u0026#34; int main(){ put_char(\u0026#39;k\u0026#39;); put_char(\u0026#39;e\u0026#39;); put_char(\u0026#39;r\u0026#39;); put_char(\u0026#39;n\u0026#39;); put_char(\u0026#39;e\u0026#39;); put_char(\u0026#39;l\u0026#39;); put_char(\u0026#39;\\n\u0026#39;); put_char(\u0026#39;1\u0026#39;); put_char(\u0026#39;2\u0026#39;); put_char(\u0026#39;\\b\u0026#39;); put_char(\u0026#39;3\u0026#39;); while (1) ; return 0; } 编译链接\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 mkdir -p bin #编译mbr nasm -o $(pwd)/bin/mbr -I $(pwd)/boot/include/ $(pwd)/boot/mbr.S dd if=$(pwd)/bin/mbr of=~/bochs/hd60M.img bs=512 count=1 conv=notrunc #编译loader nasm -o $(pwd)/bin/loader -I $(pwd)/boot/include/ $(pwd)/boot/loader.S dd if=$(pwd)/bin/loader of=~/bochs/hd60M.img bs=512 count=4 seek=2 conv=notrunc #编译print函数 nasm -f elf32 -o $(pwd)/bin/print.o $(pwd)/lib/kernel/print.S #编译main函数 gcc-4.4 -o $(pwd)/bin/main.o -c -m32 -I $(pwd)/lib/kernel/ $(pwd)/kernel/main.c #将main函数与print函数进行链接 ld -m elf_i386 -Ttext 0xc0001500 -e main -o $(pwd)/bin/kernel.bin $(pwd)/bin/main.o $(pwd)/bin/print.o #将内核文件写入磁盘，loader程序会将其加载到内存运行 dd if=$(pwd)/bin/kernel.bin of=~/bochs/hd60M.img bs=512 count=200 conv=notrunc seek=9 #rm -rf bin/* 运行\r仍旧进入bochs安装目录，运行\n1 ./bin/bochs -f boot.disk 结果如下所示\n实现字符串打印\r字符串打印函数的实现就比较简单了，直接遍历字符串的每一个字符，然后调用上述我们的字符打印函数即可\n在/lib/kernel/print.S文件中添加如下代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 ;================= 字符串打印函数 ================= [bits 32] section .text global put_str put_str: push ebx push ecx xor ecx,ecx mov ebx,[esp+12] ;ebx存放字符串首地址 .goon: mov cl,[ebx] ;取出字符串的第一个字符，存放到cx寄存器中 cmp cl,0 ;判断是否到了字符串结尾，字符串结尾标志符\u0026#39;\\0\u0026#39;即0 jz .str_over push ecx ;压入put_char参数，调用put_char函数 call put_char add esp,4 ;回收栈空间 inc ebx ;指向字符串的下一个字符 jmp .goon .str_over: pop ecx ;回收栈空间 pop ebx ;回收栈空间 ret /kernel/main.c文件中测试如下\n1 2 3 4 5 6 7 8 #include \u0026#34;print.h\u0026#34; int main(void) { put_str(\u0026#34;I am kernel\\n\u0026#34;); while (1) ; return 0; } 编译运行之后结果如下\n","date":"2024-12-15T00:00:00Z","image":"https://raw.githubusercontent.com/jl-sky/imageDatesets/master/2024/12/upgit_20241215_1734252157.jpg","permalink":"http://localhost:1313/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9C%9F%E8%B1%A1%E8%BF%98%E5%8E%9F%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%AE%8C%E5%96%84%E5%86%85%E6%A0%B8/","title":"《操作系统真象还原》第六章 —— 完善内核"},{"content":"本章节所有代码托管在miniOS_32\n章节任务介绍\r任务简介\r上一节，我们介绍了如何开启分页机制，从而让内核能够在分页机制下工作\n本节我们将在正式书写内核之前完成loader的最后一项任务——加载内核\n本章的主要任务有：\n将可执行内核程序从磁盘加载到内存 读取可执行内核程序的elf header，从中读取内核程序的代码段和数据段等内容，并将其加载到内存的指定位置 内存布局\r本节我们的任务完成后，loader的使命也就告一段落了，以下是本节完成后目前的内存布局\n前置知识\r目标文件的分类\r静态链接文件：：这类文件通常是 .a 或 .o 文件，包含已经静态链接的代码和数据，可以被其他程序引用并最终生成可执行文件。 动态链接文件：：这类文件通常是 .so 文件（共享对象文件），它们不包含完整的程序代码，而是依赖于运行时加载共享库（共享对象）。 可执行文件：最终生成的可执行文件，通常是 .out 或类似的格式，包含了可以被操作系统加载和执行的程序代码。 ELF与可执行文件的组成\rELF：即Executable and Linkable Format，可执行文件和目标文件的一种标准格式。它仅仅代表一种文件格式，类似与windows的exe格式,在linux中，目标文件都按照ELF文件格式进行组织.\n程序是由段（如代码段、数据段）组成的，而段是由节组成的（如.text节、.data节、.bss节等），因此在程序头中要有一个段头表（程序头表）和节头表来描述程序中各种段及节的信息，故\n程序头表：也称段头表，用于记录程序中的各个段的信息 节头表：其内元素用于描述程序中的各个节 由于程序头（段头）和节头的数量不固定，因此程序头表和节头表的大小也就不固定，因此需要一个数据结构来说明程序头表和节头表的大小和位置信息，这个数据结构就是elf header，这就是elf header的由来\n故，一个目标文件按照ELF格式进行组织，其主要组成为\nELF header 程序体（代码和数据等） ELF header就是文件头，记录了程序体的相关信息（如程序的入口地址、各种段的信息、符号信息等），并非代码也并非数据，是无法执行的，因此当一个程序加载到内存后，需要根据ELF header抽取出程序的代码和数据，然后将其放到指定内存处才能真正执行代码\nelf header详解\r以下是一个典型的elf可执行目标文件组成\n可以看到，本质上程序是由各种节组成的，其中.init、.text、.rodata组成了代码段，.data、.bss组成了数据段，还有其他的一些段\n以下是这些节的概念\n**.text：**已编译程序的机器代码。 .rodata：只读数据，比如 printf 语句中的格式串和开关语句的跳转表。 .data：已初始化的全局和静态 C 变量。局部 C 变量在运行时被保存在栈中，既不岀现在 .data 节中，也不岀现在 .bss 节中。 .bss：未初始化的全局和静态 C 变量，以及所有被初始化为 0 的全局或静态变量。在目标文件中这个节不占据实际的空间，它仅仅是一个占位符。目标文件格式区分已初始化和未初始化变量是为了空间效率：在目标文件中，未初始化变量不需要占据任何实际的磁盘空间。运行时，在内存中分配这些变量，初始值为 0。 .symtab：一个符号表，它存放在程序中定义和引用的函数和全局变量的信息。一些程序员错误地认为必须通过 -g 选项来编译一个程序，才能得到符号表信息。实际上，每个可重定位目标文件在 .symtab 中都有一张符号表（除非程序员特意用 STRIP 命令去掉它）。然而，和编译器中的符号表不同，.symtab 符号表不包含局部变量的条目。 .rel.text：一个 .text 节中位置的列表，当链接器把这个目标文件和其他文件组合时，需要修改这些位置。一般而言，任何调用外部函数或者引用全局变量的指令都需要修改。另一方面，调用本地函数的指令则不需要修改。注意，可执行目标文件中并不需要重定位信息，因此通常省略，除非用户显式地指示链接器包含这些信息。 .rel.data：被模块引用或定义的所有全局变量的重定位信息。一般而言，任何已初始化的全局变量，如果它的初始值是一个全局变量地址或者外部定义函数的地址，都需要被修改。 .debug：一个调试符号表，其条目是程序中定义的局部变量和类型定义，程序中定义和引用的全局变量，以及原始的 C 源文件。只有以 - g 选项调用编译器驱动程序时，才 会得到这张表。 .line：**原始 C 源程序中的行号和 .text 节中机器指令之间的映射。只有以 -g 选项调用编译器驱动程序时，才会得到这张表。 .strtab：一个字符串表，其内容包括 .symtab 和 .debug 节中的符号表，以及节头部中的节名字。字符串表就是以 null 结尾的字符串的序列。 elf header组成\r在程序中，elf header以结构体的形式存在，如下所示，elf header除了记录程序头表和节头表的信息外，还记录了程序的大小端、elf文件类型等信息\ne_ident[16]：16字节，用来表示elf字符等信息，开头的4个字节是固定不变的，是elf文件的魔数，它们分别是0x7f，以及字符串ELF的asc码:0x45,0x4c,0x46；有关e_ident[5]大小端字节序，，用 file 命令就能够查看到elf格式的可执行程序是LSB，还是MSB。 e_type:2字节，指定elf目标文件的类型，可以看到，可执行文件、动态共享文件以及可重定位文件（静态链接文件）都属于ELF格式的文件，除此以外，代码出现core dump错误时生成的core文件也是一个ELF格式文件 e_machine:2字节，描述elf目标文件要在那种硬件平台运行 e_version：4字节，版本信息 e_entry:占用4字节，用来指明操作系统运行该程序时，将控制权转交到的虚拟地址 e_phoff(program header table offset)：4字节，程序头表在文件内的字节偏移量 e_shoff(section header table offset)：4字节，节头表在文件内的偏移量 e_flags:4字节，指明与处理器相关的标志 e_ehsize：2字节，指明elf header字节大小 e_phentsize;2字节，指明程序头表中每个条目（entry）的字节大小，也就是每个用来描述段信息的数据结构的字节大小 e_phnum:2字节，程序头表中条目的数量 e_shentsize：2字节，节头表中每个条目的字节大小 e_shnum：2字节，节头表中条目的数量 e_shstrndx：2字节，指明string name table在节头表中的索引index 程序头表组成\r同理，程序头表也是以结构体形式存在，记录了程序各段的信息\n​\tp_type：4字节，程序中段的类型 p_offset：4字节，本段在文件内的起始偏移地址 p_vaddr：4字节，本段在内存中的起始虚拟地址 p_paddr：4字节，暂且保留，未设定 p_filez：4字节，本段在文件中的大小 p_memsz：4字节，本段在内存中的大小 p_flags：4字节，指明与本段相关的标志，如本段的权限信息 p_align：4字节，用来指明本段在文件和内存中的对齐方式。如果值为0或1，则表示不对齐。否则p_align应该是2的幂次数。 如何查看一个程序的elf header信息\r如下，我们写一个简单的程序\n1 2 3 4 5 6 int num1=10; char c1=\u0026#39;a\u0026#39;; int main(){ int num2=20; char c2=\u0026#39;b\u0026#39;; } 然后使用gcc编译它\n1 gcc ./main.cc -o main 在Linux中，查看一个可执行文件的工具是objdump，如下我们使用objdump查看可执行程序main的头信息\n1 objdump -x main 显示的信息比较多，我们分开来看\n1 2 3 4 5 main: file format elf64-x86-64 main architecture: i386:x86-64, flags 0x00000150: HAS_SYMS, DYNAMIC, D_PAGED start address 0x00000000000004f0 这段信息告诉我们这是一个64位的ELF文件，并且该文件是针对 64 位 x86 架构构建的，支持兼容Intel 32 位指令集，程序的入口地址是0x00000000000004f0\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 Program Header: PHDR off 0x0000000000000040 vaddr 0x0000000000000040 paddr 0x0000000000000040 align 2**3 filesz 0x00000000000001f8 memsz 0x00000000000001f8 flags r-- INTERP off 0x0000000000000238 vaddr 0x0000000000000238 paddr 0x0000000000000238 align 2**0 filesz 0x000000000000001c memsz 0x000000000000001c flags r-- LOAD off 0x0000000000000000 vaddr 0x0000000000000000 paddr 0x0000000000000000 align 2**21 filesz 0x00000000000007d8 memsz 0x00000000000007d8 flags r-x LOAD off 0x0000000000000df0 vaddr 0x0000000000200df0 paddr 0x0000000000200df0 align 2**21 filesz 0x0000000000000225 memsz 0x0000000000000228 flags rw- DYNAMIC off 0x0000000000000e00 vaddr 0x0000000000200e00 paddr 0x0000000000200e00 align 2**3 filesz 0x00000000000001c0 memsz 0x00000000000001c0 flags rw- NOTE off 0x0000000000000254 vaddr 0x0000000000000254 paddr 0x0000000000000254 align 2**2 filesz 0x0000000000000044 memsz 0x0000000000000044 flags r-- EH_FRAME off 0x0000000000000694 vaddr 0x0000000000000694 paddr 0x0000000000000694 align 2**2 filesz 0x000000000000003c memsz 0x000000000000003c flags r-- STACK off 0x0000000000000000 vaddr 0x0000000000000000 paddr 0x0000000000000000 align 2**4 filesz 0x0000000000000000 memsz 0x0000000000000000 flags rw- RELRO off 0x0000000000000df0 vaddr 0x0000000000200df0 paddr 0x0000000000200df0 align 2**0 filesz 0x0000000000000210 memsz 0x0000000000000210 flags r-- 我们主要看这段信息，这段信息就是我们说的elf header里的程序头表（Program Header table），再次强调\nelf header里记录了程序头表和节头表的信息，程序头表记录了程序头（段）的信息，节头表记录了节的信息\n观察上述程序头表的这段信息\n这段信息起始就是代码段的相关信息，我们以这段信息为例：\noff：该段在目标文件中的偏移 vaddr/paddr：该段在内存中的虚拟地址 align：对齐要求 filesz：目标文件中该段的大小 memsz：内存中该段的大小 flags：运行时该段的访问权限 1 2 LOAD off 0x0000000000000000 vaddr 0x0000000000000000 paddr 0x0000000000000000 align 2**21 filesz 0x00000000000007d8 memsz 0x00000000000007d8 flags r-x 因此上述信息告诉我们，代码段具有可读、执行权限，开始于虚拟内存地址0x0000000000000000处，总共的内存大小是0x00000000000007d8字节\n同理以下是程序的数据段信息，这段信息告诉我们，数据段具有读写权限，开始于虚拟内存地址0x0000000000200df0处，总共的内存大小是0x0000000000000228字节\n1 2 LOAD off 0x0000000000000df0 vaddr 0x0000000000200df0 paddr 0x0000000000200df0 align 2**21 filesz 0x0000000000000225 memsz 0x0000000000000228 flags rw- 接下来我们再来看一下节的相关信息\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 Sections: Idx Name Size VMA LMA File off Algn 0 .interp 0000001c 0000000000000238 0000000000000238 00000238 2**0 CONTENTS, ALLOC, LOAD, READONLY, DATA 1 .note.ABI-tag 00000020 0000000000000254 0000000000000254 00000254 2**2 CONTENTS, ALLOC, LOAD, READONLY, DATA 2 .note.gnu.build-id 00000024 0000000000000274 0000000000000274 00000274 2**2 CONTENTS, ALLOC, LOAD, READONLY, DATA 3 .gnu.hash 0000001c 0000000000000298 0000000000000298 00000298 2**3 CONTENTS, ALLOC, LOAD, READONLY, DATA 4 .dynsym 00000090 00000000000002b8 00000000000002b8 000002b8 2**3 CONTENTS, ALLOC, LOAD, READONLY, DATA 5 .dynstr 0000007d 0000000000000348 0000000000000348 00000348 2**0 CONTENTS, ALLOC, LOAD, READONLY, DATA 6 .gnu.version 0000000c 00000000000003c6 00000000000003c6 000003c6 2**1 CONTENTS, ALLOC, LOAD, READONLY, DATA 7 .gnu.version_r 00000020 00000000000003d8 00000000000003d8 000003d8 2**3 CONTENTS, ALLOC, LOAD, READONLY, DATA 8 .rela.dyn 000000c0 00000000000003f8 00000000000003f8 000003f8 2**3 CONTENTS, ALLOC, LOAD, READONLY, DATA 9 .init 00000017 00000000000004b8 00000000000004b8 000004b8 2**2 CONTENTS, ALLOC, LOAD, READONLY, CODE 10 .plt 00000010 00000000000004d0 00000000000004d0 000004d0 2**4 CONTENTS, ALLOC, LOAD, READONLY, CODE 11 .plt.got 00000008 00000000000004e0 00000000000004e0 000004e0 2**3 CONTENTS, ALLOC, LOAD, READONLY, CODE 12 .text 00000192 00000000000004f0 00000000000004f0 000004f0 2**4 CONTENTS, ALLOC, LOAD, READONLY, CODE 13 .fini 00000009 0000000000000684 0000000000000684 00000684 2**2 CONTENTS, ALLOC, LOAD, READONLY, CODE 14 .rodata 00000004 0000000000000690 0000000000000690 00000690 2**2 CONTENTS, ALLOC, LOAD, READONLY, DATA 15 .eh_frame_hdr 0000003c 0000000000000694 0000000000000694 00000694 2**2 CONTENTS, ALLOC, LOAD, READONLY, DATA 16 .eh_frame 00000108 00000000000006d0 00000000000006d0 000006d0 2**3 CONTENTS, ALLOC, LOAD, READONLY, DATA 17 .init_array 00000008 0000000000200df0 0000000000200df0 00000df0 2**3 CONTENTS, ALLOC, LOAD, DATA 18 .fini_array 00000008 0000000000200df8 0000000000200df8 00000df8 2**3 CONTENTS, ALLOC, LOAD, DATA 19 .dynamic 000001c0 0000000000200e00 0000000000200e00 00000e00 2**3 CONTENTS, ALLOC, LOAD, DATA 20 .got 00000040 0000000000200fc0 0000000000200fc0 00000fc0 2**3 CONTENTS, ALLOC, LOAD, DATA 21 .data 00000015 0000000000201000 0000000000201000 00001000 2**3 CONTENTS, ALLOC, LOAD, DATA 22 .bss 00000003 0000000000201015 0000000000201015 00001015 2**0 ALLOC 23 .comment 00000029 0000000000000000 0000000000000000 00001015 2**0 CONTENTS, READONLY 我们仍旧截取一些我们熟悉的节进行说明\n1 2 3 Idx Name Size VMA LMA File off Algn 12 .text 00000192 00000000000004f0 00000000000004f0 000004f0 2**4 CONTENTS, ALLOC, LOAD, READONLY, CODE 这段信息表示，这是一个.text节，隶属于代码段，只读，在Linux程序中的索引是12（程序以索引标记一个节），节的大小是00000192\n同理以下是.data节的相关信息\n1 2 3 Idx Name Size VMA LMA File off Algn 21 .data 00000015 0000000000201000 0000000000201000 00001000 2**3 CONTENTS, ALLOC, LOAD, DATA 除此以外，我们还需要知道，程序在链接的时候需要知道各种符号的信息，所谓符号就是函数名、全局变量名等，注意局部变量不是符合，因为局部变量本质上是在程序执行后存在于栈中，随着函数栈的开辟和销毁而生存和死亡\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 SYMBOL TABLE: 0000000000000238 l d .interp 0000000000000000 .interp 0000000000000254 l d .note.ABI-tag 0000000000000000 .note.ABI-tag 0000000000000274 l d .note.gnu.build-id 0000000000000000 .note.gnu.build-id 0000000000000298 l d .gnu.hash 0000000000000000 .gnu.hash 00000000000002b8 l d .dynsym 0000000000000000 .dynsym 0000000000000348 l d .dynstr 0000000000000000 .dynstr 00000000000003c6 l d .gnu.version 0000000000000000 .gnu.version 00000000000003d8 l d .gnu.version_r 0000000000000000 .gnu.version_r 00000000000003f8 l d .rela.dyn 0000000000000000 .rela.dyn 00000000000004b8 l d .init 0000000000000000 .init 00000000000004d0 l d .plt 0000000000000000 .plt 00000000000004e0 l d .plt.got 0000000000000000 .plt.got 00000000000004f0 l d .text 0000000000000000 .text 0000000000000684 l d .fini 0000000000000000 .fini 0000000000000690 l d .rodata 0000000000000000 .rodata 0000000000000694 l d .eh_frame_hdr 0000000000000000 .eh_frame_hdr 00000000000006d0 l d .eh_frame 0000000000000000 .eh_frame 0000000000200df0 l d .init_array 0000000000000000 .init_array 0000000000200df8 l d .fini_array 0000000000000000 .fini_array 0000000000200e00 l d .dynamic 0000000000000000 .dynamic 0000000000200fc0 l d .got 0000000000000000 .got 0000000000201000 l d .data 0000000000000000 .data 0000000000201015 l d .bss 0000000000000000 .bss 0000000000000000 l d .comment 0000000000000000 .comment 0000000000000000 l df *ABS* 0000000000000000 crtstuff.c 0000000000000520 l F .text 0000000000000000 deregister_tm_clones 0000000000000560 l F .text 0000000000000000 register_tm_clones 00000000000005b0 l F .text 0000000000000000 __do_global_dtors_aux 0000000000201015 l O .bss 0000000000000001 completed.7698 0000000000200df8 l O .fini_array 0000000000000000 __do_global_dtors_aux_fini_array_entry 00000000000005f0 l F .text 0000000000000000 frame_dummy 0000000000200df0 l O .init_array 0000000000000000 __frame_dummy_init_array_entry 0000000000000000 l df *ABS* 0000000000000000 main.cc 0000000000000000 l df *ABS* 0000000000000000 crtstuff.c 00000000000007d4 l O .eh_frame 0000000000000000 __FRAME_END__ 0000000000000000 l df *ABS* 0000000000000000 0000000000200df8 l .init_array 0000000000000000 __init_array_end 0000000000200e00 l O .dynamic 0000000000000000 _DYNAMIC 0000000000200df0 l .init_array 0000000000000000 __init_array_start 0000000000000694 l .eh_frame_hdr 0000000000000000 __GNU_EH_FRAME_HDR 0000000000200fc0 l O .got 0000000000000000 _GLOBAL_OFFSET_TABLE_ 0000000000000680 g F .text 0000000000000002 __libc_csu_fini 0000000000000000 w *UND* 0000000000000000 _ITM_deregisterTMCloneTable 0000000000201000 w .data 0000000000000000 data_start 0000000000201015 g .data 0000000000000000 _edata 0000000000000684 g F .fini 0000000000000000 _fini 0000000000000000 F *UND* 0000000000000000 __libc_start_main@@GLIBC_2.2.5 0000000000201000 g .data 0000000000000000 __data_start 0000000000000000 w *UND* 0000000000000000 __gmon_start__ 0000000000201008 g O .data 0000000000000000 .hidden __dso_handle 0000000000000690 g O .rodata 0000000000000004 _IO_stdin_used 0000000000000610 g F .text 0000000000000065 __libc_csu_init 0000000000201010 g O .data 0000000000000004 num1 0000000000201018 g .bss 0000000000000000 _end 00000000000004f0 g F .text 000000000000002b _start 0000000000201014 g O .data 0000000000000001 c1 0000000000201015 g .bss 0000000000000000 __bss_start 00000000000005fa g F .text 0000000000000016 main 0000000000201018 g O .data 0000000000000000 .hidden __TMC_END__ 0000000000000000 w *UND* 0000000000000000 _ITM_registerTMCloneTable 0000000000000000 w F *UND* 0000000000000000 __cxa_finalize@@GLIBC_2.2.5 00000000000004b8 g F .init 0000000000000000 _init 以上是我们程序的符号信息，这些符号信息记录在符号表中，我们还截取一些我们知道的说明\n1 00000000000005fa g F .text 0000000000000016 main 00000000000005fa：这是符号在内存中的地址，表示 main 函数在程序内存中的位置。\ng，符号类型：g 表示符号是 全局符号。\nF，符号类型（进一步说明）：F 表示这个符号是一个 函数。因此，main 符号代表的是一个函数的入口。\n.text，节区（Section）：.text 是二进制文件中的代码段（text section）。在 ELF 文件中，.text 节区存放的是可执行代码\n0000000000000016，大小：这表示 main 函数的大小是 16 字节（十六进制表示 0x16，即 22 字节）。\nmain：这是符号的名称。这里表示的是程序的入口函数 main。\n同理，我们也可以找到全局变量num1的符号信息，其中O 表示符号是 对象，也就是说，num1 是一个数据对象，而不是一个函数。这通常指的是变量或常量，而不是执行代码的函数\n1 0000000000201010 g O .data 0000000000000004 num1 观察上述符号信息，我们发现是没有num2这个局部变量的符号信息的，这个局部变量的生命周期由栈控制的，不参与链接过程\n加载内核\r代码目录结构\r1 2 3 4 5 6 7 8 9 10 11 . ├── boot │ ├── include │ │ └── boot.inc │ ├── loader.S │ └── mbr.S ├── lib │ └── kernel │ └── main.c ├── Makefile └── start.sh 将内核载入内存\r回忆我们之前加载mbr程序和loader程序的过程\nmbr程序固定在磁盘0块0扇区，大小固定512B，最后两个字节固定是0x55,0xaa，由BIOS开启后加载到内存的0x7c00位置处执行 loader程序由我们自定义在磁盘0块2号扇区，同时由我们写的mbr程序将其加载到0x900位置处（可执行代码的位置是0xc00，中间是512字节的GDT和256字节的物理内存容量信息，这段0x300字节的信息是保存在内存中加载内核的必要信息，是不可执行的） 因此，本节我们加载内核文件也是同样的过程，也需要由loader将内核文件从磁盘的某个位置加载到内存的某个位置，于是我们定义\n内核文件在磁盘的位置是0块9号扇区 加载到内存的物理位置是0x70000 另外我们的内核加载代码有以下特点\n在保护模式下运行，保护模式是32位的，因此需要修改之前我们加载loader的16位程序 在分页机制开启之前进行加载，这一点并非固定，只是在分页机制开启之前加载，0x70000直接就是物理地址，我们可以直接内核加载到该物理地址处 要加载内核，我们首先需要写一个简单的内核代码\n/lib/kernel/main.c\n1 2 3 4 int main(void){ while(1); return 0; } 这里我们只是先写一段简单的代码以作测试，真正的内核代码我们后续再进行补充\n编译内核\n1 gcc-4.4 $(pwd)/lib/kernel/main.c -c -m32 -o $(pwd)/bin/main.o 链接内核\n1 ld -m elf_i386 -Ttext 0x00001500 -e main -o $(pwd)/bin/kernel.bin $(pwd)/bin/main.o 这里有一个小插曲，由于目前我们使用的操作系统一般都是64位的，因此使用默认的编译器编译出来的结果都是64位的\n故而在最后的编译阶段需要降低gcc版本至gcc-4.4，同时使用-m32选项使编译出来的结果是32位，否则便会报错\n具体操作如下:\n1.打开apt-get源\n1 vim /etc/apt/sources.list 增加如下内容\n1 2 deb http://dk.archive.ubuntu.com/ubuntu/ trusty main universe deb http://dk.archive.ubuntu.com/ubuntu/ trusty-updates main universe 2.更新apt源\n1 sudo apt-get update 3.安装gcc-4.4\n1 sudo apt-get install g++-4.4 4.如果最后仍旧报错，则执行\n1 sudo apt-get install libc6-dev-i386 接下来我们开始正式将上述编译成功的内核文件kernel.bin加载到内存，以下是加载内核的代码\n/boot/loader.S\n1 2 3 4 5 6 ;------------- 加载内核 ---------------- ;将内核从磁盘的9号扇区加载的内存的KERNEL_BIN_BASE_ADDR地址处 mov eax,KERNEL_START_SECTOR mov ebx,KERNEL_BIN_BASE_ADDR mov ecx,200 call rd_disk_m_32 代码中相关的宏如下所示\n/boot/include/boot.inc\n1 2 3 4 5 6 ;----- 定义内核相关宏 ----- KERNEL_BIN_BASE_ADDR equ 0x70000 ;内核文件在内存中的位置，也就是包含文件头和程序数据的原始内核文件暂时存储在内存中的位置 ;注意内核加载是在开启分页机制之前进行的，因此该地址并不是虚拟地址，而是物理地址 ;0号扇区存放mbr，2号~4号扇区存放loader，为避免将来扩大loader，将内核存放在9号扇区 KERNEL_START_SECTOR equ 0x9 ;内核在磁盘的起始扇区 同mbr加载loader一样，我们使用写好的函数将内核文件从磁盘加载到内存指定位置，只是这里是在32位保护模式下运行，因此需要简单修改一下代码，如下所示\n/boot/loader.S\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 ; ------ 32位模式下从磁盘中加载文件到内存 ------ rd_disk_m_32: ;参数： ; eax=LBA扇区号 ; ebx=将数据写入的内存地址 ; ecx=读入的扇区数 mov esi,eax\t;备份eax mov di,cx\t;备份cx ;读写硬盘: ;第1步：选择特定通道的寄存器，设置要读取的扇区数 mov dx,0x1f2 mov al,cl out dx,al ;读取的扇区数 mov eax,esi\t;恢复ax ;第2步：在特定通道寄存器中放入要读取扇区的地址，将LBA地址存入0x1f3 ~ 0x1f6 ;LBA地址7~0位写入端口0x1f3 mov dx,0x1f3 out dx,al ;LBA地址15~8位写入端口0x1f4 mov cl,8 shr eax,cl mov dx,0x1f4 out dx,al ;LBA地址23~16位写入端口0x1f5 shr eax,cl mov dx,0x1f5 out dx,al shr eax,cl and al,0x0f\t;lba第24~27位 or al,0xe0\t; 设置7～4位为1110,表示lba模式 mov dx,0x1f6 out dx,al ;第3步：向0x1f7端口写入读命令，0x20 mov dx,0x1f7 mov al,0x20 out dx,al ;第4步：检测硬盘状态 .not_ready: ;同一端口，写时表示写入命令字，读时表示读入硬盘状态 nop in al,dx and al,0x88\t;第4位为1表示硬盘控制器已准备好数据传输，第7位为1表示硬盘忙 cmp al,0x08 jnz .not_ready\t;若未准备好，继续等。 ;第5步：从0x1f0端口读数据 mov ax, di ;di当中存储的是要读取的扇区数 mov dx, 256 ;每个扇区512字节，一次读取两个字节，所以一个扇区就要读取256次，与扇区数相乘，就等得到总读取次数 mul dx ;8位乘法与16位乘法知识查看书p133,注意：16位乘法会改变dx的值！！！！ mov cx, ax\t; 得到了要读取的总次数，然后将这个数字放入cx中 mov dx, 0x1f0 .go_on_read: in ax,dx mov [ebx],ax ;与rd_disk_m_16相比，就是把这两句的bx改成了ebx add ebx,2\t; 由于在实模式下偏移地址为16位,所以用bx只会访问到0~FFFFh的偏移。 ; loader的栈指针为0x900,bx为指向的数据输出缓冲区,且为16位， ; 超过0xffff后,bx部分会从0开始,所以当要读取的扇区数过大,待写入的地址超过bx的范围时， ; 从硬盘上读出的数据会把0x0000~0xffff的覆盖， ; 造成栈被破坏,所以ret返回时,返回地址被破坏了,已经不是之前正确的地址, ; 故程序出会错,不知道会跑到哪里去。 ; 所以改为ebx代替bx指向缓冲区,这样生成的机器码前面会有0x66和0x67来反转。 ; 0X66用于反转默认的操作数大小! 0X67用于反转默认的寻址方式. ; cpu处于16位模式时,会理所当然的认为操作数和寻址都是16位,处于32位模式时, ; 也会认为要执行的指令是32位. ; 当我们在其中任意模式下用了另外模式的寻址方式或操作数大小(姑且认为16位模式用16位字节操作数， ; 32位模式下用32字节的操作数)时,编译器会在指令前帮我们加上0x66或0x67， ; 临时改变当前cpu模式到另外的模式下. ; 假设当前运行在16位模式,遇到0X66时,操作数大小变为32位. ; 假设当前运行在32位模式,遇到0X66时,操作数大小变为16位. ; 假设当前运行在16位模式,遇到0X67时,寻址方式变为32位寻址 ; 假设当前运行在32位模式,遇到0X67时,寻址方式变为16位寻址. loop .go_on_read ret 解析内核头文件，加载内核映像\r内核映像，其实就是解析内核的elf头之后，将内核文件的程序代码和程序数据抽出来，然后放到内存的指定位置处执行，之所以这样做是因为elf头文件只是记录程序信息的结构化信息，不能执行，但是计算机不知道这一点，需要我们执行这一步操作\n注意，解析内核头文件的工作是在开启分页机制后进行的，因为内核将来要做分页机制下工作，因此我们直接在分页机制下加载内核映像\n那么问题来了，我们要将内核映像加载到内存的哪里呢？\n关于这个问题，我们知道，将来我们的内核会越来越大，而我们的内核物理空间在低1M字节这块区域内，因此我们尽量让我们的内核映像放置到内存低字节位置，这样将来的内核才有可余空间增长 另一方面，我们知道，我们的loader程序已经占据在了内存的0x900位置，其中0x900 ~ 0xb00是GDT的信息，0xb00 ~ 0xc00是存放的物理内存容量信息，这些信息都不能被覆盖，因此我们的内核映像不能覆盖掉loader 于是乎，假设我们loader大小最大是2000B，则0x900+2000=0x10d0，向上取整就将内核的物理加载地址选为0x1500 读者会发现，之前我们给内核文件加载的位置的0x70000，而我们的内核映像是在0x1500，如果内核映像覆盖掉原始内核文件怎么办，这一点不必担心，因为内核文件在被抽离出来内核映像之后就没用了，因此即使覆盖掉也没关系 综上，我们有如下定义\n/boot/include/boot.inc\n1 2 3 4 5 ;loader的物理加载地址是0x900,假设loader的文件大小最大为2000B,则0x900+2000=0x10d0， ;向上取整就将内核的物理加载地址选为0x1500 ;由于我们将操作系统的虚拟地址空间划分为3GB~4GB ;因此内核的虚拟加载地址就成了0xc0000000+0x1500=0xc0001500 KERNEL_ENTRY_POINT equ 0xc0001500 ;内核可执行代码（内核映像）的虚拟入口地址 注意，0xc0001500这个内核映像的虚拟入口地址是由gcc-4.4编译器用选项-Ttext 0x00001500指定的\n另外，我们还需要添加一段宏定义信息，在提取elf头信息时使用\n1 2 ;----- 程序段的类型定义 --------- PT_NULL equ 0 有了以上准备后，我们就可以正式加载内核映像了\n/boot/loader.S\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 ;------------- 进入内核函数 ---------------- enter_kernel: call kernel_init mov esp,0xc009f000 jmp KERNEL_ENTRY_POINT kernel_init: xor eax,eax xor ebx,ebx ;记录程序头表(段)地址 xor ecx,ecx ;记录程序头表(段头表)中程序头数量 xor edx,edx ;记录程序头表中每个条目的大小 mov dx,[KERNEL_BIN_BASE_ADDR+42] ;42字节处是e_phentsize，即程序头中每个条目的大小 mov ebx,[KERNEL_BIN_BASE_ADDR+28] ;28字节处是e_phoff，即程序头表的偏移 add ebx,KERNEL_BIN_BASE_ADDR ;程序头表的偏移加上内核在内存中的起始地址，就是程序头表的起始物理地址 mov cx,[KERNEL_BIN_BASE_ADDR+44] ;44字节处是e_phnum，即程序头表(段头表)中程序头数量 ;遍历段头表，取出程序中的每一个段，将其拷贝到对应的虚拟地址空间中 .each_segment: ;检查段头表中的段头是会否是空段(PT_NULL)，如果不是就将该段拷贝到对应区域，否则就继续遍历下一个段头 cmp byte [ebx+0],PT_NULL ;比较p_type是否等于PT_NULL，若相等说明程序头未使用 je .PTNULL ;若相等则跳转到.PTNULL ;为函数memcpy(dst,src,size)压入参数，参数依次从右向左压入，这样函数就可以从左到右取出参数 push dword [ebx+16] ;实参size，程序头表偏移16字节的地方p_filesz，本段在文件内的大小 .PTNULL: add ebx,edx ;指向下一个段头 loop .each_segment ;继续遍历段头表 ret ;逐字节拷贝函数，将esi指向的内存区域的size个字节拷贝到edi指向的区域 mem_cpy: cld ;指明拷贝时esi与edi的增长方向是向上的 push ebp ;保存ebp mov ebp,esp ;将esp指向ebp push ecx ;rep指令会用到ecx的循环计数，而外层函数也用到了ecx的值， ;因此此处需要将外层函数的ecx的值进行备份 mov edi,[ebp+8] ;参数dst mov esi,[ebp+12] ;参数src mov ecx,[ebp+16] ;参数size rep movsb ;rep(repeat)指令，重复执行movsb指令 ;movsb指令，s表示string，b表示byte， ;即将esi指向的内存拷贝一个字节给edi指向的内存 ;因此本条指令表示逐字节拷贝，拷贝的字节个数为ecx的值 pop ecx ;取出备份的值 pop ebp ;返回上层函数 ret 代码逻辑很简单：\n从elf头中读取程序头表的信息 程序头表的初始偏移 程序头表中条目（记录段的信息）的数量 程序头表中每个条目的大小 读取到程序头表的信息后，我们就可以像遍历数组一样遍历程序头表，取出程序头表中的每个程序头（也就是段头）的信息 本段在文件内的大小 本段在文件内的起始偏移 本段在内存中的起始虚拟地址 将段复制到内存指定的虚拟地址处 以下是完整代码\n/boot/include/boot.inc\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 ;----- loader and kernel ----- LOADER_BASE_ADDR equ 0x900 ;loader在内存中位置 LOADER_START_SECTOR equ 0x2 ;loader在磁盘中的逻辑扇区地址，即LBA地址 LOADER_STACK_TOP equ LOADER_BASE_ADDR ;初始化栈指针地址 ;----- 定义内核相关宏 ----- KERNEL_BIN_BASE_ADDR equ 0x70000 ;内核文件在内存中的位置，也就是包含文件头和程序数据的原始内核文件暂时存储在内存中的位置 ;注意内核加载是在开启分页机制之前进行的，因此该地址并不是虚拟地址，而是物理地址 ;0号扇区存放mbr，2号~4号扇区存放loader，为避免将来扩大loader，将内核存放在9号扇区 KERNEL_START_SECTOR equ 0x9 ;内核在磁盘的起始扇区 ;loader的物理加载地址是0x900,假设loader的文件大小最大为2000B,则0x900+2000=0x10d0， ;向上取整就将内核的物理加载地址选为0x1500 ;由于我们将操作系统的虚拟地址空间划分为3GB~4GB ;因此内核的虚拟加载地址就成了0xc0000000+0x1500=0xc0001500 KERNEL_ENTRY_POINT equ 0xc0001500 ;内核可执行代码（内核映像）的虚拟入口地址 ;----- 定义页目录表与页表相关宏 ----- PAGE_DIR_TABLE_POS equ 0x100000 ;页目录表基址 ;----- gdt描述符属性 --------- DESC_G_4K equ 1_00000000000000000000000b ;设置段界限的单位为4KB DESC_D_32 equ 1_0000000000000000000000b ;设置代码段/数据段的有效地址（段内偏移地址）及操作数大小为32位 DESC_L equ 0_000000000000000000000b ;64位代码段标记位，现在是32位操作系统，因此标记为0即可。 DESC_AVL equ 0_00000000000000000000b ;定义段界限位 ;段界限的第2部分，即描述符的高32位中的第16~19位，最终的代码段段界限为0xFFFFF DESC_LIMIT_CODE2 equ 1111_0000000000000000b ;定义代码段要用的段描述符高32位中16~19段界限为全1 DESC_LIMIT_DATA2 equ DESC_LIMIT_CODE2 ;定义数据段要用的段描述符高32位中16~19段界限为全1 DESC_LIMIT_VIDEO2 equ 0000_000000000000000b ;定义我们要操作显存时对应的段描述符的高32位中16~19段界限为全0 DESC_P equ 1_000000000000000b ;定义了段描述符中的P标志位，表示该段描述符指向的段是否在内存中 ;定义描述符的特权级别位 DESC_DPL_0 equ 00_0000000000000b DESC_DPL_1 equ 01_0000000000000b DESC_DPL_2 equ 10_0000000000000b DESC_DPL_3 equ 11_0000000000000b ;定义类型位 DESC_S_CODE equ 1_000000000000b ;代码段和数据段都是非系统段，故类型字段s设置为1 DESC_S_DATA equ DESC_S_CODE ;代码段和数据段都是非系统段，故类型字段s设置为1 DESC_S_sys equ 0_000000000000b ;系统段的类型字段设置为0 ;定义子类型位 DESC_TYPE_CODE equ 1000_00000000b ;x=1,c=0,r=0,a=0 代码段是可执行的，非一致性，不可读，已访问位a清0 DESC_TYPE_DATA equ 0010_00000000b ;x=0,e=0,w=1,a=0，数据段不可执行，向上扩展，可写，已访问位a清0 ;拼接代码段的描述符 DESC_CODE_HIGH4 equ (0x00\u0026lt;\u0026lt;24) + DESC_G_4K \\ + DESC_D_32 + DESC_L + \\ DESC_AVL + DESC_LIMIT_CODE2 + DESC_P + DESC_DPL_0 + \\ DESC_S_CODE + DESC_TYPE_CODE + 0x00 ;拼接数据段的描述符 DESC_DATA_HIGH4 equ (0x00\u0026lt;\u0026lt;24) + DESC_G_4K \\ + DESC_D_32 + DESC_L + \\ DESC_AVL + DESC_LIMIT_DATA2 + DESC_P + DESC_DPL_0 + \\ DESC_S_DATA + DESC_TYPE_DATA + 0x00 ;拼接显存段的描述符位 DESC_VIDEO_HIGH4 equ (0x00\u0026lt;\u0026lt;24) + DESC_G_4K \\ + DESC_D_32 + DESC_L + \\ DESC_AVL + DESC_LIMIT_VIDEO2 + DESC_P + DESC_DPL_0 + \\ DESC_S_DATA + DESC_TYPE_DATA + 0x0b ;----- 选择子属性 --------- RPL0 equ 00b RPL1 equ 01b RPL2 equ 10b RPL3 equ 11b TI_GDT equ 000b TI_LDT equ 100b ;----- 模块化的页目录表字段 --------- PG_P equ 1b PG_RW_R equ 00b PG_RW_W equ 10b PG_US_S equ 000b PG_US_U equ 100b ;----- 程序段的类型定义 --------- PT_NULL equ 0 /boot/loader.S\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 %include \u0026#34;boot.inc\u0026#34; SECTION loader vstart=LOADER_BASE_ADDR ;------------- 构建gdt及其内部的描述符 ------------- GDT_BASE: dd 0x00000000 dd 0x00000000 ;代码段描述符的低4字节部分，其中高两个字节表示段基址的0~15位,在这里定义为0x0000 ;低两个字节表示段界限的0~15位，由于使用的是平坦模型，因此是0xFFFF CODE_DESC: dd 0x0000FFFF dd DESC_CODE_HIGH4;段描述符的高4字节部分 DATA_STACK_DESC: dd 0x0000FFFF dd DESC_DATA_HIGH4 ;定义显存段的描述符 ;文本模式下的适配器地址为0xb8000~0xbffff,为了方便显存操作，显存段不使用平坦模型 ;因此段基址为0xb8000,段大小为0xbffff-0xb8000=0x7fff, ;段粒度位4k，因此段界限的值为0x7fff/4k=7 VIDEO_DESC: dd 0x80000007 dd DESC_VIDEO_HIGH4 GDT_SIZE equ $-GDT_BASE GDT_LIMIT equ GDT_SIZE-1 times 60 dq 0 ;此处预留60个描述符的空位 ;------------- 构建选择子 ------------- SELECTOR_CODE equ (0x0001\u0026lt;\u0026lt;3) + TI_GDT + RPL0 SELECTOR_DATA equ (0x0002\u0026lt;\u0026lt;3) + TI_GDT + RPL0 SELECTOR_VIDEO equ (0x0003\u0026lt;\u0026lt;3) + TI_GDT + RPL0 total_mem_bytes dd 0 ;total_mem_bytes用于保存最终获取到的内存容量，为4个字节 ;由于loader程序的加载地址为0x900，而loader.bin的文件头大小为0x200 ;（4个gdt段描述符（8B）加上60个dp（8B）填充字，故64*8=512B）， ;故total_mem_bytes在内存中的地址为0x900+0x200=0xb00 ;该地址将来在内核中会被用到 ;------------- 定义gdtr（指向GDT的寄存器） ------------- gdt_ptr dw GDT_LIMIT dd GDT_BASE ;------------- 定义记录ARDS结构体信息的变量 ------------- ards_buf times 244 db 0 ;开辟一块缓冲区，用于记录返回的ARDS结构体， ;该定义语句事实上是定义了一个数组ards_buf[244] ;244是因为total_mem_bytes(4)+gdt_ptr(6)+244+ards_nr(2)=256,即0x100 ;这样loader_start的在文件内的偏移地址就是0x100+0x200=0x300 ards_nr dw 0 ;用于记录ards结构体数量 ;------------------------------------------ ;INT 0x15 功能号：0xe820 功能描述：获取内存容量，检测内存 ;------------------------------------------ ;输入： ;EAX:功能号，0xE820，但调用返回时eax会被填入一串ASCII值 ;EBX:ARDS后续值 ;ES:di:ARDS缓冲区，BIOS将获取到的内存信息存到此寄存器指向的内存，每次都以ARDS格式返回 ;ECX:ARDS结构的字节大小，20 ;EDX:固定为签名标记，0x534d4150 ;返回值 ;CF：若cf为0，表示未出错，cf为1，表示调用出错 ;EAX：字符串SMAP的ASCII码值，0x534d4150 ;ES:di:ARDS缓冲区，BIOS将获取到的内存信息存到此寄存器指向的内存，每次都以ARDS格式返回 ;ECX:ARDS结构的字节大小，20 ;EBX:ARDS后续值，即下一个ARDS的位置。 ;每次BIOS中断返回后，BIOS会更新此值，BIOS会通过此值找到下一个待返回的ARDS结构。 ;在cf位为0的情况下，若返回后的EBX值为0，表示这是最后一个ARDS结构 loader_start: xor ebx,ebx ;第一次调用时，要将ebx清空置为0，此处使用的是异或运算置0 mov edx,0x534d4150 mov di,ards_buf ;di存储缓冲区地址，即指向缓冲区首地址 .e820_mem_get_loop: mov eax,0x0000e820 mov ecx,20 ;一个ards结构体的大小 int 0x15 ;调用0x15中断函数，返回的ards结构体被返回给di指向的缓冲区中 add di,cx ;使di增加20字节指向缓冲区中下一个的ARDS结构位置 inc word [ards_nr] ;inc（increment增加）指令表示将内存中的操作数增加一，此处用于记录返回的ARDS数量 cmp ebx,0 ;比较ebx中的值是否为0 jnz .e820_mem_get_loop ;若ebx不为0，则继续进行循环获取ARDS， ;若为0说明已经获取到最后一个ards，则退出循环 mov cx,[ards_nr] ;cx存储遍历到的ards结构体个数 mov ebx,ards_buf ;ebx指向缓冲区地址 xor edx,edx ;EDX用于保存BaseAddrLow+LengthLow最大值，此处初始化为0 .find_max_mem_area: mov eax,[ebx] ;eax用于遍历缓冲区中的每一个ards的BaseAddrLow add eax,[ebx+8] ;ebx+8获取的是LengthLow，故该代码计算的是BaseAddrLow+LengthLow add ebx,20 ;遍历下一个ards cmp edx,eax ;分支语句，如果edx大于等于eax，则跳转到.next_ards，也就是进入循环 jge .next_ards mov edx,eax ;否则就是更新edx .next_ards: loop .find_max_mem_area mov [total_mem_bytes],edx ;将最终结果保存到total_mem_bytes ;------------- 准备进入保护模式 ------------- ;1.打开A20 ;2.加载gdt ;3.置cr0的PE位为1 ;------------- 打开A20 ------------- in al,0x92 or al,0000_0010B out 0x92,al ;------------- 加载gdt ------------- lgdt [gdt_ptr] ;------------- 置cr0的PE位为1 ------------- mov eax,cr0 or eax,0x00000001 mov cr0,eax jmp dword SELECTOR_CODE:p_mode_start;刷新流水线 .error_hlt: hlt ;出错则挂起 [bits 32] p_mode_start: mov ax,SELECTOR_DATA ;初始化段寄存器，将数据段的选择子分别放入各段寄存器 mov ds,ax mov es,ax mov ss,ax mov esp,LOADER_STACK_TOP ;初始化栈指针，将栈指针地址放入bsp寄存器 mov ax,SELECTOR_VIDEO ;初始化显存段寄存器，显存段的选择子放入gs寄存器 mov gs,ax ;------------- 加载内核 ---------------- ;将内核从磁盘的9号扇区加载的内存的KERNEL_BIN_BASE_ADDR地址处 mov eax,KERNEL_START_SECTOR mov ebx,KERNEL_BIN_BASE_ADDR mov ecx,200 call rd_disk_m_32 ;------------- 开启分页机制 ------------- ;1.构建页表和页目录表 ;2.将页目录表的位置加载到控制寄存器cr3 ;3.置cr0寄存器的PG位为1，打开分页机制 call setup_page ;创建页目录表和页表，并初始化页内存位图 ;以下将各段描述符的基址迁移到虚拟内存空间中 mov ebx,[gdt_ptr+2] ;gdt_ptr+2表示GDT_BASE,也就是GDT的起始地址 or dword [ebx+0x18+4],0xc0000000 ;ebx中保存着GDT_BASE，0x18=24，故ebx+0x18表示取出显存段的起始地址 ;+4表示取出段描述符的高32位，之后和0xc0000000进行或操作 ;表示将显存段的起始地址增加了3G add dword [gdt_ptr+2],0xc0000000 ;同理将GDT_BASE的起始地址也增加3G add esp,0xc0000000 ;同理将esp栈指针的起始地址也增加3G mov eax,PAGE_DIR_TABLE_POS ;将页目录表的位置加载到控制寄存器cr3 mov cr3,eax mov eax,cr0 ;打开cr0的PG位，开启分页机制 or eax,0x80000000 mov cr0,eax lgdt [gdt_ptr] ;开启分页后，用gdt的新地址重新加载 ;------------- 进入内核函数 ---------------- enter_kernel: call kernel_init mov esp,0xc009f000 jmp KERNEL_ENTRY_POINT kernel_init: xor eax,eax xor ebx,ebx ;记录程序头表(段)地址 xor ecx,ecx ;记录程序头表(段头表)中程序头数量 xor edx,edx ;记录程序头表中每个条目的大小 mov dx,[KERNEL_BIN_BASE_ADDR+42] ;42字节处是e_phentsize，即程序头中每个条目的大小 mov ebx,[KERNEL_BIN_BASE_ADDR+28] ;28字节处是e_phoff，即程序头表的偏移 add ebx,KERNEL_BIN_BASE_ADDR ;程序头表的偏移加上内核在内存中的起始地址，就是程序头表的起始物理地址 mov cx,[KERNEL_BIN_BASE_ADDR+44] ;44字节处是e_phnum，即程序头表(段头表)中程序头数量 ;遍历段头表，取出程序中的每一个段，将其拷贝到对应的虚拟地址空间中 .each_segment: ;检查段头表中的段头是会否是空段(PT_NULL)，如果不是就将该段拷贝到对应区域，否则就继续遍历下一个段头 cmp byte [ebx+0],PT_NULL ;比较p_type是否等于PT_NULL，若相等说明程序头未使用 je .PTNULL ;若相等则跳转到.PTNULL ;为函数memcpy(dst,src,size)压入参数，参数依次从右向左压入，这样函数就可以从左到右取出参数 push dword [ebx+16] ;实参size，程序头表偏移16字节的地方p_filesz，本段在文件内的大小 mov eax,[ebx+4] ;程序头表偏移4字节的地方p_offset，本段在文件内的起始偏移 add eax,KERNEL_BIN_BASE_ADDR ;本段的偏移加上内核在内存中的起始地址，就是本段的物理地址 push eax ;实参src push dword [ebx+8] ;实参dst，p_vaddr，本段在内存中的起始虚拟地址 call mem_cpy add esp,12 ;回收mem_cpy的栈帧空间 .PTNULL: add ebx,edx ;指向下一个段头 loop .each_segment ;继续遍历段头表 ret ;逐字节拷贝函数，将esi指向的内存区域的size个字节拷贝到edi指向的区域 mem_cpy: cld ;指明拷贝时esi与edi的增长方向是向上的 push ebp ;保存ebp mov ebp,esp ;将esp指向ebp push ecx ;rep指令会用到ecx的循环计数，而外层函数也用到了ecx的值， ;因此此处需要将外层函数的ecx的值进行备份 mov edi,[ebp+8] ;参数dst mov esi,[ebp+12] ;参数src mov ecx,[ebp+16] ;参数size rep movsb ;rep(repeat)指令，重复执行movsb指令 ;movsb指令，s表示string，b表示byte， ;即将esi指向的内存拷贝一个字节给edi指向的内存 ;因此本条指令表示逐字节拷贝，拷贝的字节个数为ecx的值 pop ecx ;取出备份的值 pop ebp ;返回上层函数 ret ;------------- 创建页目录表和页表 ------------- ;初始化页目录表和页表 ;逐字节清空页目录表 setup_page: mov ecx,4096 ;页目录表的大小为4KB，ecx是loop指令的循环计数器 ;由于初始化页表是逐字节置0的，因此ecx的值为4096 mov esi,0 ;页目录表的偏移量 .clear_page_dir: mov byte [PAGE_DIR_TABLE_POS+esi],0 ;逐字节清空页目录表 ;其中PAGE_DIR_TABLE_POS为页目录表初始地址的宏 inc esi ;递增偏移量，清空下一个字节 loop .clear_page_dir ;初始化创建页目录表 .create_pde: mov eax,PAGE_DIR_TABLE_POS ;eax保存页目录表的起始地址 add eax,0x1000 ;0x1000为1k，故该代码的计算结果是将eax指向第一张页表的起始地址 mov ebx,eax ;ebx保存第一张页表的起始地址，后续会用到 or eax,PG_US_U|PG_RW_W|PG_P ;eax已经有了第一张页表的起始地址 ;此处再加上属性，即可表示为页目录表的一个表项， ;该表项代表的是第一张页表的物理地址及其相关属性 mov [PAGE_DIR_TABLE_POS+0x0],eax ;页目录表的第一个表项指向第一张页表 mov [PAGE_DIR_TABLE_POS+0xc00],eax ;0xc0000000即为3GB，由于我们划分的虚拟地址空间3GB以上为os地址空间 ;因此该语句是将3GB的虚拟空间映射到内核空间 ;而0xc00/4=768，也就是说页目录表的768号表项映射为物理内核空间 sub eax,0x1000 mov [PAGE_DIR_TABLE_POS+4092],eax ;最后一个页表项指向自己，为将来动态操作页表做准备 ;创建第一张页表的页表项，由于os的物理内存不会超过1M，故页表项个数的最大值为1M/4k=256 mov ecx,256 ;循环计数器 mov esi,0 ;偏移量 xor edx,edx ;第一个页表项指向物理空间的0~4KB物理页框 ;故记录的起始地址就是第一个页框的起始地址，也就是0 mov edx,PG_US_S|PG_RW_W|PG_P ;此时的edx表示拥有属性PG_US_S|PG_RW_W|PG_P ;且物理地址为0的物理页的页表项 .create_pte: mov [ebx+esi*4],edx ;此前ebx已经保存了第一张页表的起始地址 add edx,4096 ;edx指向下一个物理页（一个物理页4KB） inc esi ;esi指向页表的下一个偏移 loop .create_pte ; -------------------初始化页目录表769号-1022号项，769号项指向第二个页表的地址（此页表紧挨着上面的第一个页表），770号指向第三个，以此类推 mov eax,PAGE_DIR_TABLE_POS add eax,0x2000 ;此时的eax表示第二张页表的起始地址 or eax,PG_US_U|PG_RW_W|PG_P ;为eax表项添加属性 mov ebx,PAGE_DIR_TABLE_POS mov ecx,254 ;要设置254个页表项 mov esi,769 ;从第769个页表项开始设置 .create_kernel_pde: mov [ebx+esi*4],eax ; 设置页目录表项 inc esi ; 增加要设置的页目录表项的偏移 add eax,0x1000 ; eax指向下一个页表的位置，由于之前设定了属性，所以eax是一个完整的指向下一个页表的页目录表项 loop .create_kernel_pde ; 循环设定254个页目录表项 ret ; ------ 32位模式下从磁盘中加载文件到内存 ------ rd_disk_m_32: ;参数： ; eax=LBA扇区号 ; ebx=将数据写入的内存地址 ; ecx=读入的扇区数 mov esi,eax\t;备份eax mov di,cx\t;备份cx ;读写硬盘: ;第1步：选择特定通道的寄存器，设置要读取的扇区数 mov dx,0x1f2 mov al,cl out dx,al ;读取的扇区数 mov eax,esi\t;恢复ax ;第2步：在特定通道寄存器中放入要读取扇区的地址，将LBA地址存入0x1f3 ~ 0x1f6 ;LBA地址7~0位写入端口0x1f3 mov dx,0x1f3 out dx,al ;LBA地址15~8位写入端口0x1f4 mov cl,8 shr eax,cl mov dx,0x1f4 out dx,al ;LBA地址23~16位写入端口0x1f5 shr eax,cl mov dx,0x1f5 out dx,al shr eax,cl and al,0x0f\t;lba第24~27位 or al,0xe0\t; 设置7～4位为1110,表示lba模式 mov dx,0x1f6 out dx,al ;第3步：向0x1f7端口写入读命令，0x20 mov dx,0x1f7 mov al,0x20 out dx,al ;第4步：检测硬盘状态 .not_ready: ;同一端口，写时表示写入命令字，读时表示读入硬盘状态 nop in al,dx and al,0x88\t;第4位为1表示硬盘控制器已准备好数据传输，第7位为1表示硬盘忙 cmp al,0x08 jnz .not_ready\t;若未准备好，继续等。 ;第5步：从0x1f0端口读数据 mov ax, di ;di当中存储的是要读取的扇区数 mov dx, 256 ;每个扇区512字节，一次读取两个字节，所以一个扇区就要读取256次，与扇区数相乘，就等得到总读取次数 mul dx ;8位乘法与16位乘法知识查看书p133,注意：16位乘法会改变dx的值！！！！ mov cx, ax\t; 得到了要读取的总次数，然后将这个数字放入cx中 mov dx, 0x1f0 .go_on_read: in ax,dx mov [ebx],ax ;与rd_disk_m_16相比，就是把这两句的bx改成了ebx add ebx,2\t; 由于在实模式下偏移地址为16位,所以用bx只会访问到0~FFFFh的偏移。 ; loader的栈指针为0x900,bx为指向的数据输出缓冲区,且为16位， ; 超过0xffff后,bx部分会从0开始,所以当要读取的扇区数过大,待写入的地址超过bx的范围时， ; 从硬盘上读出的数据会把0x0000~0xffff的覆盖， ; 造成栈被破坏,所以ret返回时,返回地址被破坏了,已经不是之前正确的地址, ; 故程序出会错,不知道会跑到哪里去。 ; 所以改为ebx代替bx指向缓冲区,这样生成的机器码前面会有0x66和0x67来反转。 ; 0X66用于反转默认的操作数大小! 0X67用于反转默认的寻址方式. ; cpu处于16位模式时,会理所当然的认为操作数和寻址都是16位,处于32位模式时, ; 也会认为要执行的指令是32位. ; 当我们在其中任意模式下用了另外模式的寻址方式或操作数大小(姑且认为16位模式用16位字节操作数， ; 32位模式下用32字节的操作数)时,编译器会在指令前帮我们加上0x66或0x67， ; 临时改变当前cpu模式到另外的模式下. ; 假设当前运行在16位模式,遇到0X66时,操作数大小变为32位. ; 假设当前运行在32位模式,遇到0X66时,操作数大小变为16位. ; 假设当前运行在16位模式,遇到0X67时,寻址方式变为32位寻址 ; 假设当前运行在32位模式,遇到0X67时,寻址方式变为16位寻址. loop .go_on_read ret 编译运行\r/start.sh\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 #!/bin/bash # 设置工作目录和工具 BIN_DIR=$(pwd)/bin BOOT_DIR=$(pwd)/boot BOOT_INCLUDE_DIR=$BOOT_DIR/include/ KERNEL_DIR=$(pwd)/lib/kernel IMG=/home/minios/bochs/hd60M.img NASM=nasm GCC=gcc-4.4 LD=ld DD=dd # 目标文件 MBR_SRC=$BOOT_DIR/mbr.S LOADER_SRC=$BOOT_DIR/loader.S KERNEL_SRC=$KERNEL_DIR/main.c MBR_BIN=$BIN_DIR/mbr.bin LOADER_BIN=$BIN_DIR/loader.bin KERNEL_OBJ=$BIN_DIR/main.o KERNEL_BIN=$BIN_DIR/kernel.bin # 创建目录 echo \u0026#34;创建目标目录...\u0026#34; mkdir -p $BIN_DIR mkdir -p $BOOT_DIR # 编译 MBR echo \u0026#34;编译 MBR...\u0026#34; $NASM -I $BOOT_INCLUDE_DIR $MBR_SRC -o $MBR_BIN # 编译 Loader echo \u0026#34;编译 Loader...\u0026#34; $NASM -I $BOOT_INCLUDE_DIR $LOADER_SRC -o $LOADER_BIN # 编译内核 echo \u0026#34;编译内核...\u0026#34; $GCC $KERNEL_SRC -c -m32 -o $KERNEL_OBJ # 链接内核 echo \u0026#34;链接内核...\u0026#34; $LD -m elf_i386 -Ttext 0x00001500 -e main -o $KERNEL_BIN $KERNEL_OBJ # 创建启动镜像 echo \u0026#34;创建启动镜像...\u0026#34; $DD if=$MBR_BIN of=$IMG bs=512 count=1 conv=notrunc $DD if=$LOADER_BIN of=$IMG bs=512 count=4 seek=2 conv=notrunc $DD if=$KERNEL_BIN of=$IMG bs=512 count=200 seek=9 conv=notrunc # 完成 echo \u0026#34;构建完成！镜像文件已创建：$IMG\u0026#34; # 退出脚本 exit 0 ","date":"2024-12-13T00:00:00Z","image":"https://raw.githubusercontent.com/jl-sky/imageDatesets/master/2024/12/upgit_20241214_1734176213.jpg","permalink":"http://localhost:1313/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9C%9F%E8%B1%A1%E8%BF%98%E5%8E%9F%E7%AC%AC%E4%BA%94%E7%AB%A0%E4%BA%8C-%E5%8A%A0%E8%BD%BD%E5%86%85%E6%A0%B8/","title":"《操作系统真象还原》第五章（二）—— 加载内核"},{"content":"本章节所有代码托管在miniOS_32\n章节任务介绍\r内核的结构\r内核分为四个部分，分别是\n初始化代码：初始化代码用于从BIOS那里接管处理器和计算机硬件的控制权，安装最基本的段描述符，初始化最初的执行环境。然后，从硬盘上读取和加载内核的剩余部分，创建组成内核的各个内存段。 内核代码段：内核代码段用于分配内存，读取和加载用户程序，控制用户程序的执行。 内核数据段：内核数据段提供了一段可读写的内存空间，供内核自己使用。 公共例程段：公共例程段用于提供各种用途和功能的子过程以简化代码的编写。这些例程既可以用于内核，也供用户程序调用 因此，mbr程序和loader程序其实就是内核的初始化代码，负责完成加载内核前的初始化工作。\n上一节，我们在GDT中安装了四个最基本的段描述符（数据段、代码段、栈段、显存段），并完成了GDT的初始化。\n本章我们将继续对loader程序加以改造，在正式加载内核之前完成所有准备工作，本章节的工作主要是\n检测现有的实际物理内存 开启分页机制，让后续的内核在分页机制下工作 如何开启分页机制？ 构建页表和页目录表 将页目录表的位置加载到控制寄存器cr3 置cr0寄存器的PG位为1，打开分页机制 分页机制测试 我们在分页机制开启后重新使用显存段在屏幕上打印字符，如果能够正常显示说明分页机制成功开启 获取物理内存容量\r操作系统是计算机硬件的管家，它不仅要知道自己安装了哪些硬件，还得给出有效得当的管理措施,按照预定的一套管理策略使硬件资源得到合理的运用。但管理策略只是逻辑上的东西，真正干活的都是底层。\n保护模式最“大”的特点就是寻址空间“大”，在进入保护模式之后，我们将接触到虚拟内存、内存管理等。但这些和内存有关的概念都建立在物理内存之上。为了在后期做好内存管理工作，我们首先需要知道自己有多少物理内存才行。\nlinux内核获取物理内存的方式本质上是通过调用BIOS中断0x15实现的，分别是BIOS中断的0x15的3个子功能，子功能号要放在寄存器EAX或AX中，如下：\nEAX=0xE820:遍历主机上全部内存。 AX=0xE801:分别检测低15MB和16MB~4GB的内存，最大支持4GB AH=0x88:最多检测出64MB内存，实际内存超过此容量也按照64MB返回 本节我们主要使用BIOS中断的子功能0xE820获取内存\n利用BIOS中断的子功能0xE820获取内存\rBIOS中断0x15的子功能 0xE820能够获取系统的内存布局 由于系统内存各部分的类型属性不同,BIOS 就按照类型属性来划分这片系统内存，所以这种查询呈迭代式，每次BIOS只返回一种类型的内存信息，直到将所有内存类型返回完毕。 子功能0xE820的强大之处是返回的内存信息较丰富，包括多个属性字段，所以需要一种格式结构来组织这些数据。 内存信息的内容是用地址范围描述符来描述的，用于存储这种描述符的结构称之为地址范围描述符(Address Range Descriptor Structure，ARDS)。 此结构中的字段大小都是4字节,共5个字段,所以此结构大小为 20字节。**每次int 0x15之后，BIOS就返回这样一个结构的数据。**注意，ARDS结构中用64位宽度的属性来描述这段内存基地址(起始地址)及其长度，所以表中的基地址和长度都分为低32位和高32位两部分。\n其中的 Type 字段用来描述这段内存的类型，这里所谓的类型是说明这段内存的用途，即其是可以被操作系统使用，还是保留起来不能用。Type字段的具体意义见下\n为什么 BIOS会按类型来返回内存信息呢?原因是这段内存可能是\n系统的 ROM。 ROM 用到了这部分内存。 设备内存映射到了这部分内存。 由于某种原因，这段内存不适合标准设备使用。 另外\n由于我们在32位环境下工作，所以在ARDS结构属性中，我们只用到低32位属性。 BaseAddrLow+LengthLow 是一片内存区域上限，单位是字节。 正常情况下，不会出现较大的内存区域不可用的情况，除非安装的物理内存极其小。这意味着，在所有返回的 ARDS 结构里，此值最大的内存块一定是操作系统可使用的部分，即主板上配置的物理内存容量。\n0xe820调用说明\r以下是BIOS中断0x15子功能0xe820的调用参数\n代码目录结构\r1 2 3 4 5 6 7 . ├── include │ └── boot.inc //配置文件 ├── loader.S\t//loader程序代码 ├── Makefile\t//编译文件，可直接使用make进行编译代码 ├── mbr.S\t//mbr程序代码 └── start.sh\t//编译脚本，如果不想使用make编译代码，也可以选择运行该脚本编译代码，该脚本的编译命令更加清晰 代码\r调用步骤\n填写好“调用前输入”的寄存器 执行中断调用int 0x15 在CF位为0的情况下，获取对应的返回结果 遍历获取到的ards结构体，计算最大内存容量 loader.S\r上一节，我们为了测试loader程序在进入保护模式之前是在实模式下运行的，我们定义了一个loader_start函数进行测试，本节我们修改这个函数的实现，让其用于获取物理内存的代码\n需要注意的是，代码中最终获取到的物理内存会被存储到total_mem_bytes变量中，该变量的定义位置如下所示\n1 2 3 4 5 6 7 8 9 10 ;------------- 构建选择子 ------------- SELECTOR_CODE equ (0x0001\u0026lt;\u0026lt;3) + TI_GDT + RPL0 SELECTOR_DATA equ (0x0002\u0026lt;\u0026lt;3) + TI_GDT + RPL0 SELECTOR_VIDEO equ (0x0003\u0026lt;\u0026lt;3) + TI_GDT + RPL0 total_mem_bytes dd 0 ;total_mem_bytes用于保存最终获取到的内存容量，为4个字节 ;由于loader程序的加载地址为0x900，而loader.bin的文件头大小为0x200 ;（4个gdt段描述符（8B）加上60个dp（8B）填充字，故64*8=512B）， ;故total_mem_bytes在内存中的地址为0x900+0x200=0xb00 ;该地址将来在内核中会被用到 之所以将该变量定义在这里，是因为刚好经过计算后，该变量在内存中的地址是0xb00，由于该变量在后边也会被用到，因此将变量定义在这里方便后续使用\n以下是用于获取获取物理内存的代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 ;------------- 定义记录ARDS结构体信息的变量 ------------- ards_buf times 244 db 0 ;开辟一块缓冲区，用于记录返回的ARDS结构体， ;该定义语句事实上是定义了一个数组ards_buf[244] ;244是因为total_mem_bytes(4)+gdt_ptr(6)+244+ards_nr(2)=256,即0x100 ;这样loader_start的在文件内的偏移地址就是0x100+0x200=0x300 ards_nr dw 0 ;用于记录ards结构体数量 ;------------------------------------------ ;INT 0x15 功能号：0xe820 功能描述：获取内存容量，检测内存 ;------------------------------------------ ;输入： ;EAX:功能号，0xE820，但调用返回时eax会被填入一串ASCII值 ;EBX:ARDS后续值 ;ES:di:ARDS缓冲区，BIOS将获取到的内存信息存到此寄存器指向的内存，每次都以ARDS格式返回 ;ECX:ARDS结构的字节大小，20 ;EDX:固定为签名标记，0x534d4150 ;返回值 ;CF：若cf为0，表示未出错，cf为1，表示调用出错 ;EAX：字符串SMAP的ASCII码值，0x534d4150 ;ES:di:ARDS缓冲区，BIOS将获取到的内存信息存到此寄存器指向的内存，每次都以ARDS格式返回 ;ECX:ARDS结构的字节大小，20 ;EBX:ARDS后续值，即下一个ARDS的位置。 ;每次BIOS中断返回后，BIOS会更新此值，BIOS会通过此值找到下一个待返回的ARDS结构。 ;在cf位为0的情况下，若返回后的EBX值为0，表示这是最后一个ARDS结构 loader_start: xor ebx,ebx ;第一次调用时，要将ebx清空置为0，此处使用的是异或运算置0 mov edx,0x534d4150 mov di,ards_buf ;di存储缓冲区地址，即指向缓冲区首地址 .e820_mem_get_loop: mov eax,0x0000e820 mov ecx,20 ;一个ards结构体的大小 int 0x15 ;调用0x15中断函数，返回的ards结构体被返回给di指向的缓冲区中 add di,cx ;使di增加20字节指向缓冲区中下一个的ARDS结构位置 inc word [ards_nr] ;inc（increment增加）指令表示将内存中的操作数增加一，此处用于记录返回的ARDS数量 cmp ebx,0 ;比较ebx中的值是否为0 jnz .e820_mem_get_loop ;若ebx不为0，则继续进行循环获取ARDS， ;若为0说明已经获取到最后一个ards，则退出循环 mov cx,[ards_nr] ;cx存储遍历到的ards结构体个数 mov ebx,ards_buf ;ebx指向缓冲区地址 xor edx,edx ;EDX用于保存BaseAddrLow+LengthLow最大值，此处初始化为0 .find_max_mem_area: mov eax,[ebx] ;eax用于遍历缓冲区中的每一个ards的BaseAddrLow add eax,[ebx+8] ;ebx+8获取的是LengthLow，故该代码计算的是BaseAddrLow+LengthLow add ebx,20 ;遍历下一个ards cmp edx,eax ;分支语句，如果edx大于等于eax，则跳转到.next_ards，也就是进入循环 jge .next_ards mov edx,eax .next_ards: loop .find_max_mem_area mov [total_mem_bytes],edx 完整的loader程序代码如下所示\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 %include \u0026#34;boot.inc\u0026#34; SECTION loader vstart=LOADER_BASE_ADDR ;初始化栈指针地址 LOADER_STACK_TOP equ LOADER_BASE_ADDR ;------------- 构建gdt及其内部的描述符 ------------- GDT_BASE: dd 0x00000000 dd 0x00000000 ;代码段描述符的低4字节部分，其中高两个字节表示段基址的0~15位,在这里定义为0x0000 ;低两个字节表示段界限的0~15位，由于使用的是平坦模型，因此是0xFFFF CODE_DESC: dd 0x0000FFFF dd DESC_CODE_HIGH4;段描述符的高4字节部分 DATA_STACK_DESC: dd 0x0000FFFF dd DESC_DATA_HIGH4 ;定义显存段的描述符 ;文本模式下的适配器地址为0xb8000~0xbffff,为了方便显存操作，显存段不使用平坦模型 ;因此段基址为0xb8000,段大小为0xbffff-0xb8000=0x7fff, ;段粒度位4k，因此段界限的值为0x7fff/4k=7 VIDEO_DESC: dd 0x80000007 dd DESC_VIDEO_HIGH4 GDT_SIZE equ $-GDT_BASE GDT_LIMIT equ GDT_SIZE-1 times 60 dq 0 ;此处预留60个描述符的空位 ;------------- 构建选择子 ------------- SELECTOR_CODE equ (0x0001\u0026lt;\u0026lt;3) + TI_GDT + RPL0 SELECTOR_DATA equ (0x0002\u0026lt;\u0026lt;3) + TI_GDT + RPL0 SELECTOR_VIDEO equ (0x0003\u0026lt;\u0026lt;3) + TI_GDT + RPL0 total_mem_bytes dd 0 ;total_mem_bytes用于保存最终获取到的内存容量，为4个字节 ;由于loader程序的加载地址为0x900，而loader.bin的文件头大小为0x200 ;（4个gdt段描述符（8B）加上60个dp（8B）填充字，故64*8=512B）， ;故total_mem_bytes在内存中的地址为0x900+0x200=0xb00 ;该地址将来在内核中会被用到 ;------------- 定义gdtr（指向GDT的寄存器） ------------- gdt_ptr dw GDT_LIMIT dd GDT_BASE ards_buf times 244 db 0 ;开辟一块缓冲区，用于记录返回的ARDS结构体， ;该定义语句事实上是定义了一个数组ards_buf[244] ;244是因为total_mem_bytes(4)+gdt_ptr(6)+244+ards_nr(2)=256,即0x100 ;这样loader_start的在文件内的偏移地址就是0x100+0x200=0x300 ards_nr dw 0 ;用于记录ards结构体数量 ;------------------------------------------ ;INT 0x15 功能号：0xe820 功能描述：获取内存容量，检测内存 ;------------------------------------------ ;输入： ;EAX:功能号，0xE820，但调用返回时eax会被填入一串ASCII值 ;EBX:ARDS后续值 ;ES:di:ARDS缓冲区，BIOS将获取到的内存信息存到此寄存器指向的内存，每次都以ARDS格式返回 ;ECX:ARDS结构的字节大小，20 ;EDX:固定为签名标记，0x534d4150 ;返回值 ;CF：若cf为0，表示未出错，cf为1，表示调用出错 ;EAX：字符串SMAP的ASCII码值，0x534d4150 ;ES:di:ARDS缓冲区，BIOS将获取到的内存信息存到此寄存器指向的内存，每次都以ARDS格式返回 ;ECX:ARDS结构的字节大小，20 ;EBX:ARDS后续值，即下一个ARDS的位置。 ;每次BIOS中断返回后，BIOS会更新此值，BIOS会通过此值找到下一个待返回的ARDS结构。 ;在cf位为0的情况下，若返回后的EBX值为0，表示这是最后一个ARDS结构 loader_start: xor ebx,ebx ;第一次调用时，要将ebx清空置为0，此处使用的是异或运算置0 mov edx,0x534d4150 mov di,ards_buf ;di存储缓冲区地址，即指向缓冲区首地址 .e820_mem_get_loop: mov eax,0x0000e820 mov ecx,20 ;一个ards结构体的大小 int 0x15 ;调用0x15中断函数，返回的ards结构体被返回给di指向的缓冲区中 add di,cx ;使di增加20字节指向缓冲区中下一个的ARDS结构位置 inc word [ards_nr] ;inc（increment增加）指令表示将内存中的操作数增加一，此处用于记录返回的ARDS数量 cmp ebx,0 ;比较ebx中的值是否为0 jnz .e820_mem_get_loop ;若ebx不为0，则继续进行循环获取ARDS， ;若为0说明已经获取到最后一个ards，则退出循环 mov cx,[ards_nr] ;cx存储遍历到的ards结构体个数 mov ebx,ards_buf ;ebx指向缓冲区地址 xor edx,edx ;EDX用于保存BaseAddrLow+LengthLow最大值，此处初始化为0 .find_max_mem_area: mov eax,[ebx] ;eax用于遍历缓冲区中的每一个ards的BaseAddrLow add eax,[ebx+8] ;ebx+8获取的是LengthLow，故该代码计算的是BaseAddrLow+LengthLow add ebx,20 ;遍历下一个ards cmp edx,eax ;分支语句，如果edx大于等于eax，则跳转到.next_ards，也就是进入循环 jge .next_ards mov edx,eax .next_ards: loop .find_max_mem_area mov [total_mem_bytes],edx ;------------- 准备进入保护模式 ------------- ;1.打开A20 ;2.加载gdt ;3.置cr0的PE位为1 ;------------- 打开A20 ------------- in al,0x92 or al,0000_0010B out 0x92,al ;------------- 加载gdt ------------- lgdt [gdt_ptr] ;------------- 置cr0的PE位为1 ------------- mov eax,cr0 or eax,0x00000001 mov cr0,eax jmp dword SELECTOR_CODE:p_mode_start;刷新流水线 .error_hlt: hlt ;出错则挂起 [bits 32] p_mode_start: mov ax,SELECTOR_DATA ;初始化段寄存器，将数据段的选择子分别放入各段寄存器 mov ds,ax mov es,ax mov ss,ax mov esp,LOADER_STACK_TOP ;初始化栈指针，将栈指针地址放入bsp寄存器 mov ax,SELECTOR_VIDEO ;初始化显存段寄存器，显存段的选择子放入gs寄存器 mov gs,ax mov byte [gs:160],\u0026#39;p\u0026#39; jmp $ mbr.S\r注意，loader.S程序真正的代码执行位置是loader_start，该标号在内存中的物理位置是经过作者手工设计的\n设计原理是这样的\n构建GDT占据了512B（0x200） 定义gdtr（指向GDT基址的寄存器）占据了6B 定义total_mem_bytes（记录物理内存的实际容量）占据了4B 定义ards_nr（记录ards结构体数量）占据了2B 定义ards_buf（记录返回的ARDS结构体）占据244B 故loader_start在内存中的地址为：0x900+512B+256B（6+4+2+244）=0x900+0x300=0xc00 1 2 3 4 5 6 7 8 9 10 11 ;------------- 定义gdtr（指向GDT的寄存器） ------------- gdt_ptr dw GDT_LIMIT dd GDT_BASE ;------------- 定义记录ARDS结构体信息的变量 ------------- ards_buf times 244 db 0 ;开辟一块缓冲区，用于记录返回的ARDS结构体， ;该定义语句事实上是定义了一个数组ards_buf[244] ;244是因为total_mem_bytes(4)+gdt_ptr(6)+244+ards_nr(2)=256,即0x100 ;这样loader_start的在文件内的偏移地址就是0x100+0x200=0x300 ards_nr dw 0 ;用于记录ards结构体数量 所以我们需要修改mbr中loader的加载地址，即\n1 jmp LOADER_BASE_ADDR+0x300; 其余与上节相同，完整的mbr程序代码如下所示\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 ;主引导程序MBR，由BIOS通过jmp 0:0x7c00跳转 ;------------------------------------------ %include \u0026#34;boot.inc\u0026#34; ;vstart=0x7c00表示本程序在编译时，起始地址编译为0x7c00 SECTION MBR vstart=0x7c00 ;使用通用寄存器中的值（0）初始化其余寄存器 mov ax,cs mov ds,ax mov es,ax mov ss,ax mov fs,ax ;初始化栈指针 mov sp,0x7c00 ;存入显存的段基址 mov ax,0xb800 mov gs,ax ;------------------------------------------ ;------------------------------------------ ;利用0x06号功能进行清屏 ;INT 0x10 功能号：0x06 功能描述：上卷窗口清屏 ;输入: ;AH 功能号：0x06 ;AL=上卷的行数（如果为0，则表示全部） ;BH=上卷的行属性 ;(CL,CH)=窗口左上角(X,Y)位置 ;(DL,DH)=窗口右下角(X,Y)位置 ;返回值 ;无返回值 mov ax,0x0600 mov bx,0x0700 mov cx,0 ;左上角(0,0) mov dx,0x184f ;右下角(80,25) ;0x18=24，0x4f=79 int 0x10 ;调用BIOS中断函数 ;------------------------------------------ ;------------------------------------------ ;将要显示的字符串写入到显存中 mov byte [gs:0x00],\u0026#39;1\u0026#39;;在第一个字节的位置写入要显示的字符“1” ;在第二个字节的位置写入显示字符（也就是字符1）的属性，其中A表示绿色背景，4表示前景色为红色 mov byte [gs:0x01],0xA4 mov byte [gs:0x02],\u0026#39; \u0026#39; mov byte [gs:0x03],0xA4 mov byte [gs:0x04],\u0026#39;M\u0026#39; mov byte [gs:0x05],0xA4 mov byte [gs:0x06],\u0026#39;B\u0026#39; mov byte [gs:0x07],0xA4 mov byte [gs:0x08],\u0026#39;R\u0026#39; mov byte [gs:0x09],0xA4 mov eax,LOADER_START_SECTOR;起始扇区地址 mov bx,LOADER_BASE_ADDR;要写入的内存地址 mov cx,4;待读入的扇区数目 call rd_disk_m16;调用磁盘读取程序 jmp LOADER_BASE_ADDR+0x300; ;------------------------------------------ ;函数功能：读取硬盘的n个扇区 ;参数： ;eax：LBA扇区号 ;bx：要写入的内存地址 ;cx：待读入的扇区数目 rd_disk_m16: ;out命令，通过端口向外围设备发送数据 ;其中目的操作数可以是8为立即数或者寄存器DX,源操作数必须是寄存器AL或者AX ;因此需要将之前ax中保存的值进行备份 mov esi,eax mov di,cx ;正式读写硬盘 ;第一步：设置要读取的扇区数目 mov dx,0x1f2 mov ax,cx out dx,ax mov eax,esi;恢复eax的值 ;第二步：将LBA的地址存入0x1f3~0x1f6 ;LBA的0~7位写入端口0x1f3 mov dx,0x1f3 out dx,al ;LBA的8~15位写入端口0x1f4 mov cl,8 shr eax,cl;ax左移8位 mov dx,0x1f4 out dx,al ;LBA的16~23位写入端口0x1f5 shr eax,cl mov dx,0x1f5 out dx,al ;LBA的24~27位写入端口0x1f6 shr eax,cl;左移8位 and al,0x0f;与0000 1111相与，取后四位 or al,0xe0;设置7~4位为1110，表示lba模式 mov dx,0x1f6 out dx,al ;第三步，向0x1f7端口写入读命令，0x20 mov dx,0x1f7 mov al,0x20 out dx,al ;第四步，检测硬盘状态 .not_ready: nop;空操作，什么也不做，相当于sleep，只是为了增加延迟 in al,dx;由于读取硬盘状态信息的端口仍旧是0x1f7，因此不需要再为dx指定端口号 ;取出状态位的第3位和第7位 ;其中第3位若为1表示硬盘控制器已经准备好数据传输,第7位为1表示硬盘忙 and al,0x88 ;cmp为减法指令，此处是为了判断第7位是否为1，如果为1，则减法的结果应该为0 cmp al,0x08 ;JNZ是条件跳转指令，它表示\u0026#34;Jump if Not Zero\u0026#34;， ;也就是如果零标志位（ZF）不为0，则进行跳转。否则不进行跳转 jnz .not_ready;若未准备好，则继续等 ;第五步，从0x1f0端口读取数据 mov ax,di;di是之前备份的要读取的扇区数 mov dx,256 ;mul指令表示乘法操作，当只有一个操作数时，被乘数隐含在al或者ax中 mul dx;一个扇区512字节，每次读取两个字节，需要读取di*256次 mov cx,ax;cx在此时表示要循环读取的次数 mov dx,0x1f0 .go_on_read: in ax,dx mov [bx],ax;通过循环将输入写入bx寄存器所指向的内存，每次读入2个字节的数据 add bx,2 loop .go_on_read ret times 510-($-$$) db 0 db 0x55,0xaa 编译\r1 2 3 4 nasm -I ./include/ ./mbr.S -o mbr.bin nasm -I ./include/ ./loader.S -o loader.bin dd if=/home/minios/osCode/miniOS_32/ch4/mbr.bin of=/home/minios/bochs/hd60M.img bs=512 count=1 conv=notrunc dd if=/home/minios/osCode/miniOS_32/ch4/loader.bin of=/home/minios/bochs/hd60M.img bs=512 count=2 seek=2 conv=notrunc 运行\r我们首先看看我们的物理机上装载的内存容量，然后再运行我们的代码，测试我们检测出的物理内存是否正确\n在bochs安装位置处运行以下代码查看物理机装载的内存容量\n1 cat -n boot.disk | grep meg 可以看到，机器上装了32MB内存。megs指定的内存以MB为单位\n1 2 minios@robot:~/bochs$ cat -n boot.disk | grep meg 2 megs: 32 接下来验证我们的代码的正确性，是否可以检测出来这段32MB的内存容量\n1 ./bin/bochs -f boot.disk 运行上述命令\n出现[6]直接按下回车 继续按下c，出现如下界面 这是我们之前的实验结果\n接下来按下ctrl+c，不要退出，在终端输入\n1 xp 0xb00 其中，xp命令表示查看内存内容，0xb00是我们在代码中设计的变量total_mem_bytes的地址，total_mem_bytes保存了代码最终计算的结果，如下所示\n1 2 3 \u0026lt;bochs:2\u0026gt; xp 0xb00 [bochs]: 0x00000b00 \u0026lt;bogus+ 0\u0026gt;: 0x02000000 如上所示，在执行 xp 0xb00后，结果是 0x02000000。0x2000000 换算成十进制正是 32MB，可见检测结果是正确的。\n至此，我们的内存分布图如下所示\n分页机制概述\r为什么要分页\r在说分页机制之前，我们先回顾一下内存的分段模式\n如图所示，在处理器中有负责分段管理的段部件。\n每个程序或任务都有自己的段，这些段都用段描述符定义。 随着程序的执行，当要访问内存时，就用段地址加上偏移量，段部件就会输出一个线性地址。 在单纯的分段模式下，线性地址就是物理地址。 正如图中所示\n描述符中的段基地址为0x002000C0，界限值为0x2007。 因为段的粒度是字节，故该段的长度为8200字节。 当访问内存时，用段基地址0x002000C0加上段内偏移量0x1008，段部件就会形成线性地址0x002010C8，这也是物理地址。 那么在这种内存管理机制下，会有什么问题呢？\n我们首先看一个场景，如下图所示模拟了多个进程并行的情况\n初始时，系统里有3个进程正在运行，进程 A、B、C各占了 10MB、20MB、30MB的内存空间，还剩下15MB 可用。 假设此时进程B已经运行结束，腾出了20MB的内存，可是待加载运行的进程D需要20MB+3KB的内存空间，即20483KB。 现在的运行环境未开启分页功能,“段基址+段内偏移”产生的线性地址就是物理地址，程序中引用的线性地址是连续的，所以物理地址也连续。 虽然总共剩下35MB 内存可用，但是现在连续的内存块只有原来进程B的20MB和最下面可用内存15MB，每一块都不够进程D用，这就是内存的外部碎片 针对上述场景中出现的问题，此时可有两个解决方案\n等待进程C运行完后腾出内存，这样连续可用的内存就够运行进程D了。 将进程A的段A3或进程C的段C1换出到硬盘上，腾出一部分空间，加上邻接的20MB，足够容纳进程D。 显然方案二的效果是更好的，我们将老进程不常用的段换出到硬盘，腾出空间给新进程用，等老进程再次需要该段时，再从硬盘上将该段载入内存，如图所示\n第二个方法虽然解决了内存不足的问题，但也有缺陷\n比如物理内存特别小，无法容纳任何一个进程的段，这就没法运行进程了，更没法做段的换入换出。 另外一种情况是若进程的段比较大，换出时要将整个段全部搬到外存上，这种I0操作太多了机器响应奇慢无比，用户是无法接受的。 出现这种问题的本质在于\n在目前只分段的机制下，CPU 认为线性地址等于物理地址。 而线性地址是由编译器编译出来的，它本身是连续的，所以物理地址也必须要连续才行，但我们可用的物理地址不连续。 分页机制概述\r针对以上问题，出现了分页机制\n分页机制的思想是:通过映射，使连续的线性地址与任意物理内存地址相关联，逻辑上连续的线性地址其对应的物理地址可以不连续。\n分页机制的作用有两方面\n将线性地址转换成物理地址 用大小相等的页代替大小不等的段。 由于有了线性地址到真实物理地址的这层映射，经过段部件输出的线性地址便有了另外一个名字，虚拟地址，因此，分页机制是建立在分段机制上的。\n分页机制本质上是将大小不同的大内存段拆分成大小相等的小内存块\n那么我们要如何对内存进行分页呢？\n假如我们将4GB的内存空间划分成 4G个内存块，那么每个内存块大小是1字节，一共4G个内存块，也就是4G个页表项。 页表也是存储在内存中的，为了表示 32位地址，每个页表项必须要4字节，若按此方案，光是页表就要占4B*4G=16GB的内存，显然是不合理的。 因此，为了节省页表空间，我们需要将划分的单个内存块的尺寸变大，这样内存块数量变小，从而减少了页表项数量。\n如下所示，若滑块指向第12位，内存块大小则为2的12次方，即4KB，内存块数量则为2的20次方，1M，即1048576个。这里所说的内存块，其官方名称是页，CPU中采用的页大小恰恰就是4KB，也就是图5-10中滑块的落点处。\n页是地址空间的计量单位，并不是专属物理地址或线性地址，只要是4KB的地址空间都可以称为页，所以线性地址的一页也要对应物理地址的一页。 一页大小为4KB，所以4GB 地址空间被划分成 4GB/4KB=1M个页，也就是 4GB 空间中可以容纳1048576个页，页表中自然也要有 1048576个页表项。这就是我们要说的一级页表。 分页机制下的地址转换\r一个页表项对应一个页 线性地址的高20位作为页表项的索引，每个页表项要占用4字节大小，所以这高 20位的索引乘以4后才是该页表项相对于页表物理地址的字节偏移量。 cr3 寄存器中存放着的页表的物理地址，加上页表项的偏移量便是该页表项的物理地址，从而得到该页表项中映射的物理页地址 然后用线性地址的低12位与该物理页地址相加，所得的地址之和便是最终要访问的物理地址。 如上图所示，我们以指令 mov ax,[0x1234]为例\n假设在平坦模型下工作，不管段选择子值是多少，其所指向的段基址都是0 指令mov ax,[0x1234]中的 0x1234称为有效地址，它作为“段基址:段内偏移地址”中的段内偏移地址。 这样段基址为0，段内偏移地址为0x1234，经过段部件处理后，输出的线性地址是0x1234。 当线性地址 0x1234被送入页部件，页部件分析 0x1234的高20位，用十六进制表示高20位是0x00001。 然后将此项作为页表项索引，再将该索引乘以4后加上 cr3 寄存器中页表的物理地址，这样便得到索引所指代的页表项的物理地址 再从该物理地址处(页表项中)读取所映射的物理页地址:0x9000。 线性地址的低12位是0x234，它作为物理页的页内偏移地址与物理页地址0x9000相加，和为0x9234，这就是线性地址0x1234最终转换成的物理地址。 二级页表\r前面所述的地址转换都是一级页表的过程，那么为什么有了一级页表还要有二级页表呢？\n(1)一级页表中最多可容纳1M(1048576)个页表项，每个页表项是4字节，如果页表项全满的话，便是 4MB 大小。\n(2)一级页表中所有页表项必须要提前建好，原因是操作系统要占用4GB虚拟地址空间的高1GB用户进程要占用低 3GB。\n(3)每个进程都有自己的页表，进程一多，光是页表占用的空间就很可观了。\n归根结底，我们要解决的是:不要一次性地将全部页表项建好，需要时动态创建页表项\n无论是几级页表，标准页的尺寸都是4KB，这一点是不变的。\n4GB线性地址空间最多有1M个标准页。一级页表是将这1M个标准页放置到一张页表中，二级页表是将这1M个标准页平均放置1K个页表中。每个页表中包含有1K个页表项。页表项是4字节大小，页表包含1K个页表项，故页表大小为4KB，这恰恰是一个标准页的大小。\n拆分出了这么多个页表，如何使用它们呢?为此，专门有个页目录表来存储这些页表。\n每个页表的物理地址在页目录表中都以页目录项(Page DirectoryEntry， PDE)的形式存储，页目录项大小同页表项一样，都用来描述一个物理页的物理地址，其大小都是4字节，而且最多有1024个页表，所以页目录表也是4KB大小，同样也是标准页的大小。页表是用于管理内存的数据结构，其也要占用内存，所以页目录表和页表所占用的物理页，同样混迹于物理内存之中\n每个任务都有自己的页目录表和页表。在处理器内部，有一个控制寄存器CR3，存放着当前任务的页目录表的物理地址，故又叫作页目录基址寄存器(Page Directory Base Register,PDBR)。\n每个任务都有自己的任务状态段(TSS)，它是任务的标志性结构，存放了和任务相关的各种数据，其中就包括了CR3寄存器域，存放了任务自己的页目录表物理地址。当任务切换时，处理器切换到新任务开始执行，而CR3的内容也被更新，以指向新任务的页目录表。相应的，页目录又指向一个个的页表，这就使得每个任务都只在自己的地址空间内运行。\n二级页表的地址转换过程同一级页表是相同的\n如图所示，在处理器内部，页部件将段部件送来的32位线性地址截成3段，分别是高10位、中间10位和低12位。\n高10位是页目录的索引 中间10位是页表的索引 低12位则作为页内偏移来用 当前任务页目录的物理地址在处理器的寄存器CR3中，假设它的内容为0x00005000。\n段管理部件输出的线性地址是0x00801050，其二进制的形式为0000 0000 1000 0000 0001 0000 0101 0000\n在这里，\n高10位为0000000010，也就是十六进制的0x002，它是页目录表内的索引，处理器将它乘以4（因为每个目录项为4字节），作为偏移量访问页目录。最终，处理器从物理地址00005008处取得页表的物理地址0x08001000。 线性地址的中间10位为二进制的0000000001，即0x001，处理器要用它作为页表内的索引来取得页的物理地址。处理器将该索引值乘以4，作为偏移量访问页表。 最终，处理器又从物理地址08001004处取得页的物理地址，这就是我们一直努力寻找的那个页。 开启分页机制\r分页机制启动步骤\r准备页目录表和页表 将页表地址写入控制寄存器cr3 寄存器cr0的PG位置为1 页目录项与页表项\rP，表示存在位 1表示该页位于物理内存中 RW：读写位 1表示可读可写 0表示可读不可写 US：表示普通用户/系统用户 1，处于user级别，任意级别（1，2，3，4）特权的程序都可以访问该页 0，处于supervisor级别，只允许特权级位（1,2,3）的程序可以访问 PWT：页级通写位 1,表示此项采用通写方式表示该页不仅是普通内存，还是高速缓存。此项和高速缓存有关,“通写”是高速缓存的一种工作方式本位用来间接决定是否用此方式改善该页的访问效率。 PCD:页级高速缓存禁止位 1表示该页启用高速缓存 0表示该页禁用高速缓存 A：访问位 1表示该页已经被CPU访问过了 D：脏页位 当CPU对一个页面进行写操作时，就会将对应页表项D位置为1 此项仅对页表项有效，并不会修改页目录项中的D位 PAT：页属性表位 G，全局位 1表示该页为全局页，也就是该页将在TLB高速缓存中一直存在 0表示该页不是全局页 AVL：可用位，操作系统是否可用 控制寄存器cr3\r用途：存储页目录表基址物理位置，又称页目录基址寄存器PDBR\n内存规划\r虚拟空间共4G\n3GB ~ 4GB：操作系统\n0 ~ 3GB：用户进程自己的虚拟地址空间\n以下是虚拟内存和物理内存的逻辑映射关系\n页目录表的位置：0x100000 第一个页表位置：0x101000 以下是内核需要的页目录表在物理内存中的存放位置，以及虚拟空间3GB ~ 4GB需要的页表在物理内存中的位置\n以下是虚拟内存与物理内存的实际映射关系\n代码目录结构\r1 2 3 4 5 6 7 . ├── include │ └── boot.inc //配置文件 ├── loader.S\t//loader程序代码 ├── Makefile\t//编译文件，可直接使用make进行编译代码 ├── mbr.S\t//mbr程序代码 └── start.sh\t//编译脚本，如果不想使用make编译代码，也可以选择运行该脚本编译代码，该脚本的编译命令更加清晰 代码\rboot.inc\r在配置文件中添加页目录表和页表的相关信息\n1 2 3 4 5 6 7 8 9 10 PAGE_DIR_TABLE_POS equ 0x100000 ;页目录表基址 ;----- 模块化的页目录表字段 --------- PG_P equ 1b PG_RW_R equ 00b PG_RW_W equ 10b PG_US_S equ 000b PG_US_U equ 100b 完整boot.inc代码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 ;-----loader and kernel----- LOADER_BASE_ADDR equ 0x900 ;loader在内存中位置 LOADER_START_SECTOR equ 0x2 ;loader在磁盘中的逻辑扇区地址，即LBA地址 LOADER_STACK_TOP equ LOADER_BASE_ADDR ;初始化栈指针地址 PAGE_DIR_TABLE_POS equ 0x100000 ;页目录表基址 ;----- gdt描述符属性 --------- DESC_G_4K equ 1_00000000000000000000000b ;设置段界限的单位为4KB DESC_D_32 equ 1_0000000000000000000000b ;设置代码段/数据段的有效地址（段内偏移地址）及操作数大小为32位 DESC_L equ 0_000000000000000000000b ;64位代码段标记位，现在是32位操作系统，因此标记为0即可。 DESC_AVL equ 0_00000000000000000000b ;定义段界限位 ;段界限的第2部分，即描述符的高32位中的第16~19位，最终的代码段段界限为0xFFFFF DESC_LIMIT_CODE2 equ 1111_0000000000000000b ;定义代码段要用的段描述符高32位中16~19段界限为全1 DESC_LIMIT_DATA2 equ DESC_LIMIT_CODE2 ;定义数据段要用的段描述符高32位中16~19段界限为全1 DESC_LIMIT_VIDEO2 equ 0000_000000000000000b ;定义我们要操作显存时对应的段描述符的高32位中16~19段界限为全0 DESC_P equ 1_000000000000000b ;定义了段描述符中的P标志位，表示该段描述符指向的段是否在内存中 ;定义描述符的特权级别位 DESC_DPL_0 equ 00_0000000000000b DESC_DPL_1 equ 01_0000000000000b DESC_DPL_2 equ 10_0000000000000b DESC_DPL_3 equ 11_0000000000000b ;定义类型位 DESC_S_CODE equ 1_000000000000b ;代码段和数据段都是非系统段，故类型字段s设置为1 DESC_S_DATA equ DESC_S_CODE ;代码段和数据段都是非系统段，故类型字段s设置为1 DESC_S_sys equ 0_000000000000b ;系统段的类型字段设置为0 ;定义子类型位 DESC_TYPE_CODE equ 1000_00000000b ;x=1,c=0,r=0,a=0 代码段是可执行的，非一致性，不可读，已访问位a清0 DESC_TYPE_DATA equ 0010_00000000b ;x=0,e=0,w=1,a=0，数据段不可执行，向上扩展，可写，已访问位a清0 ;拼接代码段的描述符 DESC_CODE_HIGH4 equ (0x00\u0026lt;\u0026lt;24) + DESC_G_4K \\ + DESC_D_32 + DESC_L + \\ DESC_AVL + DESC_LIMIT_CODE2 + DESC_P + DESC_DPL_0 + \\ DESC_S_CODE + DESC_TYPE_CODE + 0x00 ;拼接数据段的描述符 DESC_DATA_HIGH4 equ (0x00\u0026lt;\u0026lt;24) + DESC_G_4K \\ + DESC_D_32 + DESC_L + \\ DESC_AVL + DESC_LIMIT_DATA2 + DESC_P + DESC_DPL_0 + \\ DESC_S_DATA + DESC_TYPE_DATA + 0x00 ;拼接显存段的描述符位 DESC_VIDEO_HIGH4 equ (0x00\u0026lt;\u0026lt;24) + DESC_G_4K \\ + DESC_D_32 + DESC_L + \\ DESC_AVL + DESC_LIMIT_VIDEO2 + DESC_P + DESC_DPL_0 + \\ DESC_S_DATA + DESC_TYPE_DATA + 0x0b ;----- 选择子属性 --------- RPL0 equ 00b RPL1 equ 01b RPL2 equ 10b RPL3 equ 11b TI_GDT equ 000b TI_LDT equ 100b ;----- 模块化的页目录表字段 --------- PG_P equ 1b PG_RW_R equ 00b PG_RW_W equ 10b PG_US_S equ 000b PG_US_U equ 100b ;----- 程序段的类型定义 --------- PT_NULL equ 0 创建页表和页目录表\r为了让3GB ~ 4GB的虚拟内存空间映射到物理内核空间0 ~ 1MB，需要将二级页表的768号页目录项（0xc00/4）指向第一个一级页表的页表项，因为第一个一级页表的页表项管理着物理空间的0 ~ 4KB 由于mbr程序最开始会在实模式下加载loader程序，而loader程序的加载地址为0x900（实际执行代码的地址为0xc00），这是由一级页表的第一个页表项管理的物理空间，因此为了能够让mbr跨越实模式加载loader，还需要让二级页表的第一个页表项指向一级页表的第一个页表项 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 ;------------- 创建页目录表和页表 ------------- ;初始化页目录表和页表 ;逐字节清空页目录表 setup_page: mov ecx,4096 ;页目录表的大小为4KB，ecx是loop指令的循环计数器 ;由于初始化页表是逐字节置0的，因此ecx的值为4096 mov esi,0 ;页目录表的偏移量 .clear_page_dir: mov byte [PAGE_DIR_TABLE_POS+esi],0 ;逐字节清空页目录表 ;其中PAGE_DIR_TABLE_POS为页目录表初始地址的宏 inc esi ;递增偏移量，清空下一个字节 loop .clear_page_dir ;初始化创建页目录表 .create_pde: mov eax,PAGE_DIR_TABLE_POS ;eax保存页目录表的起始地址 add eax,0x1000 ;0x1000为1k，故该代码的计算结果是将eax指向第一张页表的起始地址 mov ebx,eax ;ebx保存第一张页表的起始地址，后续会用到 or eax,PG_US_U|PG_RW_W|PG_P ;eax已经有了第一张页表的起始地址 ;此处再加上属性，即可表示为页目录表的一个表项， ;该表项代表的是第一张页表的物理地址及其相关属性 mov [PAGE_DIR_TABLE_POS+0x0],eax ;页目录表的第一个表项指向第一张页表 mov [PAGE_DIR_TABLE_POS+0xc00],eax ;0xc0000000即为3GB，由于我们划分的虚拟地址空间3GB以上为os地址空间 ;因此该语句是将3GB的虚拟空间映射到内核空间 ;而0xc00/4=768，也就是说页目录表的768号表项映射为物理内核空间 sub eax,0x1000 mov [PAGE_DIR_TABLE_POS+4092],eax ;最后一个页表项指向自己，为将来动态操作页表做准备 ;创建第一张页表的页表项，由于os的物理内存不会超过1M，故页表项个数的最大值为1M/4k=256 mov ecx,256 ;循环计数器 mov esi,0 ;偏移量 xor edx,edx ;第一个页表项指向物理空间的0~4KB物理页框 ;故记录的起始地址就是第一个页框的起始地址，也就是0 mov edx,PG_US_S|PG_RW_W|PG_P ;此时的edx表示拥有属性PG_US_S|PG_RW_W|PG_P ;且物理地址为0的物理页的页表项 .create_pte: mov [ebx+esi*4],edx ;此前ebx已经保存了第一张页表的起始地址 add edx,4096 ;edx指向下一个物理页（一个物理页4KB） inc esi ;esi指向页表的下一个偏移 loop .create_pte ; -------------------初始化页目录表769号-1022号项，769号项指向第二个页表的地址（此页表紧挨着上面的第一个页表），770号指向第三个，以此类推 mov eax,PAGE_DIR_TABLE_POS add eax,0x2000 ;此时的eax表示第二张页表的起始地址 or eax,PG_US_U|PG_RW_W|PG_P ;为eax表项添加属性 mov ebx,PAGE_DIR_TABLE_POS mov ecx,254 ;要设置254个页表项 mov esi,769 ;从第769个页表项开始设置 .create_kernel_pde: mov [ebx+esi*4],eax ; 设置页目录表项 inc esi ; 增加要设置的页目录表项的偏移 add eax,0x1000 ; eax指向下一个页表的位置，由于之前设定了属性，所以eax是一个完整的指向下一个页表的页目录表项 loop .create_kernel_pde ; 循环设定254个页目录表项 ret 开启分页机制\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 [bits 32] p_mode_start: mov ax,SELECTOR_DATA ;初始化段寄存器，将数据段的选择子分别放入各段寄存器 mov ds,ax mov es,ax mov ss,ax mov esp,LOADER_STACK_TOP ;初始化栈指针，将栈指针地址放入bsp寄存器 mov ax,SELECTOR_VIDEO ;初始化显存段寄存器，显存段的选择子放入gs寄存器 mov gs,ax call setup_page ;创建页目录表和页表，并初始化页内存位图 mov ebx,[gdt_ptr+2] ;gdt_ptr+2表示GDT_BASE,也就是GDT的起始地址 or dword [ebx+0x18+4],0xc0000000 ;ebx中保存着GDT_BASE，0x18=24，故ebx+0x18表示取出显存段的起始地址 ;+4表示取出段描述符的高32位，之后和0xc0000000进行或操作 ;表示将显存段的起始地址增加了3G add dword [gdt_ptr+2],0xc0000000 ;同理将GDT_BASE的起始地址也增加3G add esp,0xc0000000 ;同理将esp栈指针的起始地址也增加3G mov eax,PAGE_DIR_TABLE_POS mov cr3,eax mov eax,cr0 ;打开cr0的PG位 or eax,0x80000000 mov cr0,eax lgdt [gdt_ptr] ;开启分页后，用gdt的新地址重新加载 mov byte [gs:160],\u0026#39;V\u0026#39; jmp $ 完整loader\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 %include \u0026#34;boot.inc\u0026#34; SECTION loader vstart=LOADER_BASE_ADDR ;初始化栈指针地址 LOADER_STACK_TOP equ LOADER_BASE_ADDR ;------------- 构建gdt及其内部的描述符 ------------- GDT_BASE: dd 0x00000000 dd 0x00000000 ;代码段描述符的低4字节部分，其中高两个字节表示段基址的0~15位,在这里定义为0x0000 ;低两个字节表示段界限的0~15位，由于使用的是平坦模型，因此是0xFFFF CODE_DESC: dd 0x0000FFFF dd DESC_CODE_HIGH4;段描述符的高4字节部分 DATA_STACK_DESC: dd 0x0000FFFF dd DESC_DATA_HIGH4 ;定义显存段的描述符 ;文本模式下的适配器地址为0xb8000~0xbffff,为了方便显存操作，显存段不使用平坦模型 ;因此段基址为0xb8000,段大小为0xbffff-0xb8000=0x7fff, ;段粒度位4k，因此段界限的值为0x7fff/4k=7 VIDEO_DESC: dd 0x80000007 dd DESC_VIDEO_HIGH4 GDT_SIZE equ $-GDT_BASE GDT_LIMIT equ GDT_SIZE-1 times 60 dq 0 ;此处预留60个描述符的空位 ;------------- 构建选择子 ------------- SELECTOR_CODE equ (0x0001\u0026lt;\u0026lt;3) + TI_GDT + RPL0 SELECTOR_DATA equ (0x0002\u0026lt;\u0026lt;3) + TI_GDT + RPL0 SELECTOR_VIDEO equ (0x0003\u0026lt;\u0026lt;3) + TI_GDT + RPL0 total_mem_bytes dd 0 ;total_mem_bytes用于保存最终获取到的内存容量，为4个字节 ;由于loader程序的加载地址为0x900，而loader.bin的文件头大小为0x200 ;（4个gdt段描述符（8B）加上60个dp（8B）填充字，故64*8=512B）， ;故total_mem_bytes在内存中的地址为0x900+0x200=0xc00 ;该地址将来在内核中会被用到 ;------------- 定义gdtr（指向GDT的寄存器） ------------- gdt_ptr dw GDT_LIMIT dd GDT_BASE ards_buf times 244 db 0 ;开辟一块缓冲区，用于记录返回的ARDS结构体， ;该定义语句事实上是定义了一个数组ards_buf[244] ;244是因为total_mem_bytes(4)+gdt_ptr(6)+244+ards_nr(2)=256,即0x100 ;这样loader_start的在文件内的偏移地址就是0x100+0x200=0x300 ards_nr dw 0 ;用于记录ards结构体数量 ;------------------------------------------ ;INT 0x15 功能号：0xe820 功能描述：获取内存容量，检测内存 ;------------------------------------------ ;输入： ;EAX:功能号，0xE820，但调用返回时eax会被填入一串ASCII值 ;EBX:ARDS后续值 ;ES:di:ARDS缓冲区，BIOS将获取到的内存信息存到此寄存器指向的内存，每次都以ARDS格式返回 ;ECX:ARDS结构的字节大小，20 ;EDX:固定为签名标记，0x534d4150 ;返回值 ;CF：若cf为0，表示未出错，cf为1，表示调用出错 ;EAX：字符串SMAP的ASCII码值，0x534d4150 ;ES:di:ARDS缓冲区，BIOS将获取到的内存信息存到此寄存器指向的内存，每次都以ARDS格式返回 ;ECX:ARDS结构的字节大小，20 ;EBX:ARDS后续值，即下一个ARDS的位置。 ;每次BIOS中断返回后，BIOS会更新此值，BIOS会通过此值找到下一个待返回的ARDS结构。 ;在cf位为0的情况下，若返回后的EBX值为0，表示这是最后一个ARDS结构 loader_start: xor ebx,ebx ;第一次调用时，要将ebx清空置为0，此处使用的是异或运算置0 mov edx,0x534d4150 mov di,ards_buf ;di存储缓冲区地址，即指向缓冲区首地址 .e820_mem_get_loop: mov eax,0x0000e820 mov ecx,20 ;一个ards结构体的大小 int 0x15 ;调用0x15中断函数，返回的ards结构体被返回给di指向的缓冲区中 add di,cx ;使di增加20字节指向缓冲区中下一个的ARDS结构位置 inc word [ards_nr] ;inc（increment增加）指令表示将内存中的操作数增加一，此处用于记录返回的ARDS数量 cmp ebx,0 ;比较ebx中的值是否为0 jnz .e820_mem_get_loop ;若ebx不为0，则继续进行循环获取ARDS， ;若为0说明已经获取到最后一个ards，则退出循环 mov cx,[ards_nr] ;cx存储遍历到的ards结构体个数 mov ebx,ards_buf ;ebx指向缓冲区地址 xor edx,edx ;EDX用于保存BaseAddrLow+LengthLow最大值，此处初始化为0 .find_max_mem_area: mov eax,[ebx] ;eax用于遍历缓冲区中的每一个ards的BaseAddrLow add eax,[ebx+8] ;ebx+8获取的是LengthLow，故该代码计算的是BaseAddrLow+LengthLow add ebx,20 ;遍历下一个ards cmp edx,eax ;分支语句，如果edx大于等于eax，则跳转到.next_ards，也就是进入循环 jge .next_ards mov edx,eax ;否则就是更新edx .next_ards: loop .find_max_mem_area mov [total_mem_bytes],edx ;将最终结果保存到total_mem_bytes ;------------- 准备进入保护模式 ------------- ;1.打开A20 ;2.加载gdt ;3.置cr0的PE位为1 ;------------- 打开A20 ------------- in al,0x92 or al,0000_0010B out 0x92,al ;------------- 加载gdt ------------- lgdt [gdt_ptr] ;------------- 置cr0的PE位为1 ------------- mov eax,cr0 or eax,0x00000001 mov cr0,eax jmp dword SELECTOR_CODE:p_mode_start ;刷新流水线 .error_hlt: hlt ;出错则挂起 [bits 32] p_mode_start: mov ax,SELECTOR_DATA ;初始化段寄存器，将数据段的选择子分别放入各段寄存器 mov ds,ax mov es,ax mov ss,ax mov esp,LOADER_STACK_TOP ;初始化栈指针，将栈指针地址放入bsp寄存器 mov ax,SELECTOR_VIDEO ;初始化显存段寄存器，显存段的选择子放入gs寄存器 mov gs,ax call setup_page ;创建页目录表和页表，并初始化页内存位图 mov ebx,[gdt_ptr+2] ;gdt_ptr+2表示GDT_BASE,也就是GDT的起始地址 or dword [ebx+0x18+4],0xc0000000 ;ebx中保存着GDT_BASE，0x18=24，故ebx+0x18表示取出显存段的起始地址 ;+4表示取出段描述符的高32位，之后和0xc0000000进行或操作 ;表示将显存段的起始地址增加了3G add dword [gdt_ptr+2],0xc0000000 ;同理将GDT_BASE的起始地址也增加3G add esp,0xc0000000 ;同理将esp栈指针的起始地址也增加3G mov eax,PAGE_DIR_TABLE_POS mov cr3,eax mov eax,cr0 ;打开cr0的PG位 or eax,0x80000000 mov cr0,eax lgdt [gdt_ptr] ;开启分页后，用gdt的新地址重新加载 mov byte [gs:160],\u0026#39;V\u0026#39; jmp $ ;------------- 创建页目录表和页表 ------------- ;初始化页目录表和页表 ;逐字节清空页目录表 setup_page: mov ecx,4096 ;页目录表的大小为4KB，ecx是loop指令的循环计数器 ;由于初始化页表是逐字节置0的，因此ecx的值为4096 mov esi,0 ;页目录表的偏移量 .clear_page_dir: mov byte [PAGE_DIR_TABLE_POS+esi],0 ;逐字节清空页目录表 ;其中PAGE_DIR_TABLE_POS为页目录表初始地址的宏 inc esi ;递增偏移量，清空下一个字节 loop .clear_page_dir ;初始化创建页目录表 .create_pde: mov eax,PAGE_DIR_TABLE_POS ;eax保存页目录表的起始地址 add eax,0x1000 ;0x1000为1k，故该代码的计算结果是将eax指向第一张页表的起始地址 mov ebx,eax ;ebx保存第一张页表的起始地址，后续会用到 or eax,PG_US_U|PG_RW_W|PG_P ;eax已经有了第一张页表的起始地址 ;此处再加上属性，即可表示为页目录表的一个表项， ;该表项代表的是第一张页表的物理地址及其相关属性 mov [PAGE_DIR_TABLE_POS+0x0],eax ;页目录表的第一个表项指向第一张页表 mov [PAGE_DIR_TABLE_POS+0xc00],eax ;0xc0000000即为3GB，由于我们划分的虚拟地址空间3GB以上为os地址空间 ;因此该语句是将3GB的虚拟空间映射到内核空间 ;而0xc00/4=768，也就是说页目录表的768号表项映射为物理内核空间 sub eax,0x1000 mov [PAGE_DIR_TABLE_POS+4092],eax ;最后一个页表项指向自己，为将来动态操作页表做准备 ;创建第一张页表的页表项，由于os的物理内存不会超过1M，故页表项个数的最大值为1M/4k=256 mov ecx,256 ;循环计数器 mov esi,0 ;偏移量 mov edx,PG_US_S|PG_RW_W|PG_P ;此时的edx表示拥有属性PG_US_S|PG_RW_W|PG_P ;且物理地址为0的物理页的页表项 .create_pte: mov [ebx+esi*4],edx ;此前ebx已经保存了第一张页表的起始地址 add edx,4096 ;edx指向下一个物理页（一个物理页4KB） inc esi ;esi指向页表的下一个偏移 loop .create_pte ; -------------------初始化页目录表769号-1022号项，769号项指向第二个页表的地址（此页表紧挨着上面的第一个页表），770号指向第三个，以此类推 mov eax,PAGE_DIR_TABLE_POS add eax,0x2000 ;此时的eax表示第二张页表的起始地址 or eax,PG_US_U|PG_RW_W|PG_P ;为eax表项添加属性 mov ebx,PAGE_DIR_TABLE_POS mov ecx,254 ;要设置254个页表项 mov esi,769 ;从第769个页表项开始设置 .create_kernel_pde: mov [ebx+esi*4],eax ; 设置页目录表项 inc esi ; 增加要设置的页目录表项的偏移 add eax,0x1000 ; eax指向下一个页表的位置，由于之前设定了属性，所以eax是一个完整的指向下一个页表的页目录表项 loop .create_kernel_pde ; 循环设定254个页目录表项 ret 编译并写入磁盘\r编译mbr\n1 nasm -I ./include/ ./mbr.S -o mbr.bin 编译loader\n1 nasm -I ./include/ ./loader.S -o loader.bin 写入mbr\n1 dd if=/home/minios/osCode/miniOS_32/ch5/task2/mbr.bin of=/home/minios/bochs/hd60M.img bs=512 count=1 conv=notrunc 写入loader\n1 dd if=/home/minios/osCode/miniOS_32/ch5/task2/loader.bin of=/home/minios/bochs/hd60M.img bs=512 count=4 seek=2 conv=notrunc 运行\r如下，屏幕第二行出现了字符“V”，这个字符的打印代码是在保护模式下编写的，因此当字符“V”成功打印就说明我们成功开启了保护模式\n总结\r以下我们使用一张图总结虚拟地址在段机制与页机制下如何进行地址转换并找到物理地址的\n","date":"2024-12-12T00:00:00Z","image":"https://raw.githubusercontent.com/jl-sky/imageDatesets/master/2024/12/upgit_20241212_1733996509.jpg","permalink":"http://localhost:1313/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9C%9F%E8%B1%A1%E8%BF%98%E5%8E%9F%E7%AC%AC%E4%BA%94%E7%AB%A0%E4%B8%80-%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E8%BF%9B%E9%98%B6%E5%BC%80%E5%90%AF%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6/","title":"《操作系统真象还原》第五章（一）—— 保护模式进阶，开启分页机制"},{"content":"本章节所有代码托管在miniOS_32\n章节任务介绍\r上一节，我们完善了mbr主引导程序的功能——加载loader程序到指定位置运行\n但是上一节我们只是为了测试我们的mbr程序是否能够成功加载loader，因此loader程序仅仅只是在屏幕上打印出我们想要的字符串\n在本节，我们的主要任务就是完善loader程序的功能——开启保护模式，让后续的内核工作在保护模式下\n如何开启保护模式？\n打开A20 加载GDT 在实模式下构造需要的段描述符（代码段、数据段、栈段、显存段） 将四种段描述符装填进GDT，从而构造GDT 构造四种内存段的段选择子 构造GDTR（存储GDT基址的寄存器），从而让操作系统运行时将GDT加载进内存 置cr0寄存器的PE位为1 进入保护模式之前，先在实模式下测试一段在屏幕上显示信息的代码，即loader_start，这段代码使用实模式的逻辑编写，因此，如果运行成功，则说明在进入保护模式之前我们的代码是在实模式下运行的\n保护模式测试\n在进入保护模式之后写一段屏幕显示信息，如果显示成功说明成功进入了保护模式 前置知识\r保护模式概述\r一般来说，操作系统负责整个计算机软、硬件的管理，它做任何事情都是可以的。但是，用户程序却应当有所限制，只允许它访问属于自己的数据，即使是转移，也只允许在自己的各个代码段之间进行。\n问题在于，在实模式下，用户程序对内存的访问非常自由，没有任何限制，随随便便就可以修改任何一个内存单元\n比如以下代码片段，这个程序首先将段地址设置到0xb800，传统上，这是文本模式下的显存。所以，它通过指令向显存写入一个字符H。然后，它又将段地址切换到0x8000，向这个段内偏移地址为6的地方写入一字节0xc7。紧接着，又将段地址切换到0，向段内偏移地址为0x30的地方写入一字节0。\n事实上我们知道，段地址为0的这1KB内存是中断向量表，它这样做实际上是破坏了中断向量表的内容，但是它这样做是不受限制的，没有人可以阻止。最后，它又向端口0x60发送一字节的数据，用来控制设备。\n通过这一段程序可以看出，在实模式下，程序是可以“为所欲为”的。它想访问内存的哪一部分，都可以很轻松地通过设置段地址和偏移地址来办到，即使某个内存位置不属于当前程序，它照样可以切换到那里，并随意修改其中的内容。\n在多用户、多任务时代，内存中会有多个用户（应用）程序在同时运行。为了使它们彼此隔离，防止因某个程序的编写错误或者崩溃而影响到操作系统和其他用户程序，使用保护模式是非常有必要的。\n全局描述符表\r我们知道，为了让程序在内存中能自由浮动而又不影响它的正常执行，处理器将内存划分成逻辑上的段，并在指令中使用段内偏移。\n与实模式相同，在保护模式下，对内存的访问仍然使用段地址和偏移地址，但是，在每个段能够访问之前，必须先进行登记。\n为此，我们有以下概念\n和一个段有关的信息需要8字节来描述，称为段描述符(Segment Descriptor)，每个段都需要一个描述符。 为了存放这些描述符，需要在内存中开辟出一段空间。在这段空间里，所有的描述符都是挨在一起集中存放的，这就构成了一个描述符表。 最主要的描述符表是全局描述符表(Global Descriptor Table, GDT)，所谓全局，意味着该表是为整个软硬件系统服务的。在进入保护模式前，必须要定义全局描述符表。 为了跟踪全局描述符表，处理器内部有一个48位的寄存器，称为全局描述符表寄存器(GDTR)。 GDTR分为两部分，分别是32位的线性地址和16位的边界。32位的处理器具有32根地址线，可以访问的地址范围是0x00000000到0xFFFFFFFF，共2^32字节的内存，即4GB内存。 GDTR的32位线性基地址部分保存的是全局描述符表在内存中的起始线性地址，16位边界部分保存的是全局描述符表的边界（界限），其在数值上等于表的大小（总字节数）减一 因为GDT的界限是16位的，所以，该表最大是216字节，也就是65536字节(64KB)。又因为一个描述符占8字节，故最多可以定义8192个描述符 如下是全局描述表寄存器（GDTR）的格式\n理论上，全局描述符表可以位于内存中的任何地方。但是，\n由于在进入保护模式之后，处理器要立即按新的内存访问模式工作，所以，必须在进入保护模式之前定义GDT。 此外，由于在实模式下只能访问1MB的内存，故GDT通常都定义在1MB以下的内存范围中。当然，允许在进入保护模式之后换个位置重新定义GDT。 以下是GDT和GDTR的关系图\n总结来说，\nGDT相当于一个数组，数组中的元素是各个段描述符 GDTR这个寄存器中存放着GDT的首地址 GDTR的访问方式：lgdt 48位内存数据 段描述符\r段描述符是一个专门用来描述一个内存段（比如代码段、数据段、栈段、显存段等等）属性的结构，如前所述，该结构的大小占据8个字节\n以下是段描述符与内存段之间的关系\n以下是段描述符的格式，每个描述符在GDT中占8字节，也就是2个双字，或者说是64位。图中，下面是低32位（低双字），上面是高32位（高双字）。\n从上图可以看出\n描述符中指定了32位的段起始地址（段基址），以及20位的段边界。 在实模式下，段地址并非真实的物理地址，在计算物理地址时，还要左移4位（乘以16）。 而在32位保护模式下，段地址是32位的线性地址，如果未开启分页功能，该线性地址就是物理地址。 此外，我们给出段描述符中各个属性位的详细解释\n段界限：表示一个段的最大大小 此段界限是一个单位量，其单位要么是字节，要么是4KB，具体可由G位进行指定 最终段界限=此段界限值*单位 实际段界限计算公式：（此段界限值+1）*（G位）-1 G：粒度位，用于解释段界限的单位 为0：表示段界限的单位表示为字节 为1：表示段界限的单位表示为4KB S：描述符类型 为0，表示系统段 为1，表示非系统段（代码段或者数据段） type：用于指示描述符的子类型 DPL：Descriptor Privilege Level，即描述符的特权级，用于指定要访问该段所必须具有的最低特权级。如果这里的数值是2，那么，只有特权级别为0、1和2的程序才能访问该段，而特权级为3的程序访问该段时，处理器会予以阻止。 特权级共有0、1、2、3，用于解释段界限的含义，其中0是最高特权级别，3是最低特权级别。 特权级是一个数字，可以赋给一个程序，用来决定该程序能够执行哪些指令，或者能够访问哪些系统资源；也可以赋给系统资源，用来决定哪些程序可以访问它们。 刚进入保护模式时执行的代码具有最高特权级0（可以看成从实模式那里继承来的），这些代码通常都是操作系统代码，因此它的特权级别最高。 每当操作系统加载一个用户程序时，它通常都会指定一个稍低的特权级，比如3特权级。不同特权级别的程序是互相隔离的，其互访是严格限制的，而且有些处理器指令（特权指令）只能由0特权级的程序来执行，为的就是安全。 P：段存在位，用于指示描述符所对应的段是否存在 P位是由处理器负责检查的。每当通过描述符访问内存中的段时，如果P位是“0”，处理器就会产生一个异常中断 该中断处理过程是由操作系统提供的，该处理过程的任务是负责将该段从硬盘换回内存，并将P位置1 D/B：标志位，为了能够在32位处理器上兼容运行16位保护模式的程序。该标志位对不同的段有不同的效果。 对于代码段，此位称作“D”位，用于指示指令中默认的有效地址和操作数尺寸； D=0，表示指令中的有效地址或者操作数是16位的； D=1，指示32位的有效地址或者操作数。 对于栈段和向下扩展的数据段来说，该位被叫作“B”位，用于指定在进行隐式的栈操作时，是使用寄存器SP还是寄存器ESP，隐式的栈操作指令包括push、pop和call等。 如果该位是“0”，在访问那个段时，使用寄存器SP； 否则就是使用寄存器ESP。 AVL：表示软件是否可以使用(Available)，通常由操作系统来用，处理器并不使用它。 L：用于设置是否是64位代码段 为1，表示64位代码段 为0，表示32位代码段 选择子\r段寄存器 CS、DS、ES、FS、GS、SS，在实模式下时，段中存储的是段基地址，即内存段的起始地址。\n而在保护模式下时，在段寄存器中存入的是一个叫作选择子的东西\u0026ndash;selector。选择子可以看做是个索引值，用于在段描述符表中索引相应的段描述符，这样，便在段描述符中得到了内存段的起始地址和段界限值等相关信息。\n以下是选择子结构各属性说明\nRPL：请求特权级 TI（table indicator）：表示在GDT（全局描述符表）还是在LDT（局部描述符表）中索引描述符 为0，在GDT中进行索引 为1，在LDT中进行索引 3 ~ 15位，具体描述符的索引值，2^13=8192，故最多可以索引8192个段 我们知道\n在实模式下，段地址并非真实的物理地址，在计算物理地址时，还要左移4位（乘以16），而在32位保护模式下，段地址是32位的线性地址，如果未开启分页功能，该线性地址就是物理地址。 所以在保护模式下，直接用选择子对应的“段描述符中的段基址”加上“段内偏移地址”就是要访问的内存地址 具体来说，例如选择子是 0x8（1000），将其加载到 ds寄存器后，访问ds:0x9这样的内存，其过程是\n0x8的低2位是RPL，其值为 00。 第2位是TI，其值0，表示是在 GDT中索引段描述符。 0x8的高13 位0x1负责在 GDT中索引，也就是GDT中的第1个段描述符(GDT中第0个段描述符不可用)。 假设此时第1个段描述符中的3个段基址部分,其值为 0x1234。CPU将0x1234作为段基址,与段内偏移地址 0x9相加,0x1234+0x9=0x123d.用所得的和0x123d作为访存地址。 控制寄存器CR0\r控制寄存器是CPU的窗口，既可以用来展示CPU的内部状态，也可以用于控制CPU的运行机制\n其中CR0的PE位是保护模式的开关\n为0时，表示在实模式下运行 为1时表示在保护模式下运行 进入保护模式\r代码目录结构\r1 2 3 4 5 6 7 . ├── include │ └── boot.inc //配置文件 ├── loader.S\t//loader程序代码 ├── Makefile\t//编译文件，可直接使用make进行编译代码 ├── mbr.S\t//mbr程序代码 └── start.sh\t//编译脚本，如果不想使用make编译代码，也可以选择运行该脚本编译代码，该脚本的编译命令更加清晰 代码\rboot.inc\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 ;-----loader and kernel----- LOADER_BASE_ADDR equ 0x900 ;loader在内存中位置 LOADER_START_SECTOR equ 0x2 ;loader在磁盘中的逻辑扇区地址，即LBA地址 ;----- gdt描述符属性 --------- DESC_G_4K equ 1_00000000000000000000000b ;设置段界限的单位为4KB DESC_D_32 equ 1_0000000000000000000000b ;设置代码段/数据段的有效地址（段内偏移地址）及操作数大小为32位 DESC_L equ 0_000000000000000000000b ;64位代码段标记位，现在是32位操作系统，因此标记为0即可。 DESC_AVL equ 0_00000000000000000000b ;定义段界限位 ;段界限的第2部分，即描述符的高32位中的第16~19位，最终的代码段段界限为0xFFFFF DESC_LIMIT_CODE2 equ 1111_0000000000000000b ;定义代码段要用的段描述符高32位中16~19段界限为全1 DESC_LIMIT_DATA2 equ DESC_LIMIT_CODE2 ;定义数据段要用的段描述符高32位中16~19段界限为全1 DESC_LIMIT_VIDEO2 equ 0000_000000000000000b ;定义我们要操作显存时对应的段描述符的高32位中16~19段界限为全0 DESC_P equ 1_000000000000000b ;定义了段描述符中的P标志位，表示该段描述符指向的段是否在内存中 ;定义描述符的特权级别位 DESC_DPL_0 equ 00_0000000000000b DESC_DPL_1 equ 01_0000000000000b DESC_DPL_2 equ 10_0000000000000b DESC_DPL_3 equ 11_0000000000000b ;定义类型位 DESC_S_CODE equ 1_000000000000b ;代码段和数据段都是非系统段，故类型字段s设置为1 DESC_S_DATA equ DESC_S_CODE ;代码段和数据段都是非系统段，故类型字段s设置为1 DESC_S_sys equ 0_000000000000b ;系统段的类型字段设置为0 ;定义子类型位 DESC_TYPE_CODE equ 1000_00000000b ;x=1,c=0,r=0,a=0 代码段是可执行的，非一致性，不可读，已访问位a清0 DESC_TYPE_DATA equ 0010_00000000b ;x=0,e=0,w=1,a=0，数据段不可执行，向上扩展，可写，已访问位a清0 ;拼接代码段的描述符 DESC_CODE_HIGH4 equ (0x00\u0026lt;\u0026lt;24) + DESC_G_4K \\ + DESC_D_32 + DESC_L + \\ DESC_AVL + DESC_LIMIT_CODE2 + DESC_P + DESC_DPL_0 + \\ DESC_S_CODE + DESC_TYPE_CODE + 0x00 ;拼接数据段的描述符 DESC_DATA_HIGH4 equ (0x00\u0026lt;\u0026lt;24) + DESC_G_4K \\ + DESC_D_32 + DESC_L + \\ DESC_AVL + DESC_LIMIT_DATA2 + DESC_P + DESC_DPL_0 + \\ DESC_S_DATA + DESC_TYPE_DATA + 0x00 ;拼接显存段的描述符位 DESC_VIDEO_HIGH4 equ (0x00\u0026lt;\u0026lt;24) + DESC_G_4K \\ + DESC_D_32 + DESC_L + \\ DESC_AVL + DESC_LIMIT_VIDEO2 + DESC_P + DESC_DPL_0 + \\ DESC_S_DATA + DESC_TYPE_DATA + 0x0b ;----- 选择子属性 --------- RPL0 equ 00b RPL1 equ 01b RPL2 equ 10b RPL3 equ 11b TI_GDT equ 000b TI_LDT equ 100b 原书勘误，显存描述符应该为的最后应该是0x0b，而不是0x00\n1 2 3 4 DESC_VIDEO_HIGH4 equ (0x00\u0026lt;\u0026lt;24) + DESC_G_4K \\ + DESC_D_32 + DESC_L + \\ DESC_AVL + DESC_LIMIT_VIDEO2 + DESC_P + DESC_DPL_0 + \\ DESC_S_DATA + DESC_TYPE_DATA + 0x0b loader.S\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 %include \u0026#34;boot.inc\u0026#34; SECTION loader vstart=LOADER_BASE_ADDR ;初始化栈指针地址 LOADER_STACK_TOP equ LOADER_BASE_ADDR jmp loader_start ;------------- 构建gdt及其内部的描述符 ------------- ;使用GDT_BASE定义GDT的基址，dd是伪指令，用于定义双字变量，一个字是2个字节 GDT_BASE: ;定义GDT的第0个描述符（操作系统规定必须为全0） dd 0x00000000 dd 0x00000000 ;代码段描述符的低4字节部分，其中高两个字节表示段基址的0~15位,在这里定义为0x0000 ;低两个字节表示段界限的0~15位，由于使用的是平坦模型，因此是0xFFFF CODE_DESC: dd 0x0000FFFF dd DESC_CODE_HIGH4;段描述符的高4字节部分 DATA_STACK_DESC: dd 0x0000FFFF dd DESC_DATA_HIGH4 ;定义显存段的描述符 ;文本模式下的适配器地址为0xb8000~0xbffff,为了方便显存操作，显存段不使用平坦模型 ;因此段基址为0xb8000,段大小为0xbffff-0xb8000=0x7fff, ;段粒度位4k，因此段界限的值为0x7fff/4k=7 VIDEO_DESC: dd 0x80000007 dd DESC_VIDEO_HIGH4 GDT_SIZE equ $-GDT_BASE GDT_LIMIT equ GDT_SIZE-1 ;dq，定义四字变量，也就是8字节变量 times 60 dq 0 ;此处预留60个描述符的空位 ;------------- 构建选择子 ------------- SELECTOR_CODE equ (0x0001\u0026lt;\u0026lt;3) + TI_GDT + RPL0 SELECTOR_DATA equ (0x0002\u0026lt;\u0026lt;3) + TI_GDT + RPL0 SELECTOR_VIDEO equ (0x0003\u0026lt;\u0026lt;3) + TI_GDT + RPL0 ;------------- 定义gdtr（指向GDT的寄存器） ------------- gdt_ptr dw GDT_LIMIT dd GDT_BASE ;------------- 加载器的显示信息 ------------- loadermsg db \u0026#39;2 loader in real .\u0026#39; loader_start: ;------------------------------------------ ;INT 0x10 功能号：0x13 功能描述：打印字符串 ;------------------------------------------ ;输入： ;AH:功能号 ;AL:显示输出方式 ; 0——字符串中只含显示字符，显示属性在BH中，显示后光标位置不变 ; 1——字符串中只含显示字符，显示属性在BH中，显示后光标位置改变 ; 2——字符串中含显示字符和显示属性，显示后光标位置不变 ; 3——字符串中含显示字符和显示属性，显示后光标位置改变 ;BH:页码 ;BL:属性 ;CX:字符串长度 ;(DH、DL):坐标（行、列） ;ES:BP 字符串地址 ;无返回值 mov sp,LOADER_BASE_ADDR mov bp,loadermsg mov cx,17 mov ax,0x1301 mov bx,0x001f;页号为0，蓝底粉红字 mov dx,0x1800 int 0x10 ;------------- 准备进入保护模式 ------------- ;1.打开A20 ;2.加载gdt ;3.置cr0的PE位为1 ;------------- 打开A20 ------------- in al,0x92 or al,0000_0010B out 0x92,al ;------------- 加载gdt ------------- lgdt [gdt_ptr] ;------------- 置cr0的PE位为1 ------------- mov eax,cr0 or eax,0x00000001 mov cr0,eax jmp dword SELECTOR_CODE:p_mode_start;刷新流水线 [bits 32] p_mode_start: mov ax,SELECTOR_DATA ;初始化段寄存器，将数据段的选择子分别放入各段寄存器 mov ds,ax mov es,ax mov ss,ax mov esp,LOADER_STACK_TOP ;初始化站栈指针，将栈指针地址放入bsp寄存器 mov ax,SELECTOR_VIDEO ;初始化显存段寄存器，显存段的选择子放入gs寄存器 mov gs,ax mov byte [gs:160],\u0026#39;p\u0026#39; jmp $ mbr.S\r由于loader程序已经超过了512字节，因此我们要把mbr.S代码中从磁盘加载loader的读入扇区数增大，原来是读入1个扇区，我们直接修改为读入4个扇区，如下所示\n1 2 3 4 mov eax,LOADER_START_SECTOR ;起始扇区地址 mov bx,LOADER_BASE_ADDR ;要写入的内存地址 mov cx,4 ;待读入的扇区数目 call rd_disk_m16 ;调用磁盘读取程序 完整的mbr.S代码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 ;主引导程序MBR，由BIOS通过jmp 0:0x7c00跳转 ;------------------------------------------ %include \u0026#34;boot.inc\u0026#34; ;vstart=0x7c00表示本程序在编译时，起始地址编译为0x7c00 SECTION MBR vstart=0x7c00 ;由于BIOS是通过jmp 0:0x7c00跳转到MBR，故此时cs为0 ;对于 ds、es、fs、gs 这类 sreg，CPU 中不能直接给它们赋值，没有从立即数到段寄存器的电路实现,只有通过其他寄存器来中转，这里我们用的是通用寄存器ax来中转。 mov ax,cs mov ds,ax mov es,ax mov ss,ax mov fs,ax ;初始化栈指针 mov sp,0x7c00 ;存入显存的段基址 mov ax,0xb800 mov gs,ax ;------------------------------------------ ;------------------------------------------ ;利用0x06号功能进行清屏 ;INT 0x10 功能号：0x06 功能描述：上卷窗口清屏 ;输入: ;AH 功能号：0x06 ;AL=上卷的行数（如果为0，则表示全部） ;BH=上卷的行属性 ;(CL,CH)=窗口左上角(X,Y)位置 ;(DL,DH)=窗口右下角(X,Y)位置 ;返回值 ;无返回值 mov ax,0x0600 mov bx,0x0700 mov cx,0 ;左上角(0,0) mov dx,0x184f ;右下角(80,25) ;0x18=24，0x4f=79 int 0x10 ;调用BIOS中断函数 ;------------------------------------------ ;------------------------------------------ ;将要显示的字符串写入到显存中 mov byte [gs:0x00],\u0026#39;1\u0026#39; ;在第一个字节的位置写入要显示的字符“1” ;在第二个字节的位置写入显示字符（也就是字符1）的属性，其中A表示绿色背景，4表示前景色为红色 mov byte [gs:0x01],0xA4 mov byte [gs:0x02],\u0026#39; \u0026#39; mov byte [gs:0x03],0xA4 mov byte [gs:0x04],\u0026#39;M\u0026#39; mov byte [gs:0x05],0xA4 mov byte [gs:0x06],\u0026#39;B\u0026#39; mov byte [gs:0x07],0xA4 mov byte [gs:0x08],\u0026#39;R\u0026#39; mov byte [gs:0x09],0xA4 mov eax,LOADER_START_SECTOR ;起始扇区地址 mov bx,LOADER_BASE_ADDR ;要写入的内存地址 mov cx,4 ;待读入的扇区数目 call rd_disk_m16 ;调用磁盘读取程序 jmp LOADER_BASE_ADDR; ;------------------------------------------ ;函数功能：读取硬盘的n个扇区 ;参数： ;eax：LBA扇区号 ;bx：要写入的内存地址 ;cx：待读入的扇区数目 rd_disk_m16: ;out命令，通过端口向外围设备发送数据 ;其中目的操作数可以是8为立即数或者寄存器DX,源操作数必须是寄存器AL或者AX ;因此需要将之前ax中保存的值进行备份 mov esi,eax mov di,cx ;正式读写硬盘 ;第一步：设置要读取的扇区数目 mov dx,0x1f2 mov ax,cx out dx,ax mov eax,esi\t;恢复eax的值 ;第二步：将LBA的地址存入0x1f3~0x1f6 ;LBA的0~7位写入端口0x1f3 mov dx,0x1f3 out dx,al ;LBA的8~15位写入端口0x1f4 mov cl,8 shr eax,cl\t;将ax右移8位 mov dx,0x1f4 out dx,al ;LBA的16~23位写入端口0x1f5 shr eax,cl mov dx,0x1f5 out dx,al ;LBA的24~27位写入端口0x1f6 shr eax,cl\t;右移8位 and al,0x0f\t;与0000 1111相与，取后四位 or al,0xe0\t;设置7~4位为1110，表示lba模式 mov dx,0x1f6 out dx,al ;第三步，向0x1f7端口写入读命令，0x20 mov dx,0x1f7 mov al,0x20 out dx,al ;第四步，检测硬盘状态 .not_ready: nop ;空操作，什么也不做，相当于sleep，只是为了增加延迟 in al,dx ;由于读取硬盘状态信息的端口仍旧是0x1f7，因此不需要再为dx指定端口号 and al,0x88 ;取出状态位的第3位和第7位 ;其中第3位若为1表示硬盘控制器已经准备好数据传输,第7位为1表示硬盘忙 cmp al,0x08 ;cmp为减法指令，如果两个操作数相等，标志寄存器ZF会被置为1 ;此处是为了判断第7位是否为1，如果为1，说明硬盘忙，则减法的结果应该为0，相应ZF寄存器的值会被置为1 jnz .not_ready ;若未准备好，则继续等 ;JNZ是条件跳转指令，它表示\u0026#34;Jump if Not Zero\u0026#34;， ;也就是如果零标志位（ZF）不为0，则进行跳转。否则不进行跳转 ;第五步，从0x1f0端口读取数据 mov ax,di ;di是之前备份的要读取的扇区数 mov dx,256 mul dx ;一个扇区512字节，每次读取两个字节，需要读取di*256次 ;mul指令表示乘法操作，当只有一个操作数时，被乘数隐含在al或者ax中 mov cx,ax ;cx在此时表示要循环读取的次数 mov dx,0x1f0 .go_on_read: in ax,dx ;从0x1f0端口读取2个字节的数据到寄存器ax mov [bx],ax ;读取的数据写入bx寄存器所指向的内存 add bx,2 ;目的内存地址偏移2个字节继续循环读取剩余的数据 loop .go_on_read ret times 510-($-$$) db 0 db 0x55,0xaa 编译\r1 nasm -I ./include/ ./mbr.S -o mbr.bin 1 nasm -I ./include/ ./loader.S -o loader.bin 磁盘写入\r注意loader.S写入磁盘时count参数为2\n1 dd if=/home/minios/osCode/miniOS_32/ch4/mbr.bin of=/home/minios/bochs/hd60M.img bs=512 count=1 conv=notrunc 1 dd if=/home/minios/osCode/miniOS_32/ch4/loader.bin of=/home/minios/bochs/hd60M.img bs=512 count=2 seek=2 conv=notrunc 运行\r左下角的字符串“2 loader inreal”是在实模式下用 BIOS 中断 0x10 打印的。 左上角第2行的字符P，这是在保护模式下输出的。一个程序历经两种模式，各模式下都打印了字符，为了区别实模式下的打印，所以字符串中含有“inreal”。 输出p说明GDT成功建立，如下调试所示\n1 2 3 4 5 6 7 \u0026lt;bochs:3\u0026gt; info gdt Global Descriptor Table (base=0x00000903, limit=31): GDT[0x00]=??? descriptor hi=0x00000000, lo=0x00000000 GDT[0x01]=Code segment, base=0x00000000, limit=0xffffffff, Execute-Only, Non-Conforming, Accessed, 32-bit GDT[0x02]=Data segment, base=0x00000000, limit=0xffffffff, Read/Write, Accessed GDT[0x03]=Data segment, base=0x000b8000, limit=0x00007fff, Read/Write, Accessed You can list individual entries with \u0026#39;info gdt [NUM]\u0026#39; or groups with \u0026#39;info gdt [NUM] [NUM]\u0026#39; ","date":"2024-12-11T00:00:00Z","image":"https://raw.githubusercontent.com/jl-sky/imageDatesets/master/2024/12/upgit_20241211_1733904874.jpg","permalink":"http://localhost:1313/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9C%9F%E8%B1%A1%E8%BF%98%E5%8E%9F%E7%AC%AC%E5%9B%9B%E7%AB%A0%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%85%A5%E9%97%A8/","title":"《操作系统真象还原》第四章——保护模式入门"},{"content":"内容的定义\r数据段的定义\r汇编语言程序以段为单位进行书写，一般把数据定义在数据段里，程序写在代码段中。下面给出段的定义语法：\n1 2 3 段名 SEGMENT ...（段的内容）... 段名 ENDS 注意事项：\n汇编语言不区分字母的大小写； 汇编语言中一行只能有一条语句； 段的名字用字母或下划线开头，需要做到含义清晰且不能与保留字重名； 汇编语言中用英文分号后的内容表示程序注释； 不能在一个段的内部定义另一个段，也就是各个段之间相互独立。 数据的定义\r数据的定义是指对给出的数据分配存储单元，并将它们以标准的格式存放到数据段中。数据定义的语句元素包括DB DW DD DQ DT等。\n定义字节数据DB\r给出下面的汇编程序段\n1 2 3 4 5 DATA SEGMENT X DB -1,255,\u0026#39;A\u0026#39;,3+2,? DB \u0026#34;ABC\u0026#34;,0FFH,11001010B Y DB 3 DUP(?) DATA ENDS 变量的定义：X和Y称为变量名，表示程序员定义了两个变量X和Y。与高级语言不同，汇编语言中的变量实际上是后面第一个数据的地址，变量名代表了后面的若干个数据； 字节数据的定义：DB表示定义的数据类型都是字节类型。DB可以用于定义整数（包括正数和负数，可以使用十进制、十六进制或二进制）以及字符； 求值表达式：定义数据时可以出现简单的求值表达式的结果。如上方的DB 3+2相当于 DB 5； 未知值的定义：用问号表示一个暂时还不确定的值，一般先用0进行这个单元的填充； 多个字符的定义：可以出现用双引号括起来的多个字符，这些字符将分开并按照顺序进行存储； 重复定义相同数据：DUP表示重复定义多个相同的数据。语法如下； 隔行定义：如果数据太多一行写不下，则可以另起一行继续定义。不需要重新写变量名，但是需要重新写DB伪指令。 定义字数据DW\r字数据的位数为16位，只需要将上面字节定义的语法中的DB修改为DW即可。\n定义双字数据DD\r双字数据为32字节，只需要将上面字节定义的语法中的DB修改为DD即可。需要注意的是，数据的高位存放在地址较大的单元里，数据的低位存放在地址较小的单元里。\n定义八字节和十字节数据DQ DT\r只需要将DB伪指令修改为DQ和DT即可。\n数据的传送\r指令语句的格式\r指令语句是指与一条机器指令相对应的代码语句，其一般格式如下：\n1 [标号：] 操作码 [操作数] [;注释] 语法解释：\n标号是指程序员为这一条指令语句所起的名字。大多数指令语句都不需要标号，只有一些特殊的指令语句需要用到； 操作码指定本条指令的操作类型，所有的操作码都是保留字； 操作数可以是0-3个，有多个操作数时彼此之间用逗号分隔。右边的操作数为源操作数，最左边的操作数为目的操作数。 操作数的分类\r操作数可以分为寄存器操作数、立即数操作数和存储器操作数三类。关于寄存器操作数，需要注意的是寄存器IP和FLAGS不能作为操作数出现在指令中；关于立即数操作数，需要注意的是立即数操作数不能用作目的操作数。下面着重介绍存储器操作数，先介绍两点基础知识：\n存储器操作数表示对一个存储器单元进行访问，需要给出这个存储单元的段基址和偏移地址两部分才能进行； 大多数情况下，指令将自动使用DS寄存器中的内容作为操作数的段基址，因此，编写汇编语言源程序时首先要做的事情就是把数据段的段基址放入DS寄存器。 既然我们已经设置好了段基址，那么只需要有偏移地址即可找到内存中正确的存储单元。给出偏移地址的方法有直接和间接两种方法。直接法是指直接在指令中写出存储单元的偏移地址，间接法则是把存储单元的偏移地址事先装入一个寄存器中，需要时通过这个寄存器中的值来找到这个存储单元。\n（1）直接法语法：\n1 MOV 目的寄存器, 变量名[+字节偏移量] 此语句的作用是以DS寄存器中的内容作为段基址，以数据段中指定变量名的偏移量（与字节偏移量）的和作为偏移地址，将指定存储单元中的值放入目的寄存器中。\n（2）间接法语法：\n1 2 3 MOV 间接寻址寄存器, OFFSET 变量名 (下面是需要使用偏移地址时的语句） MOV 目的寄存器, 间接寻址寄存器 语法解释：\nOFFSET是保留字，表示取出后面变量的偏移地址； 间接寻址寄存器只能是BX BP SI DI中的一个。如果没有另外说明，那么使用BX、SI和DI时自动以DS中的内容作为段基址，使用BP时自动使用SS的值作为段基址。 程序段的定义\r程序段的一般格式如下：\n1 2 3 4 5 6 7 8 9 CODE SEGMENT ASSUME CS:CODE, DS:DATA START: MOV AX, DATA MOV DS, AX ...(其他指令部分)... MOV AX, 4C00H INT 21H CODE ENDS END START 语法解读：\n程序开始的两条指令都是用于装载数据段寄存器DS的。进入程序后，代码段寄存器CS中的值已经由操作系统自动设置为代码段的段基址，数据段的段基址则需要程序员手动装入DS中； ASSUME伪指令用于指定每一个数据段所对应的段基址寄存器。如上面的代码中CODE段的段基址寄存器为CS，DATA段的段基址寄存器为DS； INT 21H表示调用由操作系统提供的21H号服务程序。服务的种类由AH中的功能号决定，本例中4CH表示返回操作系统的操作；AL中的代码称为返回代码，用返回代码00H表示正常返回； END伪指令标志整个程序的结束。END语句下面书写的任何代码都不会被汇编。END后的标号表示程序的入口地址，也就是汇编程序开始执行的地方。 基本传送指令\r基本传送指令是使用最频繁的指令，需要熟练掌握。格式如下：\n1 MOV 目的操作数, 源操作数 语法解释：\n源操作数和目的操作数的类型必须相同。如果不相同只有使用强制类型转换后才能进行传送。强制类型转换语法可以见下方； 源操作数和目的操作数不能同时是存储器操作数，也不能同时是段寄存器； 目的操作数不能是立即数； 代码段基址寄存器CS不能作目的操作数； 使用立即数作为源操作数时，立即数会按照目的操作数的类型进行扩展。 强制类型转换语法（要谨慎使用）：\n1 数据类型 PTR[变量名] 堆栈\r堆栈的定义\r堆栈也是用户使用的存储器的一部分，用于存放临时性的数据和一些其他信息。堆栈段的定义语法如下：\n1 2 3 堆栈名 SEGMENT STACK (堆栈内容） 堆栈名 ENDS 语法解释：\n堆栈定义和一般段的定义的唯一区别在于使用了STACK； 对于堆栈段，系统会在装入程序时自动把SSEG的段基址放入SS寄存器中，堆栈中的字节数自动置入SP寄存器中； 堆栈段中的内容从较大的地址开始分配和使用； 对于8086CPU，进出堆栈的只能是2字节的数据。 堆栈的使用方法\r常用的堆栈相关指令包括PUSH POP PUSHF和POPF，语法如下：\n1 2 3 4 PUSH 源操作数 ;将指定操作数入栈保护 POP 目的操作数 ;将栈顶操作数恢复到指定位置 PUSHF ;标志寄存器内容入栈保护 POPF ;标志寄存器出栈恢复 常用操作数表达式\r符号定义伪指令\r符号定义相当于C语言中的#define编译预处理，用于进行符号的等价替换，符号定义的语法如下所示：\n1 符号名 EQU 表达式 语法解释：\n在进行汇编时，对EQU定义的符号名用对应的表达式进行等价替换； 对用EQU定义的符号名不允许重复定义。 另一种进行符号定义的方式是使用“=”符号，具体语法如下：\n1 符号名 = 常数表达式 语法解释：\n使用等号定义符号时只能使用常量表达式。\n取段基址\r可以使用SEG来取地址表达式所在段的段基址，具体使用方法为：\n1 SEG 地址表达式 算术运算\r加法指令\r对于两个操作数相加应该使用ADD指令，指令语法如下：\n1 ADD 目的操作数, 源操作数 语法解释：\n该指令将目的操作数与源操作数相加，结果存放在目的操作数原先的存放位置； ADD指令执行后会刷新CPU的状态标志位。 除此之外，还有一条INC指令实现操作数的自增，语法如下：\n1 INC 操作数 语法解释：\n增量执行执行后不影响CPU的状态标志位； 增量指令常常用于修改计数器以及存储器指针的值。 减法指令\r减法指令和加法指令的使用是对称的。加法中的ADD对应减法中的SUB；加法中的INC对应减法中的DEC。\n乘法指令和除法指令\r**乘法指令为MUL，除法指令为DIV，使用方法和加减法类似。**由于乘除法使用较少，因此不过多介绍。\n循环\r循环指令的语法如下：\n1 LOOP 标号 语法解释：\n循环的次数由寄存器CX中的值决定。每一次循环后CX寄存器中的值会自减1，当CX=0时循环终止，因此CX也被称为计数器； 装载寄存器CX的过程应该在循环开始之前完成； 每一次循环成功则回到标号处的语句。 逻辑运算\r逻辑运算有AND OR XOR和NOT四种，使用语法如下：\n1 逻辑运算操作码 目的操作数 源操作数 使用情况：\nAND指令主要用于对操作数的各位有选择地清零； OR指令主要用于对操作数各位有选择地置一； XOR指令主要用于对操作数各位有选择地取反； NOT指令主要用于对操作数整体取反。 中断调用\r所有的DOS系统功能调用都是通过软中断指令INT 21H来实现的。INT 21H是一个具有90多个子功能的中断服务程序。INT 21H对每一个子功能都进行了编号，这个编程成为功能号。\nDOS系统功能调用方法：\n1 2 3 4 5 MOV 功能号 ;把功能号放入寄存器AH中 ...... (在其他寄存器中放入该功能要求的入口参数) ...... INT 21H ;调用DOS系统功能 键盘输入单字符\r功能号1，输入字符以ASCII码的形式存放在累加器AL中同时显示出来。\n1 2 MOV AH 01 INT 21H 屏幕显示单字符\r功能号2，屏幕显示存放在DL寄存器中的字符。\n1 2 3 MOV AH 02 MOV DL 待显示字符 INT 21H 屏幕显示字符串\r功能号9，用于在显示器上显示一个存放在寄存器DX中的字符串，被显示的字符串必须以’$\u0026lsquo;作为结束符。\n1 2 3 MOV AH 09 MOV DX 待显示字符串首地址 INT 21H 返回DOS\r一个程序执行完成后使得程序正常退出并返回DOS的功能，功能号为4CH。\n1 2 MOV AH 4CH INT 21H 子程序的定义和调用\r定义子程序\r1 2 3 4 子程序名 PROC ... RET ;表示子程序返回 子程序名 ENDP ;表示子程序段定义结束 调用子程序\r1 CALL 子程序名 对接中的端口进行读写\r1 2 3 4 5 MOV DX 端口地址 ...... (其他寄存器初始化) ...... OUT DX 需要传输到端口的数据所在的寄存器 空指令延时\r使用NOP表示执行一条空指令，不进行任何操作。当指令之间需要有延时时，可以插入NOP指令。\n1 NOP 选择结构\rCMP指令\rCMP指令格式如下：\n1 CMP 目的操作数,源操作数 语法解释：\nCMP用于比较两个同类型的操作数的大小； 指令执行的结果不会修改两个操作数，而是修改标志位； CMP指令常常与下列指令结合使用。 1 2 3 4 5 6 JGE 前\u0026gt;=后 Jump if greater or equal JG 前\u0026gt;后 Jump if greater JLE 前\u0026lt;=后 Jump if less or equal JL 前\u0026lt;后 Jump if less JNE 前不等于后 Jump if not equal JE 前等于后 Jump if equal 参考：https://blog.csdn.net/hanmo22357/article/details/127883179\n","date":"2024-12-11T00:00:00Z","image":"https://raw.githubusercontent.com/jl-sky/imageDatesets/master/2024/12/upgit_20241211_1733924143.jpg","permalink":"http://localhost:1313/p/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/","title":"汇编语言快速入门"},{"content":"本章节所有代码托管在miniOS_32\n章节任务\r操作显存显示内容\r上一节，我们介绍了计算机在开机后BIOS是如何从磁盘中加载mbr程序并运行的，为了测试mbr程序，我们使用BIOS中断写了一段在屏幕上显示内容的代码，以此来测试BIOS加载mbr程序的过程，如果BIOS能够成功加载mbr程序并运行，则必然会在屏幕上显示我们在mbr程序中写的内容\n本节我们将介绍显卡与显存，而我们的第一个任务，就是将通过显存来控制屏幕输出内容，替换掉BIOS中断的方法\n前置知识\r显卡与显存\r为了显示文字，通常需要两种硬件，一是显示器，二是显卡。\n显卡的职责是为显示器提供内容，并控制显示器的显示模式和状态。 显卡未必一定是独立的插卡。为了节省使用者的成本，有的显卡会直接做在主板上，这样的显卡也有个名字，叫集成显卡。 显卡控制显示器的最小单位是像素。 显示器的职责是将显卡的内容以视觉可见的方式呈现在屏幕上。 显存就是存放要在显示器上显示的内容的器件，因为它位于显卡上，故称显示存储器，简称显存，要显示的内容都预先写入显存。\n所以，显存可以认为就是一块特殊的内存，用于存储显示在屏幕上的内容，**为了给出要显示的字符，处理器需要访问显存，把字符的ASCII码写进去。**但是，显存是位于显卡上的，访问显存需要和显卡这个外围设备打交道。同时，多一道手续自然是不好的，这当中最重要的考量是速度和效率。\n为此，计算机系统的设计者们，决定把显存映射到处理器可以直接访问的地址空间里，也就是内存空间里。\n如图所示，8086可以访问1MB内存。其中，0x00000～9FFFF属于常规内存，由内存条提供；0xF0000～0xFFFFF由主板上的一个芯片提供，即ROM-BIOS。而0xB8000～0xBFFFF这段物理地址空间，是留给显卡的，由显卡来提供，用来显示文本。\n屏幕是如何显示内容的\r**显卡的工作是周期性地从显存中提取这些比特，并把它们按顺序显示在屏幕上。如果是比特“0”，则像素保持原来的状态不变，因为屏幕本来就是黑的；如果是比特“1”，则点亮对应的像素。**其工作原理如下所示\n屏幕上的每个字符对应着显存中连续2字节，前一个是字符的ASCII代码，后面是字符的显示属性，包括字符颜色（前景色）和底色（背景色）。\n如图所示，字符“H”的ASCII代码是0x48，其显示属性是0x07；字符“e”的ASCII代码是0x65，其显示属性是0x07。\n字符的显示属性（1字节）分为两部分，\n低4位定义的是前景色 高4位定义的是背景色 色彩主要由R、G、B这3位决定 K是闪烁位，为0时不闪烁，为1时闪烁 I是亮度位，为0时正常亮度，为1时呈高亮 如下，给出了背景色和前景色的所有可能值\nmbr功能实现\r编写mbr.S代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 ;主引导程序MBR，由BIOS通过jmp 0:0x7c00跳转 ;------------------------------------------ ;vstart=0x7c00表示本程序在编译时，起始地址编译为0x7c00 SECTION MBR vstart=0x7c00 ;由于BIOS是通过jmp 0:0x7c00跳转到MBR，故此时cs为0 ;对于 ds、es、fs、gs 这类 sreg，CPU 中不能直接给它们赋值，没有从立即数到段寄存器的电路实现,只有通过其他寄存器来中转，这里我们用的是通用寄存器ax来中转。 mov ax,cs mov ds,ax mov es,ax mov ss,ax mov fs,ax ;初始化栈指针 mov sp,0x7c00 ;存入显存的段基址 mov ax,0xb800 mov gs,ax ;------------------------------------------ ;------------------------------------------ ;利用0x06号功能进行清屏 ;INT 0x10 功能号：0x06 功能描述：上卷窗口清屏 ;输入: ;AH 功能号：0x06 ;AL=上卷的行数（如果为0，则表示全部） ;BH=上卷的行属性 ;(CL,CH)=窗口左上角(X,Y)位置 ;(DL,DH)=窗口右下角(X,Y)位置 ;返回值 ;无返回值 mov ax,0x0600 mov bx,0x0700 mov cx,0 ;左上角(0,0) mov dx,0x184f ;右下角(80,25) ;0x18=24，0x4f=79 int 0x10 ;调用BIOS中断函数 ;------------------------------------------ ;将要显示的字符串写入到显存中 mov byte [gs:0x00],\u0026#39;1\u0026#39; ;在第一个字节的位置写入要显示的字符“1” ;在第二个字节的位置写入显示字符（也就是字符1）的属性，其中A表示绿色背景，4表示前景色为红色 mov byte [gs:0x01],0xA4 mov byte [gs:0x02],\u0026#39; \u0026#39; mov byte [gs:0x03],0xA4 mov byte [gs:0x04],\u0026#39;M\u0026#39; mov byte [gs:0x05],0xA4 mov byte [gs:0x06],\u0026#39;B\u0026#39; mov byte [gs:0x07],0xA4 mov byte [gs:0x08],\u0026#39;R\u0026#39; mov byte [gs:0x09],0xA4 jmp $ ;times,用于指定后续数据将被重复多少次 ;$表示该行指令地址，$$表示该段（section）的开始地址，因此（$-$$）表示程序总共占用的字节大小 ;由于mbr程序的最后两个字节的内容（标志位0x55,0xaa）是固定的，而一个扇区总共是512字节， ;因此要把前510（512-2）个字节的内容给填满。 ;故times 510-($-$$) db 0这段代码就表示用0将本扇区剩余空间进行填充 times 510-($-$$) db 0 db 0x55,0xaa 编译代码\n1 nasm mbr.S -o mbr.bin 将程序写入磁盘，注意一定要用绝对路径\n1 dd if=/home/minios/osCode/miniOS_32/ch3/task1/mbr.bin of=/home/minios/bochs/hd60M.img bs=512 count=1 conv=notrunc 运行，运行时也一定要在bochs安装目录下\n1 ./bin/bochs -f boot.disk 从硬盘中加载程序到内存\r目前为止，我们已经实现的事情是\n完成了一个简单的mbr程序，它存放在磁盘的0盘0道1扇区\nBIOS启动后会自动从磁盘的0盘0道1扇区的位置寻找代码文件，如果该代码文件的最后两个字节的内容为0x55和0xaa，就说明该文件是mbr程序，于是BIOS就将该文件加载到内存的0x7c00位置开始运行\n接下来我们要做的事情是\n由于mbr程序只有512字节大小，不能完成内核的所有初始化任务，因此需要有另外一个程序，专门负责加载内核程序 因此mbr真正的任务其实是将将来的loader程序从磁盘加载到内存的某一位置 是的，mbr的任务和BIOS的任务是一样的：\nBIOS将mbr加载到内存的0x7c00之后运行mbr，mbr运行后将loader程序从磁盘再加载到内存的某一位置，唯一的区别在于，mbr从磁盘加载文件到内存的任务由我们自定义实现\n因此，接下来我们就要对磁盘有一个简单的认识\n磁盘的基本介绍\r磁盘的读写操作\r让硬盘工作，需要通过读写硬盘控制器的端口，端口就是位于 I0 控制器上的寄存器，此处的端口是指硬盘控制器上的寄存器，这里需要解释一些概念：\n硬盘控制器属于IO接口，硬盘控制器同硬盘的关系，如同显卡和显示器一样，它们都是专门驱动外部设备的模块电路，CPU 只同它们说话，由它们将 CPU的话转译给外部设备。这是它们的共同点，但不同的是显卡和显示器是分开的，硬盘控制器和硬盘是连接在一起的。 IO接口通过寄存器的方式同CPU通信，其内部有专用于数据交互的寄存器，只不过这里所说的这些寄存器位于IO接口中，为了区别于CPU内部的寄存器，I0 接口中的寄存器就称为端口(这可不是网络应用程序所开的那种端口，如网络服务器会启动80端口，这是两码事) IO端口的访问\rIntel 汇编语言的形式是:操作码目的操作数，源操作数。Intel 采用这种格式的原因可能是觉得这样表达“目的操作数”=“源操作数”更形象，如同a-6这种形式。\nin 指令用于从端口中读取数据，其一般形式是:\nin al,dx; in ax,dx; 其中al和ax用来存储从端口获取的数据，dx是指端口号。\n这是固定用法，只要用in指令，源操作数(端口号)必须是dx，而目的操作数是用 al，还是 ax，取决于dx端口指代的寄存器是8位宽度，还\n是16位宽度。\nout指令用于往端口中写数据，其一般形式是:\nout dx,al; out dx,ax; out立即数,al; out立即数,ax 另外\nin指令中，端口号只能用dx寄存器 out指令中，可以选用dx寄存器或立即数充当端口号 硬盘控制器的主要端口介绍\r这里也需要解释一些概念\n端口是按照通道给出的，并非是针对某块硬盘，通道其实就是主板跟硬盘通信的IDE接口插槽，一个主板一般对应有两个这样的插槽，也就是说，一个主板对应两个通道（主通道与副通道），一个通道对应两块硬盘（主盘和副盘） 每个通道都分别有主盘和从盘 要想操作某个通道上的某块硬盘，需要单独指定，这一点可通过指定device寄存器的第4位实现，0表示使用主盘，1表示使用从盘 另外，端口用途在读硬盘和写硬盘时还是有点区别的\n比如拿 Primary通道上的 0x1F1端口来说，读操作时若读取失败，里面存储的是失败状态信息，所以称为error 寄存器，并且 0x1F2端口中存储未读的扇区数写操作时就变成了feauture 寄存器，此寄存器用于写命令的参数。\n常用的硬盘操作方法\r让MBR使用硬盘\r编写mbr程序\r上述我们对硬盘做了几个简单的介绍，接下来我们就要改造目前的mbr程序，让其能够读取硬盘，并把硬盘上的loader程序加载到内存\n关于loader程序也有以下几点需要说明：\nloader中需要定义一些内核需要的数据结构，因此加载到内存就不能被覆盖 随着内核的功能越来越多，其占用的内存也就越来越多，故其内存地址也会想越来越高的位置发展，所以loader程序尽量放在低处 所以，我们对loader程序的规划如下：\nloader程序的磁盘位置在第0块磁盘的第2扇区 loader程序在内存中的加载地址为0x900 对此，我们可以将上述配置写入一个单独的文件中，并使用类似宏命令定义上述配置\nboot.inc\n1 2 3 ;-----loader and kernel----- LOADER_BASE_ADDR equ 0x900\t;loader在内存中位置 LOADER_START_SECTOR equ 0x2\t;loader在磁盘中的逻辑扇区地址，即LBA地址 定义好loader的基本配置后，我们就可以着手改造mbr程序了\nmbr.S\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 ;主引导程序MBR，由BIOS通过jmp 0:0x7c00跳转 ;------------------------------------------ %include \u0026#34;boot.inc\u0026#34; ;vstart=0x7c00表示本程序在编译时，起始地址编译为0x7c00 SECTION MBR vstart=0x7c00 ;由于BIOS是通过jmp 0:0x7c00跳转到MBR，故此时cs为0 ;对于 ds、es、fs、gs 这类 sreg，CPU 中不能直接给它们赋值，没有从立即数到段寄存器的电路实现,只有通过其他寄存器来中转，这里我们用的是通用寄存器ax来中转。 mov ax,cs mov ds,ax mov es,ax mov ss,ax mov fs,ax ;初始化栈指针 mov sp,0x7c00 ;存入显存的段基址 mov ax,0xb800 mov gs,ax ;------------------------------------------ ;------------------------------------------ ;利用0x06号功能进行清屏 ;INT 0x10 功能号：0x06 功能描述：上卷窗口清屏 ;输入: ;AH 功能号：0x06 ;AL=上卷的行数（如果为0，则表示全部） ;BH=上卷的行属性 ;(CL,CH)=窗口左上角(X,Y)位置 ;(DL,DH)=窗口右下角(X,Y)位置 ;返回值 ;无返回值 mov ax,0x0600 mov bx,0x0700 mov cx,0 ;左上角(0,0) mov dx,0x184f ;右下角(80,25) ;0x18=24，0x4f=79 int 0x10 ;调用BIOS中断函数 ;------------------------------------------ ;------------------------------------------ ;将要显示的字符串写入到显存中 mov byte [gs:0x00],\u0026#39;1\u0026#39; ;在第一个字节的位置写入要显示的字符“1” ;在第二个字节的位置写入显示字符（也就是字符1）的属性，其中A表示绿色背景，4表示前景色为红色 mov byte [gs:0x01],0xA4 mov byte [gs:0x02],\u0026#39; \u0026#39; mov byte [gs:0x03],0xA4 mov byte [gs:0x04],\u0026#39;M\u0026#39; mov byte [gs:0x05],0xA4 mov byte [gs:0x06],\u0026#39;B\u0026#39; mov byte [gs:0x07],0xA4 mov byte [gs:0x08],\u0026#39;R\u0026#39; mov byte [gs:0x09],0xA4 mov eax,LOADER_START_SECTOR ;起始扇区地址 mov bx,LOADER_BASE_ADDR ;要写入的内存地址 mov cx,1 ;待读入的扇区数目 call rd_disk_m16 ;调用磁盘读取程序 jmp LOADER_BASE_ADDR; ;------------------------------------------ ;函数功能：读取硬盘的n个扇区 ;参数： ;eax：LBA扇区号 ;bx：要写入的内存地址 ;cx：待读入的扇区数目 rd_disk_m16: ;out命令，通过端口向外围设备发送数据 ;其中目的操作数可以是8为立即数或者寄存器DX,源操作数必须是寄存器AL或者AX ;因此需要将之前ax中保存的值进行备份 mov esi,eax mov di,cx ;正式读写硬盘 ;第一步：设置要读取的扇区数目 mov dx,0x1f2 mov ax,cx out dx,ax mov eax,esi\t;恢复eax的值 ;第二步：将LBA的地址存入0x1f3~0x1f6 ;LBA的0~7位写入端口0x1f3 mov dx,0x1f3 out dx,al ;LBA的8~15位写入端口0x1f4 mov cl,8 shr eax,cl\t;将ax右移8位 mov dx,0x1f4 out dx,al ;LBA的16~23位写入端口0x1f5 shr eax,cl mov dx,0x1f5 out dx,al ;LBA的24~27位写入端口0x1f6 shr eax,cl\t;右移8位 and al,0x0f\t;与0000 1111相与，取后四位 or al,0xe0\t;设置7~4位为1110，表示lba模式 mov dx,0x1f6 out dx,al ;第三步，向0x1f7端口写入读命令，0x20 mov dx,0x1f7 mov al,0x20 out dx,al ;第四步，检测硬盘状态 .not_ready: nop ;空操作，什么也不做，相当于sleep，只是为了增加延迟 in al,dx ;由于读取硬盘状态信息的端口仍旧是0x1f7，因此不需要再为dx指定端口号 and al,0x88 ;取出状态位的第3位和第7位 ;其中第3位若为1表示硬盘控制器已经准备好数据传输,第7位为1表示硬盘忙 cmp al,0x08 ;cmp为减法指令，如果两个操作数相等，标志寄存器ZF会被置为1 ;此处是为了判断第7位是否为1，如果为1，说明硬盘忙，则减法的结果应该为0，相应ZF寄存器的值会被置为1 jnz .not_ready ;若未准备好，则继续等 ;JNZ是条件跳转指令，它表示\u0026#34;Jump if Not Zero\u0026#34;， ;也就是如果零标志位（ZF）不为0，则进行跳转。否则不进行跳转 ;第五步，从0x1f0端口读取数据 mov ax,di ;di是之前备份的要读取的扇区数 mov dx,256 mul dx ;一个扇区512字节，每次读取两个字节，需要读取di*256次 ;mul指令表示乘法操作，当只有一个操作数时，被乘数隐含在al或者ax中 mov cx,ax ;cx在此时表示要循环读取的次数 mov dx,0x1f0 .go_on_read: in ax,dx ;从0x1f0端口读取2个字节的数据到寄存器ax mov [bx],ax ;读取的数据写入bx寄存器所指向的内存 add bx,2 ;目的内存地址偏移2个字节继续循环读取剩余的数据 loop .go_on_read ret times 510-($-$$) db 0 db 0x55,0xaa 编译mbr程序\r1 nasm ./mbr.S -o mbr.bin 将MBR程序写入磁盘的MBR扇区内\r1 dd if=/home/minios/osCode/miniOS_32/ch3/task2/mbr.bin of=/home/minios/bochs/hd60M.img bs=512 count=1 conv=notrunc 此时如果我们运行mbr程序，会发现程序依旧显示的是原来mbr的内容，这是因为我们并未实现loader程序，也就是说此时磁盘的0块2号扇区的位置是空的\n实现内核加载器\r上个部分，我们完成了mbr程序的书写，并使用汇编实现了一个从磁盘加载文件到内存的函数\n本部分内容我们将使用这个函数将loader加载到内存\n为了验证是否成功的将loader程序加载到指定内存并运行，我们也简单将loader程序实现了一个屏幕打印功能来做测试，具体与内核相关的功能我们在后续章节详述\n编写loader程序\rloader.S\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 %include \u0026#34;boot.inc\u0026#34; SECTION vstart=LOADER_BASE_ADDR ;------------------------------------------ ;将要显示的字符串写入到显存中 mov byte [gs:0x00],\u0026#39;2\u0026#39;;在第一个字节的位置写入要显示的字符“1” ;在第二个字节的位置写入显示字符（也就是字符1）的属性，其中A表示绿色背景，4表示前景色为红色 mov byte [gs:0x01],0xA4 mov byte [gs:0x02],\u0026#39; \u0026#39; mov byte [gs:0x03],0xA4 mov byte [gs:0x04],\u0026#39;L\u0026#39; mov byte [gs:0x05],0xA4 mov byte [gs:0x06],\u0026#39;O\u0026#39; mov byte [gs:0x07],0xA4 mov byte [gs:0x08],\u0026#39;A\u0026#39; mov byte [gs:0x09],0xA4 mov byte [gs:0x0a],\u0026#39;D\u0026#39; mov byte [gs:0x0b],0xA4 mov byte [gs:0x0c],\u0026#39;E\u0026#39; mov byte [gs:0x0d],0xA4 mov byte [gs:0x0e],\u0026#39;R\u0026#39; mov byte [gs:0x0f],0xA4 jmp $ 编译loader程序\r1 nasm ./loader.S -o loader.bin 将loader程序写入磁盘内\r按照之前的约定，我们对loader程序在磁盘中的位置安排在2号扇区内\n1 dd if=/home/minios/osCode/miniOS_32/ch3/task2/loader.bin of=/home/minios/bochs/hd60M.img bs=512 count=1 seek=2 conv=notrunc bs=512：bs 代表块大小（Block Size）。指定数据块的大小为 512 字节。即，每次读取和写入操作将处理 512 字节的数据。通常，磁盘的扇区大小为 512 字节。 count=1：count 指定了要复制的块数。在这里值为 1，表示只复制 1 个块（512 字节）。因此，loader.bin 文件的前 512 字节将被写入到目标磁盘映像的特定位置。 seek=2：seek 指定了目标文件中的偏移量（以块为单位）。此处的 seek=2 表示将目标文件的写入位置移动到距离文件开头 2 个块的位置。由于每个块是 512 字节，所以这意味着文件将被写入到磁盘映像的 1024 字节处（2 * 512 = 1024 字节）。该选项常用于在磁盘映像文件中跳过某些区域（例如引导扇区），并将文件内容写入指定的偏移位置。 conv=notrunc：conv 是转换选项，notrunc 表示在写入时不截断输出文件。默认情况下，如果目标文件已经存在，dd 会将其截断为 0 长度文件，然后开始写入。如果使用 notrunc，则文件将继续写入而不截断它。这样可以确保在目标磁盘映像中不会丢失原有数据，且 loader.bin 会追加写入到指定位置。 在boch安装位置处运行bochs模拟器\n1 ./bin/bochs -f boot.disk 如上，屏幕输出了loader程序的内容，因此mbr成功将loader程序从我们规定的磁盘位置加载到了我们规定的内存位置\n","date":"2024-12-10T00:00:00Z","image":"http://localhost:1313/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9C%9F%E8%B1%A1%E8%BF%98%E5%8E%9F/index3.jpg","permalink":"http://localhost:1313/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9C%9F%E8%B1%A1%E8%BF%98%E5%8E%9F%E7%AC%AC%E4%B8%89%E7%AB%A0%E5%AE%8C%E5%96%84mbr/","title":"《操作系统真象还原》第三章——完善MBR"},{"content":"本章节所有代码托管在\nminiOS_32\n本章节任务\r上一节，我们完成了汇编调试器nasm和虚拟机bochs安装，本节我们将正式开始手写操作系统\n任务简介\r完成mbr主引导记录的代码编写，并完成编译，本节完成的代码编译并非真正的MBR主引导程序，而是为了测试mbr程序是否会被加载到0x07c00处被正确执行 将编译生成的主引导记录内容刻录到我们的创建的启动硬盘中 mbr主引导程序说明\rmbr主引导记录程序必须存放在磁盘的0盘0道1扇区，这样BIOS程序才能进行加载\nmbr主引导记录程序的文件大小必须是512字节\n程序的第510字节和第511字节处的内容必须是0x55和0xaa，BIOS程序会检查这两个字节标志来判断是否是mbr程序，否则BIOS不会加载该程序，即便它位于磁盘的0盘0道1扇区\n前置知识\r通用寄存器介绍\r如图所示，8086处理器内部有8个16位的通用寄存器，都是由16比特组成的，并分别被命名为AX、BX、CX、DX、SI、DI、BP、SP。\n这8个寄存器中的前4个，即AX、BX、CX和DX，又各自可以拆分成两个8位的寄存器来使用，总共可以提供8个8位的寄存器AH、AL、BH、BL、CH、CL、DH和DL。此外，将一个16位的寄存器当成两个8位的寄存器来用时，对其中一个8位寄存器的操作不会影响到另一个8位寄存器。\n以寄存器AX为例，它可以分成两个独立的寄存器AH和AL。寄存器AX有16比特，但是，位0到位7这8比特属于寄存器AL；位8到位15这8比特属于寄存器AH。因此，我们说，寄存器AH是寄存器AX的高字节部分；寄存器AL是寄存器AX的低字节部分。同时，寄存器AX的内容也是由寄存器AH的内容和寄存器AL的内容组合而成的。\n虽说是通用寄存器，但是各个寄存器其实都用一些约定俗成的习惯用法，比如cx寄存器常用于循环指令中的循环计数，bx常用于基址寄存器等，以下是各寄存器的常用场景\n实模式下的内存布局\rIntel 8086有 20条地址线，故其可以访问 1MB的内存空间，即2的20次方=1048576=1MB，地址范围若按十六进制来表示，是0x00000到0xFFFFF。\n地址0~0x9FFFF处是DRAM，也就是理论上的内存\n顶部的 0xF0000~0xFFFFF，这64KB的内存是ROM，其中存的是BIOS的代码\nBIOS 的主要工作是检测、初始化硬件，同时建立中断向量表，因此可以通过“int 中断号”来实现相关的硬件调用，当然 BIOS 建立的这些功能就是对硬件的 IO 操作 地址总线宽度决定了可以访问的内存空间大小，如16位机的地址总线为20位，其地址范围是1MB，32位地址总线宽度是32位，其地址范围是4GB。\n但在计算机中,并不是只有插在主板上的内存条需要通过地址总线访问，还有一些外设同样是需要通过地址总线来访问的。\n若把全部的地址总线都指向物理内存，那其他设备该如何访问呢?由于这个原因，只好在地址总线上提前预留出来一些地址空间给这些外设用，这片连续的地址给显存，这片连续的地址给硬盘控制器等。留够了以后，地址总线上其余的可用地址再指向 DRAM，也就是指插在主板上的内存条、我们眼中的物理内存。示意如图所示。\n完整内存布局如下\n计算机的启动过程\r计算机的加电和复位\r当计算机开始启动时，就会给处理器进行加电，同时处理器此时就会执行硬件初始化，然后将内部寄存器的内容初始化到预置的状态。\n在INTEL8086处理器中，初始化操作将使代码段寄存器（CS）的内容置为0xFFFF，其他所有寄存器中的内容全部为0x0000，包括指令指针寄存器（IP）。\n这是有原因的，因为此时CS=0xFFFF，IP=0x0000，因此处理器要取的第一条指令就位于0xFFFF0，这正是BIOS的入口地址。如图所示，正好位于ROM中，而ROM中固化了开机时需要的指令。\n另一方面，处理器取指令执行的自然顺序是从内存的低地址往高地址推进。如果从0xFFFF0开始执行，这个位置离1MB内存的顶端（物理地址0xFFFFF）只有16字节的长度，一旦IP寄存器的值超过0x000F，比如IP=0x0011，那么，它与CS一起形成的物理地址将因为溢出而变成0x00001，这将回绕到1MB内存的最底端。所以，ROM中位于物理地址0xFFFF0的地方，通常是一个跳转指令，它通过改变CS和IP的内容，使处理器从ROM中的较低地址处开始取指令执行。如：\n1 jmp 0xf000:0xe05b 在这里，“jmp”是跳转(jump)的简化形式；0xf000是要跳转到的段地址，用来改变CS寄存器的内容；0xe05b是目标代码段内的偏移地址，用来改变IP寄存器的内容。因此，目标位置的物理地址是0xfe05b。一旦执行这条指令，处理器将开始从指定的“段:偏移”处开始重新取指令执行。 ROM-BIOS的容量是有限的，当它完成自己的使命后，最后所要做的，就是从辅助存储设备(如硬盘)读取指令数据，然后转到那里开始执行。\n**硬盘的第一个扇区是0面0道1扇区，或者说是0头0柱1扇区，这个扇区称为主引导扇区。**如果计算机的设置是从硬盘启动的，那么，ROM-BIOS将读取硬盘主引导扇区的内容，将它加载到内存地址0x0000:0x7c00（也就是物理地址0x07C00），然后用一个jmp指令跳到那里接着执行。\n1 jmp 0x0000,0x7c00 上述过程的图解如下\nmbr初步实现\r创建mbr.S文件\r文件功能：在屏幕上打印字符串“1 MBR”，背景色为黑色，前景色（字体颜色）为绿色\n功能实现方式：借助BIOS建立好的例程0x10号中断，可将0x10号中断看做一个函数，函数可根据不同的输入可实现不同的功能，因此要有一个参数表示要实现的功能，也就是接下来要说的功能号参数\n0x10号中断调用方式： 将功能号送入ah寄存器，不同的功能号代表不同的功能 其余输入参数可依据具体的功能将参数送入不同的寄存器即可 内容如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 ;主引导程序MBR，由BIOS通过jmp 0:0x7c00跳转 ;------------------------------------------ ;vstart=0x7c00表示本程序在编译时，起始地址编译为0x7c00 SECTION MBR vstart=0x7c00 ;由于BIOS是通过jmp 0:0x7c00跳转到MBR，故此时cs为0 ;对于 ds、es、fs、gs 这类 sreg，CPU 中不能直接给它们赋值，没有从立即数到段寄存器的电路实现,只有通过其他寄存器来中转，这里我们用的是通用寄存器ax来中转。 mov ax,cs mov ds,ax mov es,ax mov ss,ax mov fs,ax ;初始化栈指针 mov sp,0x7c00 ;------------------------------------------ ;------------------------------------------ ;利用0x06号功能进行清屏 ;INT 0x10 功能号：0x06 功能描述：上卷窗口清屏 ;输入: ;AH 功能号：0x06 ;AL=上卷的行数（如果为0，则表示全部） ;BH=上卷的行属性 ;(CL,CH)=窗口左上角(X,Y)位置 ;(DL,DH)=窗口右下角(X,Y)位置 ;返回值 ;无返回值 mov ax,0x0600 mov bx,0x0700 mov cx,0 ;左上角(0,0) mov dx,0x184f ;右下角(80,25),VGA模式下，一行只能容纳80个字符，共25行 ;下标从0开始，所以0x18=24，0x4f=79 int 0x10 ;调用BIOS中断函数 ;------------------------------------------ ;------------------------------------------ ;获取光标位置 ;功能号：3 ;输入： ;ah:3 ;bh:存储待获取光标的页号 ;输出: ;ch=光标开始行，cl=光标结束行 ;dh=光标所在行号，cl=光标所在列号 mov ah,3 mov bh,0 int 0x10 ;------------------------------------------ ;------------------------------------------ ;打印字符串,使用13号子功能 mov ax,message ;es:bp为串首地址，es与cs的值一样，开始已经被初始化 mov bp,ax ;光标位置使用dx中的内容，cx中的内容可忽略 ;cx为串的长度，不包括结束符0的字符个数 mov cx,5 ;ah=13表示使用13号子功能 ;al=01表示设置写字符的方式，其中01表示显示字符串并跟随光标移动 mov ax,0x1301 ;bh存储要显示的页号，此处是第0页（这里的页就是屏，因此bh指定的第0页就是第0屏的意思） ;bl是字符属性，02h表示黑底绿字 mov bx,0x2 int 0x10 jmp $ ;定义打印的字符串 message db \u0026#34;1 MBR\u0026#34; ;$表示该行指令地址，$$表示该段（section）的开始地址，因此（$-$$）表示程序总共占用的字节大小 ;由于mbr程序的最后两个字节的内容（标志位0x55,0xaa）是固定的，而一个扇区总共是512字节， ;因此要把前510（512-2）个字节的内容给填满。 ;故times 510-($-$$) db 0这段代码就表示用0将本扇区剩余空间进行填充 times 510-($-$$) db 0 db 0x55,0xaa 编译mrb.S文件\r1 nasm -o mbr.bin mbr.S 将文件内容写入0盘0道1扇区，注意一定要用绝对路径\r1 dd if=/home/minios/osCode/miniOS_32/ch2/mbr.bin of=/home/minios/bochs/hd60M.img conv=notrunc 1 2 3 1+0 records in 1+0 records out 512 bytes copied, 0.00255388 s, 200 kB/s dd命令可用于将一个文件写入到磁盘中，其中\n选项if表示输入文件位置，即被写的文件，of表示要将输入文件写入到哪里，~/bochs是笔者的bochs安装目录\nnotrunc 表示 \u0026ldquo;no truncate\u0026rdquo;，即不截断文件。这意味着如果输出文件（/home/minios/bochs/hd60M.img）的大小小于输入文件（/home/minios/osCode/mbr.bin）的大小，那么输出文件将不会被截断，而是保留原有的大小，并且只覆盖输出文件的前面部分。\n启动bochs查看结果\r进入bochs安装目录，输入以下指令，注意运行时一定要在bochs安装目录下\n1 ./bin/bochs -f boot.disk 老规矩，启动后首先按下数字6，然后再按键盘c，成功之后就会看到屏幕显示的字符串“1 MBR”\n这就说明计算机启动后成功把我们的mbr程序加载到内存并运行成功了\n参考\n《x86汇编语言：从实模式到保护模式》\n《操作系统真象还原》\n","date":"2024-12-09T00:00:00Z","image":"http://localhost:1313/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9C%9F%E8%B1%A1%E8%BF%98%E5%8E%9F/index2.jpg","permalink":"http://localhost:1313/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9C%9F%E8%B1%A1%E8%BF%98%E5%8E%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0%E7%BC%96%E5%86%99mbr%E4%B8%BB%E5%BC%95%E5%AF%BC%E8%AE%B0%E5%BD%95/","title":"《操作系统真象还原》第二章——编写MBR主引导记录"},{"content":"安装NASM\r安装\r1 sudo apt-get install nasm 安装完成后，如果可以查看到nasm的版本号即可视为安装成功\n1 nasm -version 测试\r创建一个asm文件\n1 vim hello.asm 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 section .data hello: db \u0026#39;Hello world!\u0026#39;,10 ; \u0026#39;Hello world!\u0026#39; plus a linefeed character helloLen: equ $-hello ; Length of the \u0026#39;Hello world!\u0026#39; string ; (I\u0026#39;ll explain soon) section .text global _start _start: mov eax,4 ; The system call for write (sys_write) mov ebx,1 ; File descriptor 1 - standard output mov ecx,hello ; Put the offset of hello in ecx mov edx,helloLen ; helloLen is a constant, so we don\u0026#39;t need to say ; mov edx,[helloLen] to get it\u0026#39;s actual value int 80h ; Call the kernel mov eax,1 ; The system call for exit (sys_exit) mov ebx,0 ; Exit with return code of 0 (no error) int 80h 编译\n1 nasm -f elf64 hello.asm 运行\n1 ./hello 如果可以正常运行没有报错说明安装成功\nBochs安装\rBochs下载与解压\r直接点击链接，等待3秒即可自动下载\n下载成功后解压文件\n1 tar -zxvf bochs-2.6.8.tar.gz 编译安装\r配置\r进入bochs-2.6.2文件夹，执行以下语句，其中我把bochs安装在了我的/home/minios/bochs目录下，读者可自行修改\n1 2 3 4 5 6 7 ./configure \\ --prefix=/home/minios/bochs \\ --enable-debugger \\ --enable-disasm \\ --enable-iodebug \\ --enable-x86-debugger \\ --with-x --with-x11 配置过程中如有报错，可自行网上查阅修改\n本人遇到的错误：\n1 ERROR: pkg-config was not found, or unable to access the gtk+-2.0 package. Install pkg-config and the gtk+ development p 解决方案：\n1 sudo apt-get install libgtk2.0-dev 配置成功后的界面如下所示\n编译\r执行make命令进行编译\n1 make 注意，刚开始我使用bochs2.6.2版本编译的时候会报错，但是我换成bochs2.6.8版本后就直接编译成功了\n编译成功界面\n安装\r1 make install 安装成功的标志： 在安装路径（/home/minios/bochs）下生成了bin文件夹\n配置Bochs\r进入bochs目录（安装目录），新建boot.disk文件，写入以下配置，注意将相应目录修改为自己设置的目录\n1 vim boot.disk 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 # 设置 Bochs 在运行过程中能够使用的内存，本例为 32MB megs: 32 # 设置对应真实机器的 BIOS 和 VGA BIOS romimage: file=/home/minios/bochs/share/bochs/BIOS-bochs-latest vgaromimage: file=/home/minios/bochs/share/bochs/VGABIOS-lgpl-latest # 设置 Bochs 使用的磁盘 # floppya: 1_44=a.img, status=inserted # 选择启动盘符 # boot: flopy # 默认从软盘启动 boot: disk # 从硬盘启动，我们的任何代码都将直接写在硬盘上，所以不会再有读写软盘的操作。 # 设置日志文件输出 log: bochs.out # 关闭鼠标，打开键盘，按照书上写会报错 mouse: enabled=0 #keyboard: enabled=1, keyboard: keymap=/home/minios/bochs/share/bochs/keymaps/x11-pc-us.map # 硬盘设置 ata0: enabled=1, ioaddr1=0x1f0, ioaddr2=0x3f0, irq=14 # 增加 Bochs 对 GDB 的支持，GDB 远程连接到此机器的 1234 端口便可调试 # gdbstub: enabled=1, port=1234, test_base=0, data_base=0, bss_base=0 保存退出后，启动bochs\n1 ./bin/bochs -f boot.disk 如下图所示， 看到数字[6]就直接按下回车，之后再按键盘c，否则报错就检查错误，如配置文件中的路径是否写对等\n安装成功！\n创建启动盘\r仔细观察上述运行成功的bochs，可以看到bochs会报错显示\nBoot failed:could not read the boot disk\n那是因为此时系统中还没有启动盘，接下来我们需要创建启动盘\nbochs给我们提供了创建虚拟硬盘的工具，使用如下命令可以查看相关指令\n1 ./bin/bximage --help 接下来我们来根据帮助创建虚拟硬盘，在终端输入\n1 ./bin/bximage 其余具体步骤如下所示\n接下来，我们需要将创建的虚拟硬盘的信息写入到配置文件中，注意柱面、磁道和扇区信息（上图红框中的CHS信息）也要写进去\n打开配置文件\n1 vim boot.disk 加入以下代码\n1 ata0-master: type=disk, path=\u0026#34;hd60M.img\u0026#34;, mode=flat,cylinders=121,heads=16,spt=63 完整文件内容\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 # 设置 Bochs 在运行过程中能够使用的内存，本例为 32MB megs: 32 # 设置对应真实机器的 BIOS 和 VGA BIOS romimage: file=/home/minios/bochs/share/bochs/BIOS-bochs-latest vgaromimage: file=/home/minios/bochs/share/bochs/VGABIOS-lgpl-latest # 设置 Bochs 使用的磁盘 # floppya: 1_44=a.img, status=inserted # 选择启动盘符 # boot: flopy # 默认从软盘启动 boot: disk # 从硬盘启动，我们的任何代码都将直接写在硬盘上，所以不会再有读写软盘的操作。 # 设置日志文件输出 log: bochs.out # 关闭鼠标，打开键盘，按照书上写会报错 mouse: enabled=0 #keyboard: enabled=1, keyboard: keymap=/home/minios/bochs/share/bochs/keymaps/x11-pc-us.map # 硬盘设置 ata0: enabled=1, ioaddr1=0x1f0, ioaddr2=0x3f0, irq=14 #新加入的代码,虚拟硬盘配置 ata0-master: type=disk, path=\u0026#34;hd60M.img\u0026#34;, mode=flat,cylinders=121,heads=16,spt=63 # 增加 Bochs 对 GDB 的支持，GDB 远程连接到此机器的 1234 端口便可调试 #gdbstub: enabled=1, port=1234, test_base=0, data_base=0, bss_base=0 保存退出，再次运行bochs\n1 ./bin/bochs -f boot.disk 可以看到，虽然仍旧报错，但是报错信息不再是不能读取启动盘，说明启动盘已经创建好了\nBoot failed:not a bootable disk\n参考：\n《操作系统真象还原》第一章 \u0026mdash;- 安装Vmware Station 安装Ubuntu 装载配置Bochs 安装Vmware tools 开始乘帆历险！_学习操作系统真相还原安装虚拟机-CSDN博客\n操作系统真象还原环境搭建-详细实践版 - 知乎\n","date":"2024-12-06T00:00:00Z","image":"http://localhost:1313/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9C%9F%E8%B1%A1%E8%BF%98%E5%8E%9F/index1.jpg","permalink":"http://localhost:1313/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9C%9F%E8%B1%A1%E8%BF%98%E5%8E%9F%E7%AC%AC%E4%B8%80%E7%AB%A0ubuntu%E5%AE%89%E8%A3%85%E6%B1%87%E7%BC%96%E8%B0%83%E8%AF%95%E5%99%A8nasm%E4%BB%A5%E5%8F%8Abochs%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/","title":"《操作系统真象还原》第一章——ubuntu安装汇编调试器NASM以及Bochs的安装与配置"},{"content":"介绍\r作用\rLinux sort 命令用于将文本文件内容加以排序。\nsort 可针对文本文件的内容，以行为单位来排序。\n注意\n1、排序时，默认是按每行/每个域的首字符排序，数字的优先级要大于字符的优先级\n2、不指定升序还是降序时，默认是升序\n语法\r1 sort [-bcdfimMnr][-o\u0026lt;输出文件\u0026gt;][-t\u0026lt;分隔字符\u0026gt;][+\u0026lt;起始栏位\u0026gt;-\u0026lt;结束栏位\u0026gt;][--help][--verison][文件][-k field1[,field2]] 参数\r-b 忽略每行前面开始出的空格字符。 -c 检查文件是否已经按照顺序排序。 -d 排序时，处理英文字母、数字及空格字符外，忽略其他的字符。 -f 排序时，将小写字母视为大写字母。 -i 排序时，除了040至176之间的ASCII字符外，忽略其他的字符。 -m 将几个排序好的文件进行合并。 -M 将前面3个字母依照月份的缩写进行排序。 -n 依照数值的大小排序。 -u 意味着是唯一的(unique)，输出的结果是去完重了的。 -o\u0026lt;输出文件\u0026gt; 将排序后的结果存入指定的文件。 -r 以相反的顺序来排序。 -t\u0026lt;分隔字符\u0026gt; 指定排序时所用的栏位分隔字符。 +\u0026lt;起始栏位\u0026gt;-\u0026lt;结束栏位\u0026gt; 以指定的栏位来排序，范围由起始栏位到结束栏位的前一栏位。 \u0026ndash;help 显示帮助。 \u0026ndash;version 显示版本信息。 [-k field1[,field2]] 按指定的列进行排序。 重点掌握\r1 -t -n -o -u - k,尤其是-k。 实例\r-r，逆序排序\r数据准备\n1 cat salary.txt 1 2 3 4 5 google 110 5000 baidu 100 5000 guge 50 3000 sohu 100 4500 sohu 30 1500 实验\n如下所示，单独使用sort命令对文件内容进行排序，默认情况按照第一列字段内容的首字母进行升序排序\n1 sort salary.txt 1 2 3 4 5 baidu 100 5000 google 110 5000 guge 50 3000 sohu 100 4500 sohu 30 1500 使用-r选项可按照逆序排序，但排序依据仍旧默认是第一列字段内容的首字母\n1 sort -r salary.txt 1 2 3 4 5 sohu 30 1500 sohu 100 4500 guge 50 3000 google 110 5000 baidu 100 5000 -k，指定按照某列进行排序\r我们先使用salary.txt文本内容进行实验，输入以下命令\n1 sort -k 2 salary.txt 观察输出结果可以发现，目前的排序结果是按照第二列字段的内容进行升序排序的\n1 2 3 4 5 sohu 100 4500 baidu 100 5000 google 110 5000 sohu 30 1500 guge 50 3000 但这个结果其实只是一个巧合，为什么这么说呢？我们看接下来的实验\n-n，按照数值大小排序\r数据准备\n1 cat nums.txt 1 2 3 4 5 6 tom 10 su 15 john 2 han 20 bell 25 jom 7 我们看使用 nums.txt 文件内容的第二列进行排序的结果\n1 sort -k2 nums.txt 观察实验结果，我们看到\n我们期望的是能够按照 nums.txt 的第二列内容进行升序排序 但实际情况是，出现了数字10排列在数字2之前的结果 1 2 3 4 5 6 tom 10 su 15 john 2 han 20 bell 25 jom 7 出现这个结果的原因也很简单，因为默认情况下，sort命令是将文本按照字符串进行排序的，举个例子，上述数字“10”和数字“2”，\n它直接将这两个数字按照字符串处理 于是字符串“10”的第一个字符是“1”，而字符串“2”的第一个字符是2 字符“1”比字符“2”小，因为sort只按照首字符进行排序，因此最后的结果就变成了“10”比“2”小 1 sort -k2 -n nums.txt 上述命令的意思是，让sort将第二列内容视为数值，并以此为依据进行升序排序，观察实验结果这次是符合预期的\n1 2 3 4 5 6 john 2 jom 7 tom 10 su 15 han 20 bell 25 同样的，我们也可以将其按照降序排序，如下所示\n1 sort -k2 -n -r nums.txt 1 2 3 4 5 6 bell 25 han 20 su 15 tom 10 jom 7 john 2 -t，指定字段分隔符\r该选项的作用是指定字段分隔符\n数据准备\n1 cat data.csv 1 2 3 4 name,age,city Alice,30,New York Bob,25,Los Angeles Charlie,35,Chicago 实验\n我们首先不指定分隔符，想让内容按照第二列数据，也就是按照年龄进行升序排序，查看结果\n1 sort -k2 -n data.csv 可以看到，下述的输出结果也是不符合我们预期的，这又是为什么呢？\n1 2 3 4 Alice,30,New York Bob,25,Los Angeles Charlie,35,Chicago name,age,city 造成这个结果的原因是，\n当我们想使用-k选项找到第二列，它首先需要知道文本是按照什么分割符划分第一列第二列 我们文件内容的每一行的每一列都是按照逗号进行分割的，sort命令不知道这一点 默认情况下，sort默认使用空格或者制表符作为分隔符，因此它此时找到的第二列是一个空列，也就是每一行的末尾 因此，这就是-t选项的作用，让sort知道我们的文本是按照什么分割符进行划分的，好让-k选项真正生效\n重新输入命令\n1 sort -t , -k2n data.csv 1 2 3 4 name,age,city Bob,25,Los Angeles Alice,30,New York Charlie,35,Chicago 可以看到，这次的输出结果是符合预期的\n练习，组合命令的使用\r到这里，我们先写一道题，熟悉一下上述学过的命令\n题目：在salary中，按薪水进行降序排列，薪资相同时，按公司人数升序排列。\n首先回顾一下我们的salary.txt文本内容，如下，第二列数据表示公司人数，第三列数据表示公司薪水\n1 2 3 4 5 6 google 110 5000 baidu 100 5000 guge 50 3000 sohu 100 4500 sohu 30 1500 sohu 30 2 我们直接给出答案，然后进行分析\n1 sort -n -k3r -k2 salary.txt 输出结果\n1 2 3 4 5 6 baidu 100 5000 google 110 5000 sohu 100 4500 guge 50 3000 sohu 30 2 sohu 30 1500 首先说明，这个输出结果是符合预期的，那么为什么要这么写\n在此需要指出\n-n是全局参数，所有指定的域（列）都有效（按数值排序） 3r中的紧跟这数字的r是局部参数，仅对-k 3r中r前面的数字所对应的第3个域（列）有效 后面的 -k 2 没有指定降序，那么默认第2个域（列）就是升序排列的。 -o,把结果输出到指定文件\r在sort排序中，如果用 \u0026gt; 重定向来把结果输出到源文件，源文件会被置为空。\n此时，-o的作用就凸显出来了。\n我们先备份一下数据进行实验\n1 2 3 4 5 6 7 8 (base) jl@jin-X299X-AORUS-MASTER:~/test$ cp salary.txt s.txt (base) jl@jin-X299X-AORUS-MASTER:~/test$ cat s.txt google 110 5000 baidu 100 5000 guge 50 3000 sohu 100 4500 sohu 30 1500 sohu 30 2 输入以下命令，我们期望的结果是，让文件按照第二列进行排序，并将排序的结果保存起来\n1 sort -k2n s.txt \u0026gt; s.txt 但现实情况是，此时的s.txt文件被置空了，也就是说，如果要把排序的结果回写到源文件，需要用-o参数，不能用重定向。\n如果需要保存排序的结果，正确的命令应该是\n1 sort -k2n s.txt -o s.txt -u 去除重复行 | -k M,N消除指定域的重复行\r再次回顾我们的salary.txt文件内容，我们看到，文本中有三条sohu相关的行，我们现在的需求是，我们想去除重复的行\n1 2 3 4 5 6 google 110 5000 baidu 100 5000 guge 50 3000 sohu 100 4500 sohu 30 1500 sohu 30 2 首先尝试使用下述命令\n1 sort -u salary.txt 实验失败\n1 2 3 4 5 6 baidu 100 5000 google 110 5000 guge 50 3000 sohu 100 4500 sohu 30 1500 sohu 30 2 如果我们显示指定列呢？也就是这样\n1 sort -u -k1 salary.txt 还是失败！为什么呢？\n1 2 3 4 5 6 baidu 100 5000 google 110 5000 guge 50 3000 sohu 100 4500 sohu 30 1500 sohu 30 2 这是因为，sort排序的时候，****-u不配合其他任何参数**时，只有*完全相同的重复行*才会被消除。\n另外还需要给出一个知识点，关于**-k选项，其实是有两个参数的**，这个两个参数指定了一个范围\n-K M,N\nM的意思是，从哪一列开始的第一个字符作为比较的依据；N表示截止到哪一列的最后一个字符比较结束。\nM,N是一个(域的)范围，如果这个M,N结合-u使用。那么-u的比较范围就是第M列的第一个字符到第N列最后一个字符之间的这段内容。\n如果数字N被省略，那么-u比较的范围就是从M域开始，一直到每行的最后一个域的最后一个字符。\n因此，正确的命令应该如下，这条命令是说，从第一列的第一个字符开始，到第一列的最后一个字符进行检查，如果发现重复就去重\n1 sort -u -k 1,1 salary.txt 1 2 3 4 baidu 100 5000 google 110 5000 guge 50 3000 sohu 100 4500 -k 的高级用法-k1.2,3.5\r通过上一案例的学习，对-k M,N有了一定了解，接下来的内容相对会比较容易理解一些。\n理论知识点：\n如果抛开M,N之间的逗号，单独说这个逗点\n-k 1.2 表示第1个列的第二个字符 -k 2.3 表示从第2个列的第三个字符。 案例：仅仅按工资表中第一列的第二个字符升序排列\n错误示范\n1 sort -k 1.2 salary.txt 1 2 3 4 5 6 baidu 100 5000 sohu 100 4500 sohu 30 1500 sohu 30 2 google 110 5000 guge 50 3000 正确示范\n1 sort -k 1.2,1.2 salary.txt 1 2 3 4 5 6 baidu 100 5000 google 110 5000 sohu 100 4500 sohu 30 1500 sohu 30 2 guge 50 3000 解析\n-k1.2,1.2 仅仅且只按照第一个域的第二个字母进行排序，不会再按其他字符进行排序。 -k1.2 先按照第一个域的第二个字母进行排序，第二个字母如果一样，再按照第二个字母后面的字母进行排序，依次类推，直到行尾最后一个字符。也就是说：google 和 sohu的第二个字母都是o,就开始看第三个字母，显然第三个字母h应该排在o的前面。 ","date":"2024-11-29T00:00:00Z","image":"http://localhost:1313/img/linux/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/index1.jpg","permalink":"http://localhost:1313/p/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%B8%80-sort/","title":"linux常用命令(一) —— sort"},{"content":"介绍\r单例模式的目的是确保某个类在整个应用程序中只有一个实例，并提供一个全局访问点来获取该实例。这个模式常常用来管理全局共享资源，如配置对象、数据库连接、线程池等。\n如下所示，我们通过new运算符创建出了类A的三个对象实例，而我们现在要做的是，如何设计类A，使得上述代码运行之后永远只产生同一个对象实例\n1 2 3 A* p1=new A(); A* p2=new A(); A* p3=new A(); 单例模式的核心要点：\n唯一性：保证类只有一个实例。 全局访问点：提供一个全局的静态方法来访问该实例。 单例模式的结构：\n私有构造函数：防止外部通过 new 关键字直接实例化对象。 静态成员变量：用于存储唯一的实例。 静态方法：提供外部获取实例的全局访问点。 设计方法\r接下来我们一步步设计代码，来观察单例模式是如何被设计出来的\n将构造函数设为私有\r这一步的目的在于拒绝用户使用构造函数创建对象，只能使用我们提供的静态方法创建一个全局对象\n1 2 3 4 5 class Singleton{ public: private: Singleton(){}; }; 声明全局对象并提供访问接口\r我们知道静态成员变量的特点是它在类的所有实例之间是共享的，因此，我们可将类实例直接创建出来，并声明为static\n1 2 3 4 5 6 class Singleton{ public: private: static Singleton instance_; Singleton(){}; }; 由于上述定义的实例对象是private的，因此我们需要定义一个公共接口，来供外部用户进行访问\n1 2 3 4 5 6 7 8 9 class Singleton{ public: static Singleton\u0026amp; getInstance(){ return instance_; } private: static Singleton instance_; Singleton(){}; }; 该接口声明是static的原因是，当用户调用接口时，对象实例还没有被创建出来，假如声明为普通成员函数，则普通成员函数的调用必须通过对象进行，这将成为一个矛盾点，因此如果想要用户使用这个函数，就必须要将其声明为static的\n拒绝对象的拷贝和赋值\r至此，我们已经完成了一个半成品，也就是说，这个时候我们要使用Sington对象，就必须通过其中的static成员函数getInstance来获取，而该函数返回的对象实例永远都是同一个实例\n但还有个问题是，编译器还会为我们创建拷贝构造函数和拷贝赋值运算符，因此，当我们进行对象拷贝操作的时候，这个实例对象就不是“单例”的了\n故而我们需要将拷贝构造和拷贝赋值运算符禁止掉\n1 2 3 4 5 6 7 8 9 10 11 12 13 class Singleton{ public: static Singleton\u0026amp; getInstance(){ return instance_; } private: static Singleton instance_; Singleton(){}; Singleton(const Singleton\u0026amp;)=delete; Singleton\u0026amp; operator=(const Singleton\u0026amp;)=delete; }; 单例模式的分类\r饿汉式单例模式\r饿汉式单例模式是指，当在类加载时就将实例创建出来了，上述我们实现的单例模式就是饿汉式单例模式\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #if 1 class Singleton{ public: static Singleton\u0026amp; GetInstance(){ return instance_; } private: static Singleton instance_; Singleton(){} Singleton(const Singleton\u0026amp;)=delete; Singleton\u0026amp; operator=(const Singleton\u0026amp;)=delete; }; //初始化静态变量 Singleton Singleton::instance_; #endif 饿汉式单例模式的特点是\n优点：\n实现简单、线程安全：在类加载时就创建了实例，不存在多线程并发访问的问题 执行效率高、没有加锁同步等额外操作 缺点：\n内存浪费：类加载时即创建实例，如果单例对象占用大量资源或者初始化耗时较长，会导致程序启动变慢。 无法延迟加载：即使没有使用到该单例对象，也会被创建 懒汉式单例模式\r由于饿汉式单例模式在类加载时就会创建对象，即使我们不使用它它也会存在，当对象数据占据空间较大时，这显然是一种浪费，因此我们设计出了第二种单例模式\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Singleton { public: static Singleton* GetInstance(){ // 将对象实例的创建延迟到第一次访问时 if(instance_==nullptr){ instance_=new Singleton(); } return instance_; } private: static Singleton *instance_; Singleton(){}; Singleton(const Singleton\u0026amp;)=delete; Singleton\u0026amp; operator=(const Singleton\u0026amp;)=delete; }; Singleton* Singleton::instance_=nullptr; 如上，我们将类中创建的对象实例声明为指针类型，这样当类加载的时候，内存中存在的是一个指针，而指针变量的大小在相同的操作系统下永远都是固定的，除此以外，在GetInstance方法的实现中，我们还将对象实例的创建延迟到了第一次访问的时候,平时如果我们不是该对象，该对象就不会被new出来\n懒汉式单例模式的线程安全问题\r问题复现\r在懒汉式单例模式的代码里，虽然可以实现对象的延迟加载，但是会存在多线程并发时代码的线程安全问题\n考虑一种情况，假如现在有两个线程，都要执行如下代码创建单例对象的实例\n1 Singleton* ptr1=Singleton::GetInstance(); 那么\n当线程1执行到这段代码时，开始执行下面这句代码时，突然切换回了线程2 而由于此时线程1并没有将对象创建创建出来就切换到了线程2，因此线程2也能执行到这段代码 1 if(instance_==nullptr) 那么问题来了，也就是说，此时线程1和线程2都执行到了上述这段代码，那么接下来，线程1和线程2就都可以创建这个“单例对象”\n因此，在这种情况下，下述对象的创建其实是被执行了两次\n1 instance_=new Singleton(); 这就是懒汉式单例模式的线程安全问题\n问题解决\r方法1\r第一种方法很自然的就会想到使用互斥量锁住这段创建对象的代码，如下所示\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Singleton{ public: static Singleton* getInstance(){ std::lock_guard\u0026lt;std::mutex\u0026gt; lock(_mutex); if(!instance){ instance_=new Singleton(); } return instance_; } void show(){ std::cout\u0026lt;\u0026lt;\u0026#34;this is singleton!\u0026#34;\u0026lt;\u0026lt;std::endl; } private: static Singleton* instance_; static std::mutex _mutex; Singleton(){}; Singleton(const Singleton\u0026amp;)=delete; Singleton\u0026amp; operator=(const Singleton\u0026amp;)=delete; }; Singleton* Singleton::instance_=nullptr; std::mutex Singleton::_mutex; 但是这样写的效率就会及其底下，在GetInstance成员函数中，就为了解决一个初始化该类对象时的互斥问题，居然在GetInstance中增加互斥量，导致所有调用该函数的调用者线程都被互斥一下，这非常影响性能。\n因为除了初始化那个时刻，其他的时候完全不需要互斥。一旦初始化完毕，不管是否互斥调用GetInstance，这个if（！instance）条件都不会成立，从而完全可以确保初始化完毕之后，“instance=new Singleton()；”代码行绝不会被再次执行。\n方法2\r方法2也被称之为双重锁定，先给出代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include\u0026lt;mutex\u0026gt; #if 1 class Singleton { public: static Singleton *GetInstance() { if (!instance_) { std::lock_guard\u0026lt;std::mutex\u0026gt; lock(mtx_); if (!instance_) instance_ = new Singleton(); } return instance_; } private: static Singleton *instance_; static std::mutex mtx_; Singleton() {}; Singleton(const Singleton \u0026amp;) = delete; Singleton \u0026amp;operator=(const Singleton \u0026amp;) = delete; }; // 静态成员变量定义：初始化为 nullptr Singleton* Singleton::instance_ = nullptr; // 静态成员变量初始化：mutex std::mutex Singleton::mtx_; #endif 使用互斥锁可以避免竞态问题的出现，但是会代码效率问题，但是如果我们此时在外层多加一层判断，那么一旦instance被创建成功后，因为最外面有一个条件判断if （instance ==NULL）在，这样就不会每次调用GetInstance都会创建一次互斥量。\n也就是说，平常的调用根本就执行不到创建互斥量的代码，而是直接执行“return instance_；”，这样调用者就能够直接拿到这个单例类的对象，所以肯定提高了执行GetInstance的效率。\n因此，互斥锁解决了多线程对单例对象创建的竞态问题，而双重判断解决了互斥锁带来的效率问题\n","date":"2024-11-24T22:30:22+08:00","image":"http://localhost:1313/img/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/SIngleton/singleton_index.jpg","permalink":"http://localhost:1313/p/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","title":"单例模式"}]